<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为何说三进制是效率最高的进制？以及其他一些与三进制有关的东西...</title>
    <url>/posts/1d122915.html</url>
    <content><![CDATA[<p>这是一次计算机导论的作业。老师提供了很多课题供我们选择，我选择的是 “有人说三进制是被证明理论上效率最高的进制，请广泛搜集相关资料，撰写关于三进制的科普报告，或者对其他进制进行对比和评价。</p>
<span id="more"></span>

<h2 id="为什么在理论上三进制是最高效率的进制？"><a href="#为什么在理论上三进制是最高效率的进制？" class="headerlink" title="为什么在理论上三进制是最高效率的进制？"></a>为什么在理论上三进制是最高效率的进制？</h2><blockquote>
<p>这里的内容来自知乎大佬 <a href="https://www.zhihu.com/people/bai-yun-long-52">@白云龙</a>的<a href="https://www.zhihu.com/question/435375360">这篇</a>回答。<br>B 站 up 主 <a href="https://space.bilibili.com/19319172">@差评君</a> 的<a href="https://www.bilibili.com/video/BV17b4y1U7TZ/">这个</a>视频中对这篇回答进行了动画形式的展现。</p>
</blockquote>
<p>首先，先让我们来约定一下什么叫 “进制的效率”：<br>$$<br>进制的效率 = \frac {表达的信息量}{表达这些信息所需的资源}<br>$$<br>比如我们需要表达十进制下 <code>0~999</code> 这 1000 个数字，这就是我们 $ 表达的信息量 $，我们选择用写有数字的牌子来表示它们。</p>
<ul>
<li><p>在十进制下，<code>0~999</code> 我们至少需要三位，每位上我们都需要 0~9 十个数字的牌子，所以三位一共是 30 个数字牌子；</p>
</li>
<li><p>在二进制下，<code>0~999</code> 是 <code>0~1111100111</code>，我们至少需要十位，每位是 0 或 1，所以一共是 20 个数字牌子；</p>
</li>
<li><p>在三进制下，<code>0~999</code> 是 <code>0~1101000</code>，至少七位，每位是 0、1 或 2，所以一共是 21 个数字牌子；</p>
</li>
<li><p>在四进制下，<code>0~999</code> 是 <code>0~33213</code>，需要 20 个数字牌子；</p>
</li>
<li><p>在五进制下，<code>0~999</code> 是 <code>0~12444</code>，需要 25 个数字牌子；</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>这些数字牌子的个数就是 $ 表达这些信息所需的资源 $。到目前为止，似乎二进制和四进制的效率最高。</p>
<p>但这样理解并不完全准确。因为实际上， 对于某些进制而言，对应数量的数字牌子其实不止能表达这么多信息。比如在二进制情况下，20 个数字牌子表达的数字总量应该是 $2^{10} = 1024 $ 个；在三进制的情况下，21 个数字牌子表达的数字总量却是 $3^7 = 2187$ 个；在四进制的情况下，20 个数字牌子表达的数字总量是 $4^5 = 1024$ 个…</p>
<p>也就是说，虽然对于上边十进制而言，它那 30 个牌子表达的信息量确实就是 <code>0~999</code> 这 1000  个数字的信息，或者我们说 1000 种状态信息，但对于下边的比如二进制、三进制、四进制，对应的 20 个、21 个、20 个牌子其实表达了超过 1000 种状态，我们用这些牌子是有浪费的。</p>
<p>这么来算，我们大致可以得到，十进制的效率是 $\frac {1000}{30} \approx 33.3333$，二进制的效率是 $\frac {1024}{20} = 51.2$，三进制的效率是 $\frac {2187}{21} \approx 104.1429$，四进制的效率是 $\frac {1024}{20} = 51.2$…</p>
<p>从这个例子我们已经大概能看到三进制的效率了，那么怎么证明这件事儿呢？</p>
<p>回顾上边的思考过程，我们的数字牌子个数是怎么被算出来的呢？我们大概可以总结出：<br>$$<br>数字牌子的个数 = 进制数 \times 所需的位数<br>$$<br>而为了满足上边的表达 1000 个状态的要求，所以我们要求：<br>$$<br>进制数 ^{所需的位数} \geq 1000<br>$$<br>也就是说：<br>$$<br>所需的位数 = 向上取整（log_{进制数} 1000）<br>$$<br>因为进制数必须是整数，所以我们必须加上 $ 向上取整 $，但就是因为这个向上取整，我们浪费了很多的资源，所以我们先假设 $ 进制数 $ 是个实数。</p>
<p>那么现在对上面 $ 数字牌子的个数 $ 的式子改成 $ 表达这些信息所需的资源 $，这样这个式子就成了下边这样：<br>$$<br>表达这些信息所需的资源 = 进制数 \times log_{进制数} 表达的信息量<br>$$<br>记 $ 表达这些所需的资源 $ 为 $R$，$ 进制数 $ 为 $N$，$ 表达的信息量 $ 为 $I$：<br>$$<br>R = N \times log_NI<br>$$<br>记效率为 $E$，那么：<br>$$<br>E = \frac{I}{R} = \frac{I}{Nlog_NI} = \frac{I}{lnI}\times\frac{lnN}{N}<br>$$<br>求导<br>$$<br>\frac{dE}{dN} = \frac{I}{lnI}\times\frac{1-lnN}{N^2}<br>$$<br>分析单调性，我们知道，当 $N = e$ 时，效率 $E$ 最大。</p>
<p>所以也就是，<code>e 进制</code> 理论上才是效率最高的进制。</p>
<p>但是，e 进制是个啥呢？试试 e 附近的 2 和 3，得到 $E (2) \approx 0.3466\times\frac {I}{lnI}$，$E (3)\approx 0.3662\times\frac {I}{lnI}$，所以，三进制是理论上效率最高的进制。</p>
<h2 id="为什么没用三进制？"><a href="#为什么没用三进制？" class="headerlink" title="为什么没用三进制？"></a>为什么没用三进制？</h2><p>在上边的两个引用里，知乎大佬 @白云龙 和 b 站 up 主 @差评君 都给出了一些答案。@白云龙 大佬的说法是，在实际的实现过程中，实现二进制的 “牌子” 和实现三进制的 “牌子” 的成本不一样，可能二进制的 01 牌子就便宜好用，但三进制的牌子就是又贵又难用，最后所需的资源还要乘上每个牌子的单价，加上这层因素后，二进制比三进制更经济。这其实也就是 @差评君 所言的，二进制只需高低电平来区分 01，但三进制需要实现三种电流状态就比较复杂。</p>
<p>但其实我觉得，这样的问题并不是什么太大的问题，就像 SLC、MLC、TLC 一样。既然我们都可以在同样的电子数的情况下分别实现 2、4、8 种状态的区别，那多实现一个除了 01 以外的第三个状态似乎也类似？(我瞎说的哦，别当真，大佬轻喷…)。主要是，二进制计算机确实已经走到了这样一个瓶颈期，我们的芯片制程来到了十几纳米甚至几纳米、我们的光刻机使用的光已经来到了极紫外光的情况下，想要进一步提升二进制计算机的一丁点性能所消耗的成本是极其庞大的。但是，三进制却是一条新的路，也许就是一条出路。</p>
<p>如果我们把视角从全人类缩到我们中国，在这个光刻机远远落后于欧美的情况下，或许三进制，真的就是我们中国的出路。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.zhihu.com/question/435375360">《为什么计算机不用 e 进制，按道理说 e 进制难道不是最高效的吗？ - 知乎 (zhihu.com)》</a></li>
<li><a href="https://www.bilibili.com/video/BV17b4y1U7TZ/">苏联的三进制电脑，为什么被二进制干掉了？【差评君】哔哩哔哩</a></li>
<li><a href="https://www.crucial.cn/articles/about-ssd/difference-between-slc-mlc-tlc">《SLC、MLC、TLC 颗粒的区别是什么 | Crucial (英睿达) | Crucial 英睿达》</a></li>
</ul>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>大一新生的高数预备知识学习笔记</title>
    <url>/posts/33435544.html</url>
    <content><![CDATA[<p>这篇文章主要是笔者从<a href="https://space.bilibili.com/66607740">宋浩老师</a>处学习高数高数知识的课堂笔记，也加入了一些笔者自己搜到的东西。具体课程你可以看这里：<a href="https://www.bilibili.com/video/BV1YU4y1e7Q9/">大一新生的高数预备知识简介</a>.</p>
<span id="more"></span>

<h2 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h2><h3 id="y-arcsinX"><a href="#y-arcsinX" class="headerlink" title="y=arcsinX"></a>y=arcsinX</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vxa7CV.png"></p>
<h3 id="y-arccosX"><a href="#y-arccosX" class="headerlink" title="y=arccosX"></a>y=arccosX</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vxdQxS.png"></p>
<h3 id="y-arctanX"><a href="#y-arctanX" class="headerlink" title="y=arctanX"></a>y=arctanX</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vxd8bj.png"></p>
<h3 id="y-arccotX"><a href="#y-arccotX" class="headerlink" title="y=arccotX"></a>y=arccotX</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vxdYan.png"></p>
<h3 id="y-secX"><a href="#y-secX" class="headerlink" title="y=secX"></a>y=secX</h3><p>正割是余弦的倒数：</p>
<p>$$<br>secX = \frac{1}{cosX}<br>$$</p>
<p>定义域：显然 $cosX \neq 0$，所以 $y=secX$ 的定义域为：$X\neq k\pi +\frac {\pi}{2},k\in Z$</p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vxwCon.png"></p>
<h3 id="y-cscX"><a href="#y-cscX" class="headerlink" title="y=cscX"></a>y=cscX</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vxwneJ.png"></p>
<h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>$$<br>sec^2x=1+tan^2x,csc^2x=1+cot^2x<br>$$</p>
<p>可以使用下面的方法进行记忆：</p>
<p><img data-src="https://s1.ax1x.com/2022/09/16/vzBKpt.png"></p>
<p>六边形的中间是 $1$。红色三角形的上边两个角的平方之和等于下边一个的平方，即：</p>
<p>$$<br>sin^2x+cos^2x=1<br>$$</p>
<p>$$<br>tan^2x+1=sec^2x<br>$$</p>
<p>$$<br>cot^2x+1=csc^2x<br>$$</p>
<h2 id="多项式的除法"><a href="#多项式的除法" class="headerlink" title="多项式的除法"></a>多项式的除法</h2><ul>
<li>次数高的放前面，低的放后边</li>
<li>缺项的补出来</li>
</ul>
<h3 id="不带余数"><a href="#不带余数" class="headerlink" title="不带余数"></a>不带余数</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vx0m1f.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vx0Mng.png"></p>
<h3 id="带余数"><a href="#带余数" class="headerlink" title="带余数"></a>带余数</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vx0t3V.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vx0o4I.png"></p>
<h2 id="有理分式的拆分"><a href="#有理分式的拆分" class="headerlink" title="有理分式的拆分"></a>有理分式的拆分</h2><h3 id="何为有理分式："><a href="#何为有理分式：" class="headerlink" title="何为有理分式："></a>何为有理分式：</h3><p>有理分式就是一个多项式比一个多项式</p>
<h3 id="何为有理分式的拆分："><a href="#何为有理分式的拆分：" class="headerlink" title="何为有理分式的拆分："></a>何为有理分式的拆分：</h3><p>将相乘的项变成相加减</p>
<h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img data-src="https://s1.ax1x.com/2022/09/15/vxBdRP.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vxBWR0.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vxBHo9.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vxDpee.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vxDUw4.png" alt="待定系数法例子之一"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/15/vxsWRI.png" alt="待定系数法例子之二"></p>
<h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>首先看转动角度，其次看这个点到原点的距离。</p>
<p>例如：直角坐标系中 $(2,2)$ 点在极坐标系中表示为 $(2\sqrt {2},\frac {\pi}{4})$；$(-2,2)$ 表示为 $(2\sqrt {2},\frac {3\pi}{4})$。</p>
<p>极坐标中的原点叫<code>极点</code>，<code>极轴</code>是从极点向 $X$ 轴正方向引入的一条射线（仅正方向有）。极坐标中的点到极点的距离叫做<code>极径</code>，记作 $\rho (\rho\geq0)$（距离肯定是个非负数）；从极轴逆时针转过的角度记作 $\theta (0\leq\theta&lt;2\pi)$（但实际上不一定取这个范围）。所以极坐标中一点 $P$ 的坐标记为 $P (\rho,\theta)$。</p>
<p>一般先考虑 $\theta$ 再考虑 $\rho$。</p>
<h3 id="一些常见图像的极坐标表示"><a href="#一些常见图像的极坐标表示" class="headerlink" title="一些常见图像的极坐标表示"></a>一些常见图像的极坐标表示</h3><blockquote>
<p>括号内范围是默认范围，可写可不写</p>
</blockquote>
<h4 id="射线"><a href="#射线" class="headerlink" title="射线"></a>射线</h4><p>例如一条以极点为端点，$\theta=45^\circ$ 的射线表述为：</p>
<p>$$<br>\theta = 45^\circ(,\rho\geq0)<br>$$</p>
<h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h4><p>例如一个以极点为圆心，$1$ 为半径的圆表述为：</p>
<p>$$<br>(0\leq\theta&lt;2\pi,)\rho=1<br>$$</p>
<h4 id="半圆"><a href="#半圆" class="headerlink" title="半圆"></a>半圆</h4><p>例如一个以极点为圆心，$1$ 为半径的位于 $X$ 轴上方的半圆表述为：</p>
<p>$$<br>0\leq\theta\leq\pi,\rho=1<br>$$</p>
<h4 id="圆面"><a href="#圆面" class="headerlink" title="圆面"></a>圆面</h4><p>例如一个以极点为圆心，$1$ 为半径的圆面表述为：</p>
<p>$$<br>(0\leq\theta&lt;2\pi,)0\leq\rho\leq1<br>$$</p>
<h4 id="半圆面"><a href="#半圆面" class="headerlink" title="半圆面"></a>半圆面</h4><p>例如一个以极点为圆心，$1$ 为半径的位于 $X$ 轴上方的半圆面表述为：</p>
<p>$$<br>0\leq\theta\leq\pi,0\leq\rho\leq1<br>$$</p>
<div class="note warning no-icon"><p>又例如这个以 $(1,0)$ 为圆心，$1$ 为半径的位于 $X$ 轴上方的半圆面表述为：</p>
<p>$$<br>0\leq\theta\leq\frac{\pi}{2},0\leq\rho\leq2cos\theta<br>$$</p>
<p><img data-src="https://s1.ax1x.com/2022/09/16/vzwCNR.png"></p>
<p>又例如这个：</p>
<p><img data-src="https://s1.ax1x.com/2022/09/16/vzwtbQ.png"></p>
</div>

<h4 id="圆环"><a href="#圆环" class="headerlink" title="圆环"></a>圆环</h4><p><img data-src="https://s1.ax1x.com/2022/09/16/vzdzB4.png"></p>
]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>手动挡学习笔记</title>
    <url>/posts/66959aa9.html</url>
    <content><![CDATA[<p>最近几天一直在忙着考驾照的事情，8 月份第一次考科二挂了后就开始边练科二边练科三。最近两三天先后把科三、第二次科二、科四过了，顺利拿到了 C1 驾照。但是… 学的是手动挡，家里的车却是自动挡。所以想着如果不记一下的话，以后估计开惯了自动挡手动挡就不会了，便想做些笔记。顺便也记录一下笔者自己的学车过程。</p>
<span id="more"></span>


<div class="notification is-danger">
相关做法仅供参考，有些内容可能也只适用于笔者这边的考试。如有错误敬请各位大佬指出。
</div>


<h2 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h2><p>就是刷题嘛。笔者本人是把 2000 道题的题库先完整了一遍，然后又模拟了 20 + 次，所以相当于做了 4000 多道题吧，结果是 98 一把过的。笔者一直很担心自己过不了那些扣分 / 罚款题，甚至为此还自己做了个表格把扣分项全部列在了里边。结果实际上并没有用上多少就是了，因为实际考试根本没有那么多难题。<del>可能自己用的软件为了让你冲 VIP 所以不冲的话给的题目就会比较难吧。</del>笔者也认识一个刷了 600 道直接过的，还有一个当天下午考结果上午中午刷了 1200 道直接过的。可能考试的时候抽题目也有点运气成分，和笔者一起去的朋友第二把的难度显然低于第一把，所以第一把 80 多但第二把就 100 了。</p>
<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><p>科二始终是一档就行了，油门也是锁死的，所以只要看离合与刹车两个踏板。核心要点：<strong>速度慢一点</strong>。</p>
<h3 id="开始前准备"><a href="#开始前准备" class="headerlink" title="开始前准备"></a>开始前准备</h3><ol>
<li>系好安全带</li>
<li>调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜</li>
<li>调整内外后视镜。左后视镜下边缘差不多与后车轮下边缘重合为宜，右后视镜车身差不多占 1/3，然后地平线位于上下 1/2 左右。（具体不记得了，笔者自己也有点弄不明白这里，请大佬指点）</li>
</ol>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p>笔者第一次科二两把都挂在这儿了，都是 “倒库不入”。正确的操作如下：</p>
<ol>
<li>首先鼻子正对从右往左数第三条虚线左边缘开，直到开到虚线与肩膀对齐。</li>
<li>挂倒挡，看左后视镜下边缘，差不多与虚线前边缘对齐或间隔几厘米的时候（因人而异），向左打死方向盘。</li>
<li>往后倒的同时观察左后视镜，三条虚线压住两条半了看车身与库边缘的距离，如果较大（30cm 以上？），则保持打死状态继续倒，否则回半圈继续倒。</li>
<li>主要通过右后视镜观察车身是否正。这时候需要自己微调，反正就车屁股要往左就方向盘往左打，车屁股要往右就往右打。</li>
<li>车身正了，端平方向盘，看左后视镜，差不多等到左后视镜完全压住黄线了，停车。</li>
<li>挂前进档，起步。观察左后视镜看到左后轮压到前库线了，向右打死方向盘。车身正，回半圈方向盘继续开直到左侧车门框压到黄虚线。</li>
<li>挂倒挡，起步。待左后视镜对齐黄线了向右打半圈并开始观察右后视镜。看三条虚线类似上边第 3、4 点进行调整。</li>
<li>完全停好，挂前进档，起步。同样观察左后视镜看到左后轮压到前库线了（或者这里也可以稍微提前一点），向左打死。车身正回正。前轮过黄虚线后轮不过。结束倒车入库。</li>
<li>倒车入库的时间要求是：210s（3.5min）</li>
</ol>
<h3 id="坡道定点停车与起步"><a href="#坡道定点停车与起步" class="headerlink" title="坡道定点停车与起步"></a>坡道定点停车与起步</h3><ol>
<li>上坡前离合要稍微踩下边一点，鼻子对准从右往左数第二第三条虚线中间开（保证左右间距）。开到差不多坡顶前，看前车窗右侧商标距离杆子还有 2cm 左右时踩离合与刹车停车。</li>
<li>拉手刹，等 3s，松手刹。</li>
<li>踩住刹车，很缓慢地松离合直到车身抖动或发动机转速表指针往下掉了一下，方向盘稍微往左打一点防止待会压右侧线。松刹车起步。</li>
<li>坡道定点停车与起步无时间要求。</li>
</ol>
<h3 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h3><ol>
<li>进入右直角转弯区域前需要先左转，所以先向左打死，然后提前做准备打好右转灯。</li>
<li>进入区域，车身正方向盘回正。等到右边门把手右端点位于黄线前 1~2cm 时往右打死。</li>
<li>车身正回正，稍微开两步继续向左打死。（右直角转弯只评判右直角，所以这里左转压线也没事）</li>
<li>直角转弯无时间要求。</li>
</ol>
<h3 id="曲线行驶"><a href="#曲线行驶" class="headerlink" title="曲线行驶"></a>曲线行驶</h3><ol>
<li>往前看并伸长脖子看引擎盖左边一个凹下出，当凹下处压线后向左打一圈，方向盘微调使凹下处沿着曲线右边线走。</li>
<li>保持左一圈的动作直到上述凹下处压到曲线左边界，回正，往前开。</li>
<li>看到雨刮器铆钉旁凹下处右侧 2~3cm 处与曲线左边界重合后，往右打一圈。然后往前开直到驶出曲线行驶路段。</li>
<li>曲线行驶无时间要求。</li>
</ol>
<h3 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h3><ol>
<li>首先调整边缘线与车身差不多 30cm 左右的位置。然后保持车身与右边缘线这个间距平行，注意观察右后视镜，直到右后视镜中出现一个直角（侧方的库的边缘角）。</li>
<li>挂倒挡，后退直到直角消失迅速向右打死。</li>
<li>往后的同时低头观察左后视镜，看到两条虚线方向盘迅速回正。然后伸长脖子注意左后轮，压到黄虚线位置后迅速往左打死。</li>
<li>观察右后视镜，到车身平行入库时踩离合刹车停车。</li>
<li>保持左打死状态，打左转向灯，换前进档。引擎盖左侧凹下处压左边线后迅速回正。引擎盖一半压黄线时向右打一圈，车身正回正，侧方停车完成。</li>
<li>侧方停车的时间要求是：从挂倒挡起 90s 内完成。</li>
</ol>
<h2 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h2><h3 id="起步前准备"><a href="#起步前准备" class="headerlink" title="起步前准备"></a>起步前准备</h3><ol>
<li>系好安全带</li>
<li>调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜</li>
<li>调整内外后视镜</li>
</ol>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>停车时应处于空挡、手刹拉好的状态。想要起步，首先应该踩死离合与刹车。打开左转向灯，等 3 秒后，观察后方情况。确认安全后挂一档，松手刹，松刹车，缓松离合。等待 4s 左右完全放掉离合（考试要求 6s 内），踩油门加速。</p>
<h3 id="换挡"><a href="#换挡" class="headerlink" title="换挡"></a>换挡</h3><p>首先是各挡位的速度对应：</p>
<table>
<thead>
<tr>
<th>速度</th>
<th>挡位</th>
</tr>
</thead>
<tbody><tr>
<td> 10 码以下</td>
<td>一档</td>
</tr>
<tr>
<td> 10~20 码</td>
<td>二档</td>
</tr>
<tr>
<td> 20~35 码</td>
<td>三档</td>
</tr>
<tr>
<td> 35~40 码</td>
<td>四档</td>
</tr>
<tr>
<td> 40 码以上</td>
<td>五档</td>
</tr>
</tbody></table>
<p>换档前，首先踩油门到挡位速度的分界线。然后松油门，踩死离合，换挡，松离合，完成换挡操作。考试要求换挡在 6s 内完成。</p>
<p>加档必须一档一档加上（比如停车时空挡再起步就只能从一档开始加上去），减档可以跳着减（只要速度挡位匹配）。</p>
<h3 id="变更车道与超车"><a href="#变更车道与超车" class="headerlink" title="变更车道与超车"></a>变更车道与超车</h3><p>先打转向灯，等待 3s 后观察后方情况，然后转方向盘进入另一车道。</p>
<h3 id="十字路口的转向"><a href="#十字路口的转向" class="headerlink" title="十字路口的转向"></a>十字路口的转向</h3><h4 id="右转"><a href="#右转" class="headerlink" title="右转"></a>右转</h4><p>看地上标线，一般是有三个右转向的箭头。从近及远，第一个之前或差不多那时候打右转向灯，第二个的地方减档，紧接着是点踩刹车和左右摇头观察情况。（考试时常规要保持三档 20 码左右的速度，所以这里减档就是到二档）。彻底完成转向后加速回到三档。右转即走右车道，但要注意不要开到非机动车道上去。</p>
<h4 id="左转"><a href="#左转" class="headerlink" title="左转"></a>左转</h4><p>类似右转，不过是 “左转左车道”。</p>
<h3 id="掉头"><a href="#掉头" class="headerlink" title="掉头"></a>掉头</h3><p>我考试的情况是左右两车道，并且靠侧边的是非机动车道。所以掉头时要先借右侧辅道。</p>
<p>首先打右转向灯，然后减二档，等待 3s 观察右后方情况，确认安全后进入右侧辅道。接着关闭右转灯，打左转灯，等待 3s 观察<strong>左前方和左后方</strong>的情况，确认安全后往左打死。这中间可以稍微踩点刹车放慢点速度。</p>
<h3 id="靠边停车"><a href="#靠边停车" class="headerlink" title="靠边停车"></a>靠边停车</h3><p>首先右转向灯，打一档，等 3s 后观察右后方情况。确认安全后进入右边车道停车。</p>
<h3 id="减速与停车"><a href="#减速与停车" class="headerlink" title="减速与停车"></a>减速与停车</h3><p>减速就是踩刹车；</p>
<p>停车要离合刹车一起踩并且离合要踩得更快更早一点点。车停后记得挂空挡。</p>
<p>考试过程中，除了人行横道，其余地方都可以停车。所以善用它！</p>
<h3 id="点踩刹车与左右摇头观察"><a href="#点踩刹车与左右摇头观察" class="headerlink" title="点踩刹车与左右摇头观察"></a>点踩刹车与左右摇头观察</h3><p>这点实际开车应该都没人做吧，完全是应付考试了。需要在路口转弯、靠近人行横道、公交车站的地方做这个动作。</p>
<p>注意点主要是：点踩刹车不用踩太下，碰一下刹车立马抬起就行了。两次点踩刹车不要太连续，不然容易掉档。摇头的时候，幅度要大一点。</p>
<h3 id="夜间灯光考试"><a href="#夜间灯光考试" class="headerlink" title="夜间灯光考试"></a>夜间灯光考试</h3><h4 id="近光灯"><a href="#近光灯" class="headerlink" title="近光灯"></a>近光灯</h4><ul>
<li>夜间同方向近距离<strong>跟车</strong>行驶</li>
<li>夜间在窄桥 / 窄路上与非机动车<strong>会车</strong></li>
<li>夜间<strong>直行通过路口</strong></li>
<li>夜间在照明<strong>良好</strong>的道路上行驶</li>
</ul>
<h4 id="远光灯"><a href="#远光灯" class="headerlink" title="远光灯"></a>远光灯</h4><ul>
<li>夜间在没有路灯、照明<strong>不良</strong>的道路上行驶</li>
</ul>
<h4 id="远近灯光交替"><a href="#远近灯光交替" class="headerlink" title="远近灯光交替"></a>远近灯光交替</h4><ul>
<li>夜间通过<strong>急弯 / 坡路 / 拱桥</strong></li>
<li>夜间通过<strong>没有</strong>交通信号灯的路口</li>
<li>夜间<strong>超越</strong>前方车辆</li>
</ul>
<h4 id="示宽灯-双闪"><a href="#示宽灯-双闪" class="headerlink" title="示宽灯+双闪"></a>示宽灯 + 双闪</h4><ul>
<li><strong>路边临时停车</strong></li>
<li>夜间在路口发生交通事故，<strong>妨碍交通难以移动</strong></li>
</ul>
<h2 id="科目四"><a href="#科目四" class="headerlink" title="科目四"></a>科目四</h2><p>刷了 300 道不到去了，大部分都是常识，相对比较好过。</p>
<h2 id="附：笔者教练讲的完整流程及注意点"><a href="#附：笔者教练讲的完整流程及注意点" class="headerlink" title="附：笔者教练讲的完整流程及注意点"></a>附：笔者教练讲的完整流程及注意点</h2><h3 id="科二"><a href="#科二" class="headerlink" title="科二"></a>科二</h3><blockquote>
<p>【侧方停车】(1) 先调整好边缘线 30 公分左右，再看向右面大反光镜直角出来就停车。(2) 开始挂倒挡，倒车看后右反光镜看不见直角。就向右把方向打死。(3) 再看左反光镜里后面露出两条虚线把方向回正。(4) 然后在看左后轮压虚线向左打死。(5) 最后再看大镜车身平行刚进虚线就停。【2】出侧方位，打左转向灯。挂前进挡出库看前面左车头凹巢面挡外框黄线把方向回正。继续向前左车头当一半外面黄线时向右打一圈车身正把它回正。侧方位结束。【3】侧方位规定在挂倒挡开始 90 秒之内完成。【倒车入库】先看从右边数第三条虚线停在我们车中间与肩膀平行，倒车入库开始两百十秒钟完成。看左反光镜下檐 余肩膀线从合同时 向左打死方向，再看左反光镜库里面第三条虚线挡住一半时把方向回半圈。再看右面反光镜与库线平行，把方向右回正。在看左前反光镜下檐 于库角线刚从合停车。挂前档向右时看两反光镜调整出库大小。左后轮到库角向右打死，车头正回半圈。一直到肩膀停车，挂倒档看左镜子下檐于肩膀线从合向右打半圈打死。右面大反光镜库第三条虚线时一半把方向回半圈。就是等车上与地上黄线平行。把方向全部回正。就等停车看前面左反光镜檐于 库角线停车，出库调整大小左后面库角向左打死。车身正回正前轮到肩膀线。</p>
</blockquote>
<h3 id="科三"><a href="#科三" class="headerlink" title="科三"></a>科三</h3><blockquote>
<p> 1. 继续完成考试。先打左转向灯。向左回头观望。确保安全后。踩离合。挂一挡。松手刹。又手推到一点钟的位置。右脚放油门。左脚慢慢抬起离合。车子开始走动一般数四秒。把离合器全部松掉。 (记住 左脚必须在六秒钟之内。完全离合器踏板。超过六秒扣 100 分，行车过程中。加减档 也必须在。六秒钟内完成)，从松手下到起步 必须十秒钟内起步走哦  2. 行车过程中。加速加档。10 码以上加二档 20 码以上加三档 35 码以上加四档。加档只能一个一个档往上加。不能跳跃加档，减档可以速度与档位匹配时可以越档位减档。3. 还有会车动作，准备会车稍微向左一点。不要压中心线。听到电脑语音指定。与机动车会车。向右靠。沿着右边线点行驶。小心右边压线。3 到 4 秒后，电脑语音指定。结束回车。你靠中心随便行驶。会车结束以后。直接踩油门踩 35 码以上加四档。四挡加上去离合器放掉 5 秒过后，踩离合直接推三档，四档就完成了。4. 超越前方车辆。电脑发出指定，你打左转向灯。向前方数三秒后，向左回头观望。头必须左后 90 度以上观望。确认安全后，方向稍微向左。行驶到另一个车道。等车辆完全进入另一个车道后，关闭左转向灯。车身直驶回原车道。你打开右转向灯。向前方数三秒后向右回头观望。头必须 90 度以上。方向稍微向右使上另一个车道，完全进入另一个车道后把转向灯关掉。5. 直线行驶。一般的我教听到指令控制好方向油门踩上去。达到 40km 以上中间会听到我的敲门声松掉油门。。让它自由滑行。方向微调。记住必须直线行驶 100 米以后。会听到结束直线行驶。滑行自由行驶了，6. 遇到路口一般减速减档轻点刹车左右观望。人行横道，公交车站台轻点刹车，左右观望通过。停车放空挡。7. 听到适当路口掉头时，借右侧辅道先打右转向灯。减二档。三秒以后回头观望。向右进入辅道记住小心右面压边线。完全进入辅道后启左转向灯，三秒以后。向左回头观望。一把快打死掉头。8. 进入对方车道路后，准备停车。打好右转向灯，记住一定要等好电脑指令。请靠边停车。可以换一挡数三秒。右回头观望后往右向右靠。注意停不进去随时随地都可以停车放空挡等， 看前小反光镜与边线 30 公分以内。踩离合踩刹车。放空挡拉手刹。等电脑成绩合格。才可下车。</p>
</blockquote>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
  </entry>
  <entry>
    <title>记一次电脑清灰</title>
    <url>/posts/50b3c006.html</url>
    <content><![CDATA[<p>电脑是以前的老电脑，初一暑假时候买的 y700。配置低的可怜，毫无性价比的一台机子吧，当年还是电脑小白的时候保意买的，在完全不懂的情况下被忽悠着忽悠着买了，满满的坑啊。</p>
<p>这电脑之前被我拆开来过，为了加一条固态，后盖螺丝因而已经不全了（拆必丢原则！），不过这次没丢！</p>
<span id="more"></span>

<p>硅脂买的是 7921，网上说好用就买了，竟然还送了一些刷子垫片啥的，应该是很多人都买了清灰用的所以店家就把清灰附属需要的东西也都附赠了，这点还挺不错的。但是实际涂起来吧，这款硅脂是真的令我痛苦 —— 真的很奇妙的质感，比较像容易断的那种橡皮泥 (?)，反正结果就很尴尬（我知道我涂多了！没办法）</p>
<p>弄好装完发现点不亮了！吓了我一跳，结果发现是放那儿好久原来一直没接电源所以没电，接上电就能正常进系统了，太懒了，就没烤一下再看看。</p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed37f.jpg" alt="所用硅脂——信越7921"></p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed388.jpg" alt="商家还送了一些清灰用的玩意儿（这张照片是补拍的）"></p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed394.jpg" alt="清灰前的风扇"></p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed36a.jpg" alt="清灰前的...这叫啥..."></p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed375.jpg" alt="擦掉旧的硅脂（原来这个方方的才是gpu！）"></p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6816f2c2beb1fed7e1.jpg" alt="尽力清灰后..."></p>
<p><img data-src="https://pic.imgdb.cn/item/6308bb6816f2c2beb1fed7e6.jpg" alt="涂多了...希望不要出事"></p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次网络改造</title>
    <url>/posts/b9a9b40d.html</url>
    <content><![CDATA[<p>事情的起因是跟爸闲聊我抱怨家里为什么没有预埋到我和我妹房间的网线，结果才知道原来是有的，只不过藏在空面板里没有装接口…… 于是就开始兴致勃勃地想把它装起来 (这样我房间里就有有线网了！)，赶紧买了面板，交换机，网线和一众工具。</p>
<span id="more"></span>

<p>接网线难在第一个，不过第一个弄会了后面也就快了，此次没有试水晶头的接法，下次有机会试试。</p>
<p>昨天仅仅是把面板弄完了，交换机今天才到的刚刚也弄上了，现在都做的很方便接上就能用了！不过在等交换机的时候把家里老的路由器小米 WiFi4 整了出来，稀里糊涂地捣鼓了半天刷上了个 openwrt，这个东西似乎是个 linux 发行版？! 反正似乎潜力巨大，可以装好多东西，但现在还没太研究，以前想试的 adguard home 似乎也可以试试去了。</p>
<p>现在我的房间也终于有千兆网了！</p>
<p><img data-src="https://s1.ax1x.com/2022/08/28/vWrbPP.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWrTUI.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWroVA.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWr75t.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWr5bd.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWrOxS.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWrL28.jpg"><br><img data-src="https://s1.ax1x.com/2022/08/28/vWrq8f.jpg"></p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>挖老婆矿！—— NovelAI 初试</title>
    <url>/posts/f17b3e8b.html</url>
    <content><![CDATA[<p>最近一段时间，感觉突然之间，就有很多很多将现实图片二次元化啊，按照每句歌词生成一副画作啊的 AI 绘画应用的图文视频出现。和室友聊天还说是不是最近一段时间 AI 技术突破什么瓶颈突飞猛进了。后来才知道，原来是 NovelAI 泄露了… 这样一来，本地部署方便了起来，于是整了一个玩玩。由于跑 AI 嘛，GPU 比较呼啸，跟挖矿一样，我就戏称我这是在 “挖老婆矿” 了。</p>
<span id="more"></span>

<p>注：这篇文章更偏向于我记录生成时使用的 tag， 不涉及基础操作。我使用的 NovelAI 下载自<a href="https://www.bilibili.com/video/BV1EV4y1L7dX">这里</a>。</p>
<h1 id="一个头像（一堆头像）"><a href="#一个头像（一堆头像）" class="headerlink" title="一个头像（一堆头像）"></a>一个头像（一堆头像）</h1><p>我最开始只是用几个 tag 生成。经历了一些粗浅的尝试后，发现生成的质量并不高。但是看到了<a href="https://www.yuque.com/longyuye/lmgcwy/goa36x">一篇文章</a>，照着里边的 tag 写，才算真正开始了探索。</p>
<p>首先是根据上边那篇文章最后的示例增改了点 tag 形成的 prompt:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">blue pen illustration, light blue background, flowers on face, growth, nature, beautiful face, pink hair,shawl hair, zoom in on eyes, apathy, red eye shadow, petite, best quality, masterpiece</span><br></pre></td></tr></tbody></table></figure>

<p>然后生成出了下面这些相当不错的图案：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0HgAK.jpg"></p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0H676.jpg"></p>
<p>下边分类讲讲 tag:</p>
<p>提高总体质量的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">masterpiece, best quality, by famous artist, beautiful face</span><br></pre></td></tr></tbody></table></figure>

<p>使整体的风格偏向更具插画感：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">illustration</span><br></pre></td></tr></tbody></table></figure>

<p>限定背景的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">xxxx + backgroud  (比如上边的淡蓝色背景就是 light blue background )</span><br></pre></td></tr></tbody></table></figure>

<p>让生成出来的 waifu 更幼的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">petite</span><br></pre></td></tr></tbody></table></figure>

<p>让脸上、头发上出现花朵装饰的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">flowers on face</span><br></pre></td></tr></tbody></table></figure>

<p>让眼睛更大的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">zoom in one eyes</span><br></pre></td></tr></tbody></table></figure>

<p>尝到了甜头后，我就想换头像了。但我不想完全抛弃现在的头像，于是就试图拿它做派生。</p>
<p>首先描述一下原来的头像，让 AI 知道我大概是想要怎样的一个 “老婆”。<del>（虽然其实我描述的时候更感觉是在捏女儿）</del> 顺便一说，我这个原来的头像其实也是 AI 生成的，叫 <a href="https://waifulabs.com/generate">WaifuLabs</a>，是我把原来生成出来的丢进 PS 去了水印，又自己修缮了一下得到的。</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0I1Z8.jpg" alt="上边是 WaifuLabs 生成出来时候的样子，下边是我自己 PS 改的"></p>
<p>抛却那些提高质量的，大概给了 <code>披肩发</code>、<code>深灰色头发</code>、<code>深灰色眼睛</code>、<code>红色眼影</code>、<code>白色衬衫</code>、<code>微笑</code> 这些 tag。同时模仿了上边，给了 <code>面部的花</code> 之类的 tag：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{masterpiece,best quality}},shawl hair,dark grey hair, dark grey eyes,red eye shadow,  white shirt,illustration,flower on face,growth, nature,beautiful face, smile, zoom in one eyes</span><br></pre></td></tr></tbody></table></figure>

<p>以上边的内容为 prompt，同时把我改的那张扔给 NovelAI，根据生成结果又慢慢改，添加 tag，最终的 prompt 如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{masterpiece,best quality,by wlop}},shawl hair,dark grey hair, dark grey eyes,red eye shadow, white shirt,{{{illustration}}},flower on face, growth, nature, beautiful face, small smile, zoom in one eyes, {{{{petite}}}}, dramatic shadows, ink,eye-focus, portrait, red hairclip</span><br></pre></td></tr></tbody></table></figure>

<p>跑了大概 100 张，然后挑了挑，下边展示的是部分高质量的：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0IgzR.png"></p>
<p>又是一波奇奇怪怪的调整：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0onkF.png"></p>
<p>最后挑选出了这张我觉得挺有特色的：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0o161.png"></p>
<p>然后开始根据这张进行派生：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0jbEn.png"></p>
<h1 id="一张壁纸（一堆壁纸）"><a href="#一张壁纸（一堆壁纸）" class="headerlink" title="一张壁纸（一堆壁纸）"></a>一张壁纸（一堆壁纸）</h1><p>这事儿开始的挺搞笑的，当时我正在调上边的头像参数，坐我旁边玩 CSGO 的朋友希望我把某把枪拟人，然后发我了下边的图片：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0TGgs.jpg"></p>
<p>然后我加了点描述词生成了，但生成效果并不好，我就又开始研究我上边的头像了。我完全忘记了我还拿着这张图生成的某张图在做派生呢… 我只是改回了我的 prompt，就意外地得到了下边这张图：</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x0TI8H.png"></p>
<p>似乎是把枪头画成了那条条纹？我也不知道。反正着实是惊艳到我了，扔到 bigjpg 那边提高了一下分辨率，再扔进 PS 调了一下曲线，嘿嘿，新的手机壁纸有了！</p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x07eG4.png" alt="拉的曲线"></p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x07Prq.png" alt="新的手机壁纸！"></p>
<p>然后又拿这张图和基于上边改的 prompt 做了派生…</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{masterpiece,best quality}},shawl hair,dark grey hair, dark grey eyes,red eye shadow,red scanf,  light grey shirt,{{illustration}},red flower on face,white flower on hair,growth, nature,beautiful face, {{indifferent}}, zoom in one eyes,1girl, red flower background, gold fence background,focus on eye</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://s1.ax1x.com/2022/10/15/x07XO1.jpg"></p>
<p><img data-src="https://s1.ax1x.com/2022/10/15/x07vex.jpg"></p>
<p>相当不错！</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>NovelAI</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>My personal summary of Algorithms, Part I on Coursera</title>
    <url>/posts/94efd546.html</url>
    <content><![CDATA[<p>As the title says, this is my personal summary of <a href="https://www.coursera.org/learn/algorithms-part1">Algorithms, Part I</a> on <a href="https://www.coursera.org/">Coursera</a>.</p>
<span id="more"></span>

<p>Finally! q(≧▽≦q)</p>
<p>I enrolled in this course about a month ago and have just finished it. Although the system decided that I had completed the course when my last assignment was due on the 2nd of May, I actually finished Week 06 about ten days later. No deadline, no motivation. &gt;_&lt;</p>
<p>The course is called Algorithms, Part I. (There is Part II, of course, but I haven’t signed up for it yet.) The teacher is Prof. Robert Sedgewick from Princeton University, also the author of the famous book Algorithms. Although this course is from a few years ago, it’s still one of the top courses today.</p>
<p>The biggest feature of this course is that it ties algorithms so closely to real-world problems. Almost all topics are introduced this way: Here we have a problem. To solve it, we can easily use … But we can’t do that because it’s too expensive, so we can try to use … to solve it. By using this algorithm, we can ensure that … in the case of …. Also, we can use this algorithm to solve … problems. I think this kind of combination between theory and practice is really valuable.</p>
<p>The five projects are amazing. Instead of writing stupid experiment reports, uploading them to the QQ group and not knowing whether my codes are good or not, this online platform provides an incredible evaluation system that not only checks the correctness of your codes, but also the style! The style! Much better than some Chinese reference books! After each submission, the evaluation system gives you a detailed report on what’s wrong with your codes, and you can then correct or polish your codes and submit them again. I submitted the last project thirteen times to pass it, with the help of GPT and even some reference codes! Orz</p>
<p>I’d highly recommend any CS student to take this course on Coursera. It’s free and in my opinion it’s actually much easier than the listening section of the national college entrance examination or CET-4.</p>
<p><img data-src="https://s1.ax1x.com/2023/05/12/p9yWH3t.png"></p>
<p><img data-src="https://s1.ax1x.com/2023/05/12/p9yWqjf.png"></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Algorithms &amp; Data structures</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Online course summary</tag>
      </tags>
  </entry>
  <entry>
    <title>初探深度优先搜索（DFS）和广度优先搜索（BFS）</title>
    <url>/posts/a336c1b8.html</url>
    <content><![CDATA[<p><strong>深度优先搜索</strong>（DFS，Depth First Search）和<strong>广度优先搜索</strong>（BFS，Breadth First Search），我从来没弄明白过。是时候努力去好好理解一下了。</p>
<span id="more"></span>

<p>B 站找了两个视频看，这篇文章是笔记。</p>
<p><del>所以图直观还是直接看视频吧…</del></p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1cQ4y127Kd/">《不怕你学不会系列：深度优先搜索_哔哩哔哩_bilibili》</a></li>
<li><a href="https://www.bilibili.com/video/BV1H44y1871A/">《不怕你学不会系列：宽度优先搜索_哔哩哔哩_bilibili》</a></li>
</ul>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>DFS 的搜索过程要结合 <strong>栈</strong> 来理解，实际上这个过程就是在对一个 <strong>栈</strong> 在操作。比如我们有这样一张图：</p>
<pre class="mermaid">graph TB
1((1))===2((2))===4((3))===8((4))===5((5))
2((2))===5((5))
1((1))===3((8))===6((6))===8((4))
3((8))===7((9))
6((6))===9((7))
</pre>

<p>我们建立一个栈，然后开始遍历上边这张图。我们做以下约定：</p>
<ul>
<li>已经入栈的节点要被标记为已经遍历；</li>
<li>起始节点为 1，将其入栈，作为最初的栈顶；</li>
<li>查看与当前栈顶元素相连并且未被标记的节点，将其入栈；</li>
<li>如果有多个满足 3 中条件的元素，节点序号较小的优先入栈；</li>
<li>当栈顶元素没有相连节点或所有相连节点均已经被标记后，将其出栈。</li>
</ul>
<p>所以对于上边的图，我们依次进行下面的操作：</p>
<ol>
<li>节点 1 入栈，并将其标记；</li>
<li>查找与当前栈顶元素节点 1 相连并且没有标记的元素，有节点 2 和节点 8，节点 2 优先入栈，将节点 2 标记；</li>
<li>查找与当前栈顶元素节点 2 相连并且没有标记的元素，有节点 3 和节点 5，节点 3 优先入栈，将节点 3 标记；</li>
<li>查找与当前栈顶元素节点 3 相连并且没有标记的元素，只有节点 4，节点 4 入栈，并将其标记；</li>
<li>查找与当前栈顶元素节点 4 相连并且没有标记的元素，有节点 5 和 节点 6 ，节点 5 优先入栈，将节点 5 标记；</li>
<li>查找与当前栈顶元素节点 5 相连的元素，有节点 2 和节点 4，但均已被标记，所以当前栈顶节点 5 出栈；</li>
<li>查找与当前栈顶元素节点 4 相连并且没有标记的元素，只有节点 6，节点 6 入栈，并将其标记；</li>
<li>查找与当前栈顶元素节点 6 相连并且没有标记的元素，有节点 7 和节点 8，节点 7 优先入栈，将节点 7 标记；</li>
<li>查找与当前栈顶元素节点 7 相连的元素，没有这样的元素，节点 7 出栈；</li>
<li>查找与当前栈顶元素节点 6 相连并且没有标记的元素，只有节点 8，节点 8 入栈，并将其标记；</li>
<li>查找与当前栈顶元素节点 8 相连并且没有标记的元素，只有节点 9， 节点 9 入栈，并将其标记；</li>
<li>查找与当前栈顶元素节点 9 相连并且没有标记的元素，没有这样的元素，节点 9 出栈；</li>
<li>查看当前栈顶元素节点 8，类似，节点 8 出栈；</li>
<li>查看当前栈顶元素节点 6，类似，节点 6 出栈；</li>
<li>查看当前栈顶元素节点 4，类似，节点 4 出栈；</li>
<li>查看当前栈顶元素节点 3，类似，节点 3 出栈；</li>
<li>查看当前栈顶元素节点 2，类似，节点 2 出栈；</li>
<li>查看当前栈顶元素节点 1，类似，节点 1 出栈。</li>
</ol>
<p>上边对这个栈的操作过程应该如下边所示：</p>
<ol start="0">
<li><p>（栈空）</p>
</li>
<li><p>节点 1</p>
</li>
<li><p>节点 1、节点 2</p>
</li>
<li><p>节点 1、节点 2、节点 3</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 5</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 7</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 8</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 8、节点 9</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 8</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4、节点 6</p>
</li>
<li><p>节点 1、节点 2、节点 3、节点 4</p>
</li>
<li><p>节点 1、节点 2、节点 3</p>
</li>
<li><p>节点 1、节点 2</p>
</li>
<li><p>节点 1</p>
</li>
<li><p>（栈空）</p>
</li>
</ol>
<h2 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h2><p>BFS 的搜索过程要联系 <strong>队列</strong> 来理解，约定如下：</p>
<ul>
<li>已经入队的节点要被标记为已经遍历；</li>
<li>第一个入队的是节点 1，将其作为最初的队首和队尾；</li>
<li>遍历与当前队首相连但未被标记的节点，按照数字大小依次入队，并且移动队尾；</li>
<li>队首移动到下一个元素。</li>
</ul>
<p>例如对下边这个图：</p>
<pre class="mermaid">graph TB
1((1))===2((2))===4((4))===8((8))
2((2))===5((5))===8((8))
1((1))===3((3))===6((6))===8((8))
6((6))===9((9))
3((3))===7((7))===9((9))
</pre>

<p>队列维护的情况如下（加粗的表示队首、斜体表示队尾）：</p>
<ol>
<li><strong>1</strong>、2、<em>3</em></li>
<li>1、<strong>2</strong>、3、4、<em>5</em></li>
<li>1、2、<strong>3</strong>、4、5、6、<em>7</em></li>
<li>1、2、3、<strong>4</strong>、5、6、7、<em>8</em></li>
<li>1、2、3、4、<strong>5</strong>、6、7、<em>8</em></li>
<li>1、2、3、4、5、<strong>6</strong>、7、8、<em>9</em></li>
<li>1、2、3、4、5、6、<strong>7</strong>、8、<em>9</em></li>
<li>1、2、3、4、5、6、7、<strong>8</strong>、<em>9</em></li>
<li>1、2、3、4、5、6、7、8、<strong>9</strong></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Algorithms &amp; Data structures</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Searching</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>求解最大公约数的四种算法</title>
    <url>/posts/504f038d.html</url>
    <content><![CDATA[<p>这是一次计算机导论课的作业。本来对于最大公约数的求解算法，我就只知道一个<strong>辗转相除法</strong>。原来，其实还有别的一些 …</p>
<span id="more"></span>

<h2 id="法一：试除法（穷举法）"><a href="#法一：试除法（穷举法）" class="headerlink" title="法一：试除法（穷举法）"></a>法一：试除法（穷举法）</h2><p>也许这应该才是最先能想到的算法 —— 两个数中取小的那个，由大到小穷举这个数的所有因数，并且看看这个数是不是另一个数的因数，如果是，那这个数就是这两个数的最大公约数了。</p>
<h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h3><p>$O(min(a,b))$</p>
<h3 id="1-自然语言描述"><a href="#1-自然语言描述" class="headerlink" title="1. 自然语言描述"></a>1. 自然语言描述</h3><ol>
<li>定义变量 $a,b$，用于存放两个待求取最大公约数的值，确保 $a\leq b$；</li>
<li>定义变量 $i=a$；</li>
<li>如果 $i\geq1$，执行步骤 4；</li>
<li>判断 $i$ 是否是 $a$ 的因数，如果是，执行步骤 5，否则，执行步骤 7；</li>
<li>判断 $i$ 是否是 $b$ 的因数，如果是，执行步骤 6，否则，执行步骤 7；</li>
<li>跳出循环，$i$ 就是 $a$ 和 $b$ 的最大公约数；</li>
<li>$i$ 自减 $1$，执行步骤 3；</li>
</ol>
<h3 id="1-伪代码描述"><a href="#1-伪代码描述" class="headerlink" title="1. 伪代码描述"></a>1. 伪代码描述</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var a,b,i:integer;</span><br><span class="line">input(a);</span><br><span class="line">input(b);</span><br><span class="line">Begin</span><br><span class="line">For i&lt;-a to 1 do</span><br><span class="line">Begin</span><br><span class="line">	If a%i==0 Then</span><br><span class="line">    	If b%i==0 Then</span><br><span class="line">    	Begin</span><br><span class="line">    		print(i);</span><br><span class="line">    		break;</span><br><span class="line">    	End;</span><br><span class="line">End;</span><br><span class="line">End;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h3><p><img data-src="https://s1.ax1x.com/2022/12/05/zy8vhn.png" alt="Powered by draw.io"></p>
<h3 id="1-C-代码"><a href="#1-C-代码" class="headerlink" title="1. C++ 代码"></a>1. C++ 代码</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint64_t</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (b % i == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="法二：辗转相除法（欧几里得算法）"><a href="#法二：辗转相除法（欧几里得算法）" class="headerlink" title="法二：辗转相除法（欧几里得算法）"></a>法二：辗转相除法（欧几里得算法）</h2><p>这大概是最常见的计算最大公约数的算法了吧…</p>
<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2. 时间复杂度"></a>2. 时间复杂度</h3><p>可近似看作 $O (log (max (a,b)))$，但取模运算性能较差。</p>
<h3 id="2-自然语言描述"><a href="#2-自然语言描述" class="headerlink" title="2. 自然语言描述"></a>2. 自然语言描述</h3><ol>
<li>定义变量 a，b 并读入；</li>
<li>如果 b == 0，返回 a；</li>
<li>否则，更新 a 的值为原来 b 的值，更新 b 的值为原来 a% b 的值，回到步骤 2。</li>
</ol>
<h3 id="2-伪代码描述"><a href="#2-伪代码描述" class="headerlink" title="2. 伪代码描述"></a>2. 伪代码描述</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var a,b:integer;</span><br><span class="line">def gcd(a,b):</span><br><span class="line">Begin</span><br><span class="line">	If b==0 Then</span><br><span class="line">    	return a;</span><br><span class="line">    Else return(gcd(b, a%b));</span><br><span class="line">End;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2. 流程图"></a>2. 流程图</h3><p><img data-src="https://s1.ax1x.com/2022/12/05/zyNCG9.png" alt="Powered by draw.io"></p>
<h3 id="2-C-代码"><a href="#2-C-代码" class="headerlink" title="2. C++ 代码"></a>2. C++ 代码</h3><p>主函数及 gcd 函数的函数声明：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span>, <span class="type">uint64_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint64_t</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>gcd 函数（递归实现）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>gcd 函数（递归函数，写成一行的版本）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span> </span>{ <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; }</span><br></pre></td></tr></tbody></table></figure>

<p>gcd 函数（迭代实现）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">uint64_t</span> tmp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="法三：更相减损法"><a href="#法三：更相减损法" class="headerlink" title="法三：更相减损法"></a>法三：更相减损法</h2><p>更相减损法又叫<strong>更相减损术</strong>，出自《九章算术》，是咱老祖宗的智慧。这个东西本来是为了约分而设计的，但是，既然都约分了，那自然也可以用来求取最大公约数。</p>
<p>这个算法的原文描述是这样：</p>
<blockquote>
<p>可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。</p>
</blockquote>
<p>翻译成白话就是：</p>
<blockquote>
<p>（如果需要对分数进行约分，那么）可以折半的话，就折半（也就是用 2 来约分）。如果不可以折半的话，那么就比较分母和分子的大小，用大数减去小数，互相减来减去，一直到减数与差相等为止，用这个相等的数字来约分。</p>
</blockquote>
<p><em>这两段引用的来源是：<a href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF">更相减损术_百度百科 (baidu.com)</a></em></p>
<h3 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3. 时间复杂度"></a>3. 时间复杂度</h3><p>$O(max(a,b))$</p>
<h3 id="3-自然语言描述"><a href="#3-自然语言描述" class="headerlink" title="3. 自然语言描述"></a>3. 自然语言描述</h3><ol>
<li>定义变量 a、b 并读入；</li>
<li>如果 变量 a、b 能被 2 整除，那就都除以 2。不断重复执行这一步直到 a、b 任意一个不能被 2 整除，记录下进行这一步的次数，存入变量 cnt 中；</li>
<li>定义三个变量 x1、x2、x3，用于表示被减数、减数和差；</li>
<li>x1 赋初值为 a、b 中较大的那一个，x2 赋初值为 a、b 中较小的那一个，x3 赋初值为 x1-x2；</li>
<li>在 x2!=x3 的情况下，不断更新 x1 = max (x2, x3)，x2 = min (x2, x3)，x3 = x1 - x2；</li>
<li>返回 x2 + pow (2, cnt)。</li>
</ol>
<h3 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3. 流程图"></a>3. 流程图</h3><h3 id="3-C-代码"><a href="#3-C-代码" class="headerlink" title="3. C++ 代码"></a>3. C++ 代码</h3><p>下边给出的是基于原文描述实现的更相减损法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint64_t</span> cnt = <span class="number">0</span>; <span class="comment">// 统计除以二的次数</span></span><br><span class="line">    <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        cnt++;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">uint64_t</span> x1, x2, x3; <span class="comment">// 分别表示被减数、减数、差</span></span><br><span class="line">    x1 = <span class="built_in">max</span>(a, b);</span><br><span class="line">    x2 = <span class="built_in">min</span>(a, b);</span><br><span class="line">    x3 = x1 - x2;</span><br><span class="line">    <span class="keyword">while</span> (x2 != x3)</span><br><span class="line">    {</span><br><span class="line">        x1 = <span class="built_in">max</span>(x2, x3);</span><br><span class="line">        x2 = <span class="built_in">min</span>(x2, x3);</span><br><span class="line">        x3 = x1 - x2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x2 * <span class="built_in">pow</span>(<span class="number">2</span>, cnt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果去掉那些 “可半者半之”，直接进行后面的 “<strong>辗转相减</strong>” 部分，也是可以的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">uint64_t</span> x1, x2, x3; <span class="comment">// 分别表示被减数、减数、差</span></span><br><span class="line">    x1 = <span class="built_in">max</span>(a, b);</span><br><span class="line">    x2 = <span class="built_in">min</span>(a, b);</span><br><span class="line">    x3 = x1 - x2;</span><br><span class="line">    <span class="keyword">while</span> (x2 != x3)</span><br><span class="line">    {</span><br><span class="line">        x1 = <span class="built_in">max</span>(x2, x3);</span><br><span class="line">        x2 = <span class="built_in">min</span>(x2, x3);</span><br><span class="line">        x3 = x1 - x2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x2;  <span class="comment">// 或者 return x3;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>于是也可以写出递归形式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        a ^= b, b ^= a, a ^= b; <span class="comment">// 确保 a&gt;=b</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * b == a)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a - b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="法四：Stein-算法"><a href="#法四：Stein-算法" class="headerlink" title="法四：Stein 算法"></a>法四：Stein 算法</h2><p>这个算法是辗转相除法的改进版本，避免了取模运算，且算法性能稳定。</p>
<h3 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>$O(log(max(a,b)))$</p>
<h3 id="版本一："><a href="#版本一：" class="headerlink" title="版本一："></a>版本一：</h3><p>学习自<a href="https://cnblogs.com/COLIN-LIGHTNING/p/8425484.html">这篇</a>文章，正好学习一下位运算的一些 “骚操作”（见下文引用处）。</p>
<h4 id="4-1-自然语言描述"><a href="#4-1-自然语言描述" class="headerlink" title="4.1. 自然语言描述"></a>4.1. 自然语言描述</h4><ol>
<li>定义变量 a、b 并读入，确保 a&gt;=b（如果 a&lt;b 则交换）；</li>
<li>如果两个数都是偶数，那就不断除以 2 直至至少一个不是偶数；</li>
<li>如果一奇一偶，那就把那个偶数不断除以 2 直至它也为一个奇数；</li>
<li>对两个奇数进行辗转相减（或者辗转相除？上边那篇文章里这么说，但是除的话不是无法避免取模运算效率低下的问题了嘛 emm），直至求出它们的最大公约数；</li>
</ol>
<h4 id="4-1-流程图"><a href="#4-1-流程图" class="headerlink" title="4.1. 流程图"></a>4.1. 流程图</h4><p><img data-src="https://s1.ax1x.com/2022/12/05/zyTcJe.png" alt="Powered by draw.io"></p>
<h4 id="4-1-C-代码"><a href="#4-1-C-代码" class="headerlink" title="4.1. C++ 代码"></a>4.1. C++ 代码</h4><blockquote>
<p>(1) 按位与 (&amp;):</p>
<p>a&amp;x 为对数 a 的二进制形式的取位操作，即去 a 二进制形式的第 x 位。这里有一个重要应用就是 a&amp;1 可以用于判断数 a 的奇偶性，即 a 末位为 0 即为偶数，末位为 1 即为奇数。</p>
<p>(2) 异或运算 (^):</p>
<p>具体介绍参考之前的随笔：<a href="http://www.cnblogs.com/COLIN-LIGHTNING/p/8298554.html%EF%BC%9B">http://www.cnblogs.com/COLIN-LIGHTNING/p/8298554.html；</a><br>应用为交换两数：a^=b,b^=a,a^=b 即完成了两数交换。</p>
<p>(3) 按位左移 (&lt;&lt;):</p>
<p>a&lt;&lt;=x 即为使 a 乘以 2 的 x 次幂，原理是让 a 的二进制形式左移 x 位；应用为对与 2 的幂次方相乘使运算更快更方便；</p>
<p>(4) 按位右移 (&gt;&gt;):</p>
<p>a&gt;&gt;=x 即为使 a 除以 2 的 x 次幂，原理是让 a 的二进制形式右移 x 位；应用为对与 2 的幂次方相除使运算更快更方便；</p>
</blockquote>
<p>大佬的代码大致是这样的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        a ^= b, b ^= a, a ^= b; <span class="comment">// 确保 a&gt;=b，也可以 swap(a,b);</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> ((!(a &amp; <span class="number">1</span>)) &amp;&amp; (!(b &amp; <span class="number">1</span>)))        <span class="comment">// a&amp;1 若为 0 表示 a%2==0，也就是 a 能被 2 整除；</span></span><br><span class="line">                                         <span class="comment">// 若非 0 则表示 a%2!=0，也就是 a 不能被 2 整除。</span></span><br><span class="line">                                         <span class="comment">// b&amp;1 类似。所以这里判断的是 “当 a、b 都是偶数的时候”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 步骤 2：将 a、b 都除以 2。注意最后的左移，在递归返回过程中将2因子乘上。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) &amp;&amp; (!(b &amp; <span class="number">1</span>)))      <span class="comment">// “当 a 为奇数，b 为偶数时”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a, b &gt;&gt; <span class="number">1</span>);           <span class="comment">// 步骤 3：将仍为偶数的那个数不断除以 2 直至其为奇数。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((!(a &amp; <span class="number">1</span>)) &amp;&amp; (b &amp; <span class="number">1</span>))      <span class="comment">// “当 a 为偶数，b 为奇数时”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b);           <span class="comment">// 与上面类似</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a - b, b); <span class="comment">// 步骤 4：用辗转相减法处理，求取这两个奇数的最大公约数;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="版本二："><a href="#版本二：" class="headerlink" title="版本二："></a>版本二：</h3><p>来自<a href="https://blog.csdn.net/Brilliance_panpan/article/details/88372432">这里</a>，对均为奇数的情况做了不同的处理，其他都是一样的。</p>
<h4 id="4-2-自然语言描述"><a href="#4-2-自然语言描述" class="headerlink" title="4.2. 自然语言描述"></a>4.2. 自然语言描述</h4><ol>
<li>定义变量 a、b 并读入；</li>
<li>如果 a==b，则直接返回 a 或 b，否则下一步；</li>
<li>如果 a&lt;b，交换 a、b 的值，确保 a&gt;b；</li>
<li>判断属于下边哪种情况，按对应的情况更新 a、b 的值，回到步骤 2。</li>
</ol>
<p>四种情况分别是：</p>
<ol>
<li>均为偶数: gcd (a,b) = 2 * gcd (a/2,b/2);</li>
<li> 均为奇数: gcd (a,b) = gcd ((a+b)/2,(a-b)/2);</li>
<li>a 为奇数，b 为偶数: gcd (a,b) = gcd (a,b/2);</li>
<li>a 为偶数，b 为奇数: gcd (a,b) = gcd (a/2,b);</li>
</ol>
<h4 id="4-2-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2. 流程图"></a>4.2. 流程图</h4><p><img data-src="https://s1.ax1x.com/2022/12/05/zyTgRH.png" alt="Powered by draw.io"></p>
<h4 id="4-2-C-代码"><a href="#4-2-C-代码" class="headerlink" title="4.2. C++ 代码"></a>4.2. C++ 代码</h4><p>最后代码和上边也没有太大差别。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        a ^= b, b ^= a, a ^= b;</span><br><span class="line">    <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>))            <span class="comment">// 均为偶数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 别忘了要乘回来</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>))         <span class="comment">// 均为奇数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>((a + b) &gt;&gt; <span class="number">1</span>, (a - b) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>)) <span class="comment">// a 奇 b 偶</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="comment">// a 偶 b 奇</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><a href="https://blog.csdn.net/Brilliance_panpan/article/details/88372432">《求最大公约数的 4 种常用算法 <em>AmethystFOB 的博客 - CSDN 博客</em>求最大公约数的四种算法》</a></li>
<li><a href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF">《更相减损术_百度百科 (baidu.com)》</a></li>
<li><a href="https://blog.csdn.net/Dan1374219106/article/details/106676043">《教你写一手漂亮的伪代码（详细规则 &amp; 简单实例）_<em>陈同学</em>的博客 - CSDN 博客_伪代码的简单例子》</a></li>
<li><a href="https://www.php.cn/csharp-article-415083.html">《伪代码是什么？如何写一个伪代码？-C#.Net 教程 - PHP 中文网》</a></li>
<li><a href="https://baike.baidu.com/item/%E6%B5%81%E7%A8%8B%E5%9B%BE/206961">《流程图_百度百科 (baidu.com)》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/359722998">《for、while、do while 三种循环的流程图画法总结（附案例） - 知乎 (zhihu.com)》</a></li>
<li><a href="https://www.liuchengtu.com/tutorial/switchlct.html">《switch 语句流程图怎么画？简单的 switch 语句流程图模板分享 (liuchengtu.com)》</a></li>
<li><a href="https://www.cnblogs.com/COLIN-LIGHTNING/p/8425484.html">《浅谈 Stein 算法求最大公约数 (GCD) 的原理及简单应用 - COLINGAO - 博客园 (cnblogs.com)》</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Algorithms &amp; Data structures</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>Set up a blog with Hexo</title>
    <url>/posts/4ef0ac98.html</url>
    <content><![CDATA[<p>This is a simple record of my other trial to set up a blog with Hexo. I have built one on GitHub Page before, using Hexo with Icarus theme. This time, I want to try something else. I also cleaned my old blog and selectively migrated some old posts here.</p>
<span id="more"></span>

<p><img data-src="https://s1.ax1x.com/2023/04/15/p9ppsZ8.png" alt="Hexo"></p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>You need to install <a href="http://nodejs.org/">Node.js</a> and <a href="http://git-scm.com/">Git</a> before installing Hexo.</p>
<p>After that, you could run this command to install Hexo.</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>

<p>The <code>-g</code> flag indicates that Hexo is installed globally.</p>
<p>Learn more on <a href="https://hexo.io/docs/">Hexo Docs</a>.</p>
<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>You need to make a directory <code>&lt;folder&gt;</code> to store your Hexo blog. Here I use <code>fishpond</code>.</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo init fishpond</span><br><span class="line">$ <span class="built_in">cd</span> fishpond</span><br><span class="line">$ npm install</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <a href="https://hexo.io/docs/setup">Hexo Docs</a>.</p>
<h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p>Before starting to use your blog, you may choose a <a href="https://hexo.io/themes/">theme</a> you like.</p>
<p><img data-src="https://s1.ax1x.com/2023/04/11/ppOnugs.png" alt="Hexo themes"></p>
<p>Here I choose <a href="https://theme-next.js.org/">NexT</a>. To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> fishpond</span><br><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></tbody></table></figure>

<p>After installing your own theme, you could uninstall the default <code>hexo-theme-landscape</code>:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-theme-landscape --save</span><br></pre></td></tr></tbody></table></figure>

<p>Also, clean the folder of the default theme landscape in <code>theme/</code>.</p>
<p>To enable NexT, open Hexo config file and set variable <code>theme</code> to <code>next</code>.</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Basic-configuration"><a href="#Basic-configuration" class="headerlink" title="Basic configuration"></a>Basic configuration</h2><h3 id="Hexo-configuration"><a href="#Hexo-configuration" class="headerlink" title="Hexo configuration"></a>Hexo configuration</h3><p>To configure your Hexo blog, modify <code>_config.yml</code>.</p>
<p>Here are my modifications in <code>_config.yml</code>:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">"Fish Pond"</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">"Posts swim here."</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"Here is BlockLune's blog."</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">BlockLune,</span> <span class="string">SaltedFish,</span> <span class="string">NJUPT,</span> <span class="string">IT,</span> <span class="string">F-Studio,</span> <span class="string">咸鱼,</span> <span class="string">个人博客</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">BlockLune</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">"raw/**"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">auto_spacing:</span> <span class="literal">true</span> <span class="comment"># put a space between Chinese and English</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">1</span> <span class="comment"># transform filenames to 1 (lower case) / 2 (upper case)</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">exclude_languages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mermaid</span></span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <em><a href="https://hexo.io/docs/configuration.html">Hexo Docs</a></em>.</p>
<h3 id="NexT-theme-configuration"><a href="#NexT-theme-configuration" class="headerlink" title="NexT theme configuration"></a>NexT theme configuration</h3><p>Before configuring, you need to copy the configuration file. Run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></tbody></table></figure>

<p>Then you can customize your own <code>_config.next.yml</code> as your wish.</p>
<p>Learn more on <em><a href="https://theme-next.js.org/docs/getting-started/configuration.html">Configuration | NexT (theme-next.js.org)</a></em>.</p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>You could install plugins to make your blog more powerful.</p>
<p>To list all the plugins you have installed, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm list --depth 0</span><br></pre></td></tr></tbody></table></figure>

<h3 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h3><p><a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> is a Hexo plugin to generate static post link based on title and data in the post front.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-abbrlink --save</span><br></pre></td></tr></tbody></table></figure>

<p>To configure it, modify <code>_config.yml</code>:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># URLs</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">"posts/:abbrlink.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">### hexo-abbrlink: https://github.com/rozbo/hexo-abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span> <span class="comment"># support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span> <span class="comment"># support dec(default) and hex</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="hexo-auto-category"><a href="#hexo-auto-category" class="headerlink" title="hexo-auto-category"></a>hexo-auto-category</h3><p><a href="https://github.com/xu-song/hexo-auto-category">hexo-auto-category</a> is a Hexo plugin which generates categories automatically from folder structure for each post.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-auto-category --save</span><br></pre></td></tr></tbody></table></figure>

<p>To configure it, modify <code>_config.yml</code>:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">### hexo-auto-category: https://github.com/xu-song/hexo-auto-category</span></span><br><span class="line"><span class="attr">auto_category:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="hexo-generator-feed"><a href="#hexo-generator-feed" class="headerlink" title="hexo-generator-feed"></a>hexo-generator-feed</h3><p><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> helps generate Atom 1.0 or RSS 2.0 feed.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></tbody></table></figure>

<p>To configure it, modify <code>_config.yml</code>. Here is my configuration:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">### hexo-generator-feed: https://github.com/hexojs/hexo-generator-feed</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">rss2</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">rss.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">"&lt;!--more--&gt;"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="hexo-generator-searchdb"><a href="#hexo-generator-searchdb" class="headerlink" title="hexo-generator-searchdb"></a>hexo-generator-searchdb</h3><p><a href="https://github.com/next-theme/hexo-generator-searchdb">hexo-generator-searchdb</a> provides a local search service.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></tbody></table></figure>

<h3 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h3><p><a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap</a> generates sitemap.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></tbody></table></figure>

<p>Configuration:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">### hexo-generator-sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sitemap.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sitemap.txt</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="hexo-pangu"><a href="#hexo-pangu" class="headerlink" title="hexo-pangu"></a>hexo-pangu</h3><p><a href="https://github.com/next-theme/hexo-pangu">hexo-pangu</a> severs side <a href="https://github.com/vinta/pangu.js">pangu.js</a> filter for Hexo.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-pangu --save</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="Manual-deployment"><a href="#Manual-deployment" class="headerlink" title="Manual deployment"></a>Manual deployment</h3><p><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a> helps deploy your blog to your GitHub Page.</p>
<p>To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>

<p>Modify <code>_config.yml</code>:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&lt;branch&gt;</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&lt;message&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <em><a href="https://hexo.io/docs/one-command-deployment">One-Command Deployment | Hexo</a></em>.</p>
<h3 id="Automatic-deployment"><a href="#Automatic-deployment" class="headerlink" title="Automatic deployment"></a>Automatic deployment</h3><h4 id="Using-GitHub-Action"><a href="#Using-GitHub-Action" class="headerlink" title="Using GitHub Action"></a>Using GitHub Action</h4><p>By using GitHub Action, our workflow of writing posts will be like this:</p>
<ol>
<li>Writes a post.</li>
<li>Uses <code>git push</code> to push your new post to your <strong>source repo</strong>.</li>
<li>A GitHub Action automatically starts, generating our blog pages.</li>
<li>Your <strong>GitHub Page repo</strong> updates automatically.</li>
</ol>
<p>Here are the steps:</p>
<ol>
<li><p>Create a new repository to store your source <code>*.md</code> posts. We call this <code>source repo</code>. It is recommended to make it <strong>private</strong>.</p>
</li>
<li><p>Add a <code>./.github/workflows/auto_build_and_deploy.yml</code> file. It may look like this:</p>
</li>
</ol>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Based on https://hexo.io/docs/github-pages.html</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">build</span> <span class="string">and</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;source_repo_branch&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">&lt;source_repo_branch&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">"16"</span> <span class="comment"># run `node --version` to show your nodejs version</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          export TZ='Asia/Shanghai'</span></span><br><span class="line"><span class="string">          npm install -g hexo-cli</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">${{runner.OS}}-${{hashFiles('**/package-lock.json')}}</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">'true'</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean </span></span><br><span class="line"><span class="string">          hexo g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">&lt;your_token&gt;</span></span><br><span class="line">          <span class="attr">repository-name:</span> <span class="string">&lt;your_github_name&gt;/&lt;your_github_name&gt;.github.io</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">&lt;github_page_repo_branch&gt;</span></span><br><span class="line">          <span class="attr">folder:</span> <span class="string">./public</span></span><br><span class="line">          <span class="attr">commit-message:</span> <span class="string">"$<span class="template-variable">{{ github.event.head_commit.message }}</span> Updated By Github Actions"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>&lt;your_token&gt;</code>: Generate it <a href="https://github.com/settings/tokens">here</a>. Make sure that its scope includes <code>workflow</code>.</p>
<p>Learn more on <em><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">Creating a personal access token - GitHub Docs</a></em>.</p>
<ol start="3">
<li>Configure the local git repo.</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># initialize</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># (optional) create a branch in source repo and change to it</span></span><br><span class="line">$ git checkout －b &lt;source_repo_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># connect to the remote repo</span></span><br><span class="line">$ git remote add &lt;server_short_name&gt; &lt;server_url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># add and commit</span></span><br><span class="line">$ git add .                              <span class="comment"># '.' means the current directory</span></span><br><span class="line">$ git commit -m <span class="string">"First commit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># push</span></span><br><span class="line">$ git push -u &lt;server_short_name&gt; &lt;source_repo_branch&gt;</span><br><span class="line"><span class="comment"># if you didn't change to another branch, # the default branch is 'main'</span></span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <em><a href="https://hexo.io/docs/github-pages.html">GitHub Pages | Hexo</a></em>.</p>
<h4 id="Using-Vercel"><a href="#Using-Vercel" class="headerlink" title="Using Vercel"></a>Using Vercel</h4><p>See <em><a href="https://blog.yunfinibol.top/2023/04/12/hexo-vercel-%E9%83%A8%E7%BD%B2/">hexo vercel 部署 | Yunfi’s Blog</a></em>.</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Where-is-my-index-html-in-categories-and-tags"><a href="#Where-is-my-index-html-in-categories-and-tags" class="headerlink" title="Where is my index.html in /categories and /tags ?"></a>Where is my index.html in /categories and /tags ?</h3><p>To generate index.html in <code>/categories</code>, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"categories"</span></span><br></pre></td></tr></tbody></table></figure>

<p>or</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo n page <span class="string">"categories"</span></span><br></pre></td></tr></tbody></table></figure>

<p>Then, edit <code>source/categories/index.md</code> like this:</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2023-04-12 00:00:00</span><br><span class="line"><span class="section">type: "categories"</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></tbody></table></figure>

<p>You can generate the index.html file in <code>/tags</code> similarly.</p>
<h2 id="Old-content"><a href="#Old-content" class="headerlink" title="Old content"></a>Old content</h2><p>Here are some old content migrated from my previous Icarus blog.</p>
<ul>
<li><p>Use Bulma to beautify your blog</p>
<p>See <em><a href="https://www.imaegoo.com/2020/icarus-with-bulma/">活用 Bulma 美化 Icarus 文章 - iMaeGoo’s Blog</a></em></p>
</li>
<li><p>Change fonts of Icarus.</p>
<p>Modify the <code>&lt;blog_path&gt;\node_modules\hexo-theme-icarus\include\style\base.styl</code>:</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">$family</span>-sans-serif ?= Ubuntu, Roboto, <span class="string">'Open Sans'</span>, <span class="string">'Microsoft YaHei'</span>, sans-serif</span><br><span class="line"><span class="variable">$family</span>-<span class="selector-tag">code</span> ?= <span class="string">'Source Code Pro'</span>, monospace, <span class="string">'Microsoft YaHei'</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Officially supported tags in Icarus</p>
<p>See <em><a href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/custom-hexo-tag-helpers/">Custom Hexo Tag Helpers - Icarus</a></em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>补记一个用 Vue.js 和 ElementUI 实现的在线抽奖网页</title>
    <url>/posts/6a8a1633.html</url>
    <content><![CDATA[<p>这件事儿发生在我的高中某个新学期开始，新来了一个电脑老师。有点打赌或者考验我的性质吧，ta 说 ta 弄了随机数点名的小网页，还能用同学的照片进行抽取，问我能不能实现一个。ta 的实现方法是 jQuery，技术上比较老，界面也不太好看。我想去尝试一下别的方法，正好也试试略微学了一点的 Vue.js，为了好看，用了 Element UI。</p>
<span id="more"></span>

<p>一两个周末最终实现到现在的效果，能输入名字抽人，能随机数抽人（学号抽人？），还有一个通过图片抽的到今天也还没做。当时对着 Vue.js 和 Element UI 的开发文档勉里勉强做出来这个效果，现在早把那些基础知识忘记了，也不知道以后有没有工夫完善它了。</p>
<p>你可以<a href="/raw/CatchDog/CatchDog.html">点击这里</a>来玩玩看。</p>
<p><img data-src="https://pic.imgdb.cn/item/6308b57316f2c2beb1fad0f4.png"><br><img data-src="https://pic.imgdb.cn/item/6308b57316f2c2beb1fad0ec.png"><br><img data-src="https://pic.imgdb.cn/item/6308b57216f2c2beb1fad081.png"><br><img data-src="https://pic.imgdb.cn/item/6308b57216f2c2beb1fad087.png"><br><img data-src="https://pic.imgdb.cn/item/6308b57216f2c2beb1fad091.png"></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Vue.js</tag>
        <tag>Element UI</tag>
        <tag>Html</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 插件推荐</title>
    <url>/posts/72a59031.html</url>
    <content><![CDATA[<p>你可能常年使用着国产的一些浏览器，却也常年遭受着各种弹窗、全家桶的侵扰…</p>
<p>你也可能不止一次地听过”Chrome”，安装下来后却发现他空空如也，又默默地装回那些国产…</p>
<p>那么，让这些插件来拯救你吧</p>
<span id="more"></span>

<blockquote>
<p>注：文中提到的<code>鹏少</code>、<code>Joker鹏少</code>等均指 B 站 up 主 <a href="https://space.bilibili.com/92678046">JOKER 鹏少</a>，版权归其所有。他也是我非常喜欢的一个 up 主，为避免误会，特此声明。介绍中的引用部分为各个插件自己的介绍。</p>
</blockquote>
<h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><p>问度娘～或者在<a href="https://www.bilibili.com/video/av29290563">这里</a>观看视频教程</p>
<h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><h3 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>The world’s most popular userscript manager</p>
</blockquote>
<p>一个脚本管理插件，允许你自己通过编写脚本来实现某种功能，也可以下载脚本使用</p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="谷歌访问助手"><a href="#谷歌访问助手" class="headerlink" title="谷歌访问助手"></a>谷歌访问助手</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>最简单易用的谷歌访问助手，为 chrome 扩展用户量身打造。可以解决 chrome 扩展无法自动更新的问题，同时可以访问谷歌 google 搜索，Gmail 邮箱，google + 等谷歌服务。</p>
</blockquote>
<p>帮助你访问所有 Google 的页面</p>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vRECiF.jpg" alt="谷歌访问助手"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/gocklaboggjfkolaknpbhddbaopcepfp?hl=zh-CN">Chrome 网上应用店</a></p>
<p>你也可以去<a href="https://www.jokerps.com/851.html">鹏少资源网</a>下载不用锁定主页的特别版</p>
</li>
</ul>
<h3 id="Infinity-新标签页-Pro"><a href="#Infinity-新标签页-Pro" class="headerlink" title="Infinity 新标签页(Pro)"></a>Infinity 新标签页 (Pro)</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>百万用户选择的新标签页和快速拨号，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录。使你的主页和开始页更加美观和易用</p>
</blockquote>
<p>在<a href="https://www.bilibili.com/video/av18789095">这里</a>可以观看鹏少更详细的介绍</p>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREmdK.jpg" alt="Infinity新标签页"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>本扩展支持百度、搜狗、必应、好搜、谷歌搜索结果的页面结果广告优化和显示内容优化。绕过百度和搜狗的重定向，同时优化主流搜索引擎的搜索结果的样式效果，更方便快速的得到搜索的真实内容，更符合用户习惯。同时支持双列三列甚至四列展示百度谷歌和必应的页面，还自带有护眼模式</p>
</blockquote>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREeZ6.jpg" alt="安装百度优化插件后的Google主页"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="%5Bhttps://chrome.google.com/webstore/detail/%E7%99%BE%E5%BA%A6%E4%BC%98%E5%8C%96/denccnggppnbllgifimhkcehbpmlljcp%5D(https://chrome.google.com/webstore/detail/%E7%99%BE%E5%BA%A6%E4%BC%98%E5%8C%96/denccnggppnbllgifimhkcehbpmlljcp)">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="划词翻译"><a href="#划词翻译" class="headerlink" title="划词翻译"></a>划词翻译</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>支持谷歌、百度、有道三大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。</p>
</blockquote>
<p>同类型的软件很多 但是自己感觉这款最轻量好用</p>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREAMR.jpg" alt="划词翻译界面"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="%5Bhttps://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad%5D(https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad)">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="FireShot"><a href="#FireShot" class="headerlink" title="FireShot"></a>FireShot</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>捕捉网页截图，编辑并将它们保存为 PDF，JPEG，GIF，PNG 或 BMP；上传，打印，在 Photoshop 中打开，复制到剪贴板或电子邮件</p>
</blockquote>
<p>在<a href="https://www.bilibili.com/video/av44274712">这里</a>可以观看鹏少更详细的介绍</p>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREiRJ.jpg" alt="一张用FireShot截取的维基百科首页"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。</p>
</blockquote>
<p>在<a href="https://www.bilibili.com/video/av27145745">这里</a>可以观看鹏少更详细的介绍</p>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREVqx.jpg" alt="使用Stylus中“Baidu Lite 百度轻”后的百度主页"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Chrome 网上应用店</a></p>
<p><a href="https://add0n.com/stylus.html">官网</a></p>
</li>
</ul>
<h3 id="Adblock-Plus"><a href="#Adblock-Plus" class="headerlink" title="Adblock Plus"></a>Adblock Plus</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>Adblock Plus 是拥有超过 5 亿次下载的全球最受欢迎的广告拦截软件之一。</p>
</blockquote>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="AdGuard-广告拦截器"><a href="#AdGuard-广告拦截器" class="headerlink" title="AdGuard 广告拦截器"></a>AdGuard 广告拦截器</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>广告拦截扩展对抗广告和弹出窗口。拦截 Facebook，YouTube 和所有其它网站的广告。</p>
</blockquote>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="Clutter-Free"><a href="#Clutter-Free" class="headerlink" title="Clutter Free"></a>Clutter Free</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>Reduce tab clutter - prevent duplicate tabs, quickly search &amp; switch tabs, and more…</p>
</blockquote>
<p>自动关闭重复打开的标签页</p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/clutter-free-prevent-dupl/iipjdmnoigaobkamfhnojmglcdbnfaaf">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="crxMouse-Chrome™-手势"><a href="#crxMouse-Chrome™-手势" class="headerlink" title="crxMouse Chrome™ 手势"></a>crxMouse Chrome™ 手势</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>方便，快捷，充分发掘鼠标的所有操作。功能包括：鼠标手势，超级拖曳，滚轮手势，摇杆手势，平滑滚动，标签页列表等.</p>
</blockquote>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREFz9.jpg" alt="crxMouse设置界面"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo">Chrome 网上应用店</a></p>
<p><a href="https://crxmouse.com/zh-hans/">官网</a></p>
</li>
</ul>
<h3 id="IE-Tab"><a href="#IE-Tab" class="headerlink" title="IE Tab"></a>IE Tab</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>在标签页中以 IE 内核显示网页。快捷、强健、可靠。这个版本是最流行的一个原因。</p>
</blockquote>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="Imagus"><a href="#Imagus" class="headerlink" title="Imagus"></a>Imagus</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>Enlarge thumbnails, and show images/videos from links with a mouse hover.</p>
</blockquote>
<p>在<a href="https://www.bilibili.com/video/av44940125">这里</a>可以观看鹏少更详细的介绍</p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="Lazy-Tabs"><a href="#Lazy-Tabs" class="headerlink" title="Lazy Tabs"></a>Lazy Tabs</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>Unload all inactive tabs (except pinned) at startup or by clicking an icon</p>
</blockquote>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/lazy-tabs/aabgbgciohhaogajcnacpgilhmacdahc">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>节省高达 95％的内存，并减轻标签页混乱现象</p>
</blockquote>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREEs1.jpg" alt="将打开的三个标签页全部聚拢"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">Chrome 网上应用店</a></p>
</li>
</ul>
<h3 id="云盘万能钥匙"><a href="#云盘万能钥匙" class="headerlink" title="云盘万能钥匙"></a>云盘万能钥匙</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>您的云盘智能助手</p>
</blockquote>
<p>在<a href="https://www.bilibili.com/video/av55835350">这里</a>可以观看鹏少更详细的介绍</p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/%E4%BA%91%E7%9B%98%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99/anlllmnpjodopgbkbpnghnjlelnogfjc">Chrome 网上应用店</a></p>
<p><a href="https://extension.yunpanjingling.com/">官网</a></p>
</li>
</ul>
<h2 id="适用于-B-站朋友们的插件"><a href="#适用于-B-站朋友们的插件" class="headerlink" title="适用于 B 站朋友们的插件"></a>适用于 B 站朋友们的插件</h2><h3 id="哔哩哔哩助手"><a href="#哔哩哔哩助手" class="headerlink" title="哔哩哔哩助手"></a>哔哩哔哩助手</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>哔哩哔哩弹幕网辅助扩展，拥有视频区和直播区的人性化功能</p>
</blockquote>
</li>
<li><p><strong>截图预览</strong></p>
<p><img data-src="https://s1.ax1x.com/2022/08/26/vREPG4.jpg" alt="bilibili助手设置页面"></p>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A9%E6%89%8B%EF%BC%9Abilibilicom-%E7%BB%BC%E5%90%88%E8%BE%85%E5%8A%A9%E6%89%A9%E5%B1%95/kpbnombpnpcffllnianjibmpadjolanh">Chrome 网上应用店</a></p>
<p><a href="https://bilibili-helper.github.io/">官网</a></p>
</li>
</ul>
<h3 id="获取哔哩哔哩-bilibili-视频的封面图片"><a href="#获取哔哩哔哩-bilibili-视频的封面图片" class="headerlink" title="获取哔哩哔哩 bilibili 视频的封面图片"></a>获取哔哩哔哩 bilibili 视频的封面图片</h3><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>获取哔哩哔哩 bilibili 视频的封面图片</p>
</blockquote>
</li>
<li><p><strong>下载地址</strong></p>
<p><a href="https://chrome.google.com/webstore/detail/%E8%8E%B7%E5%8F%96%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9bilibili%E8%A7%86%E9%A2%91%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87/egodkcidolldembjebmiepoibpahmllh">Chrome 网上应用店</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>Edge 扩展推荐</title>
    <url>/posts/3c91f84e.html</url>
    <content><![CDATA[<p>2019 年 7 月写过一篇 Chrome 插件推荐的文章，那时候我还在用 Chrome 作为我的主要浏览器。一晃三年过去了，我也早已从 Google Chrome 转入全新 Chromium 内核构建的 Edge 浏览器。微软倒蛮有意思，自己从头开发的东西不咋地，在别人的平台上倒是表现得相当好。由于国内的水土不服啊，我用 Chrome 时总会遇到同步不了的情况，这点的体验在 Edge 这儿得到了很好的改善，也是我用 Edge 的主要原因吧。前些天帮很多同学做新机开荒，也推荐他们就用这款 “Win11 原装” 浏览器。当然一个浏览器肯定是离不开扩展的，趁着帮他们开荒这个机会，也顺便整理了我认为必备的一些浏览器扩展。</p>
<span id="more"></span>

<p><strong>本文更多的从个人角度出发，仅涵盖了笔者的主要需求，自然是粗略的，仅供参考。</strong></p>
<h2 id="全部用户"><a href="#全部用户" class="headerlink" title="全部用户"></a>全部用户</h2><h3 id="Dark-Reader"><a href="#Dark-Reader" class="headerlink" title="Dark Reader"></a>Dark Reader</h3><p>简介：强制暗黑模式的网页</p>
<h3 id="Infinity-新标签页-Pro"><a href="#Infinity-新标签页-Pro" class="headerlink" title="Infinity 新标签页 (Pro)"></a>Infinity 新标签页 (Pro)</h3><p>简介：rt，一个新标签页扩展</p>
<h3 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><p>简介： 打开了太多网页的时候，按一下可以帮你全部收起来，之后可以自由恢复</p>
<h3 id="Prevent-Duplicate-Tabs"><a href="#Prevent-Duplicate-Tabs" class="headerlink" title="Prevent Duplicate Tabs"></a>Prevent Duplicate Tabs</h3><p>简介： 帮你干掉那些重复的标签页</p>
<h3 id="uBlock-Origin"><a href="#uBlock-Origin" class="headerlink" title="uBlock Origin"></a>uBlock Origin</h3><p>简介：干掉广告，且是众多去广告插件中占用相对较少的</p>
<h3 id="捕捉网页截图-FireShot-的"><a href="#捕捉网页截图-FireShot-的" class="headerlink" title="捕捉网页截图 - FireShot 的"></a>捕捉网页截图 - FireShot 的</h3><p>简介：rt，支持长截图（名字有点怪，可能是翻译问题，搜索 FireShot 就能找到）</p>
<h3 id="暴力猴"><a href="#暴力猴" class="headerlink" title="暴力猴"></a>暴力猴</h3><p>简介：装脚本的插件，和大名鼎鼎的油猴一样的功能，这个可能 (?) 小巧一点</p>
<h3 id="沙拉查词-聚合词典划词翻译"><a href="#沙拉查词-聚合词典划词翻译" class="headerlink" title="沙拉查词-聚合词典划词翻译"></a>沙拉查词 - 聚合词典划词翻译</h3><p>简介：rt，划词翻译，可配置内容超多</p>
<h3 id="Imagus"><a href="#Imagus" class="headerlink" title="Imagus"></a>Imagus</h3><p>简介：可以把网页图片放大了看</p>
<h3 id="User-Agent-Switcher-for-Chrome"><a href="#User-Agent-Switcher-for-Chrome" class="headerlink" title="User-Agent Switcher for Chrome"></a>User-Agent Switcher for Chrome</h3><p>简介：“伪装” 你自己</p>
<h3 id="Video-Speed-Controller"><a href="#Video-Speed-Controller" class="headerlink" title="Video Speed Controller"></a>Video Speed Controller</h3><p>简介：rt，但是竟然也可以改视频前广告的播放速度！</p>
<h2 id="哔哩哔哩用户"><a href="#哔哩哔哩用户" class="headerlink" title="哔哩哔哩用户"></a>哔哩哔哩用户</h2><h3 id="pakku：哔哩哔哩弹幕过滤器"><a href="#pakku：哔哩哔哩弹幕过滤器" class="headerlink" title="pakku：哔哩哔哩弹幕过滤器"></a>pakku：哔哩哔哩弹幕过滤器</h3><p>简介：简化（过滤）你的 b 站弹幕</p>
<h3 id="哔哩哔哩助手：bilibili-com-综合辅助扩"><a href="#哔哩哔哩助手：bilibili-com-综合辅助扩" class="headerlink" title="哔哩哔哩助手：bilibili.com 综合辅助扩"></a>哔哩哔哩助手：bilibili.com 综合辅助扩</h3><p>简介：功能超多，我主要用来下载 b 站视频了</p>
<h2 id="Steam-用户"><a href="#Steam-用户" class="headerlink" title="Steam 用户"></a>Steam 用户</h2><h3 id="Augmented-Steam"><a href="#Augmented-Steam" class="headerlink" title="Augmented Steam"></a>Augmented Steam</h3><p>简介：为 steam 官网提供了众多试用的玩意儿</p>
<h2 id="IT-工作者"><a href="#IT-工作者" class="headerlink" title="IT 工作者"></a>IT 工作者</h2><h3 id="Octotree-GitHub-code-tree"><a href="#Octotree-GitHub-code-tree" class="headerlink" title="Octotree - GitHub code tree"></a>Octotree - GitHub code tree</h3><p>简介：方便地查看 github 上某个 repository 的文件结构</p>
<h3 id="Surfingkeys"><a href="#Surfingkeys" class="headerlink" title="Surfingkeys"></a>Surfingkeys</h3><p>简介：像 vim 一样的玩意儿，让你完全用你的键盘浏览网页</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Browser</tag>
        <tag>Edge</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 公式基础</title>
    <url>/posts/848a7d31.html</url>
    <content><![CDATA[<p>用 LaTeX 写数学公式的时候，总记不住一些写法，故在此记录学习笔记。</p>
<span id="more"></span>

<h2 id="常见符号"><a href="#常见符号" class="headerlink" title="常见符号"></a>常见符号</h2><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p>大小写希腊字母的写法区别就在于 LaTeX 符号的首字母大小写。</p>
<p>若要使用斜体只要在前面加上 <code>var</code> 前缀，例如 <code>\varGamma</code> 可以用来显示 $\varGamma$ 。</p>
<table>
<thead>
<tr>
<th>大写字母</th>
<th> LaTeX 写法</th>
<th>小写字母</th>
<th> LaTeX 写法</th>
</tr>
</thead>
<tbody><tr>
<td> $\Alpha$</td>
<td>\Alpha</td>
<td>$\alpha$</td>
<td>\alpha</td>
</tr>
<tr>
<td>$\Beta$</td>
<td>\Beta</td>
<td>$\beta$</td>
<td>\beta</td>
</tr>
<tr>
<td>$\Gamma$</td>
<td>\Gamma</td>
<td>$\gamma$</td>
<td>\gamma</td>
</tr>
<tr>
<td>$\Delta$</td>
<td>\Delta</td>
<td>$\delta$</td>
<td>\delta</td>
</tr>
<tr>
<td>$\Epsilon$</td>
<td>\Epsilon</td>
<td>$\epsilon$</td>
<td>\epsilon</td>
</tr>
<tr>
<td>$\Zeta$</td>
<td>\Zeta</td>
<td>$\zeta$</td>
<td>\zeta</td>
</tr>
<tr>
<td>$\Eta$</td>
<td>\Eta</td>
<td>$\eta$</td>
<td>\eta</td>
</tr>
<tr>
<td>$\Theta$</td>
<td>\Theta</td>
<td>$\theta$</td>
<td>\theta</td>
</tr>
<tr>
<td>$\Iota$</td>
<td>\Iota</td>
<td>$\iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$\Kappa$</td>
<td>\Kappa</td>
<td>$\kappa$</td>
<td>\kappa</td>
</tr>
<tr>
<td>$\Lambda$</td>
<td>\Lambda</td>
<td>$\lambda$</td>
<td>\lambda</td>
</tr>
<tr>
<td>$\Mu$</td>
<td>\Mu</td>
<td>$\mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$\Nu$</td>
<td>\Nu</td>
<td>$\nu$</td>
<td>\nu</td>
</tr>
<tr>
<td>$\Xi$</td>
<td>\Xi</td>
<td>$\xi$</td>
<td>\xi</td>
</tr>
<tr>
<td>$\Omicron$</td>
<td>\Omicron</td>
<td>$\omicron$</td>
<td>\omicron</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>\Pi</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>$\Rho$</td>
<td>\Rho</td>
<td>$\rho$</td>
<td>\rho</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>\Sigma</td>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\Tau$</td>
<td>\Tau</td>
<td>$\tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\Upsilon$</td>
<td>\Upsilon</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\Phi$</td>
<td>\Phi</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td>$\Chi$</td>
<td>\Chi</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\Psi$</td>
<td>\Psi</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>\Omega</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
</tbody></table>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th>渲染结果</th>
<th> LaTeX 写法</th>
<th>记法</th>
</tr>
</thead>
<tbody><tr>
<td> $\pm$</td>
<td>\pm</td>
<td> 英文：<strong>P</strong>lus + <strong>M</strong>inus</td>
</tr>
<tr>
<td>$\mp$</td>
<td>\mp</td>
<td> 英文：<strong>M</strong>inus + <strong>P</strong>lus</td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
<td><strong>times</strong> 就有 “乘” 的意思</td>
</tr>
<tr>
<td> $\div$</td>
<td>\div</td>
<td>$6 \div 3=2$ 表述为：Six <strong>div</strong>ided by two is three.</td>
</tr>
<tr>
<td>$\geq$</td>
<td>\geq</td>
<td>“大于等于” 的英文：<strong>g</strong>reater than or <strong>eq</strong>ual to</td>
</tr>
<tr>
<td>$\leq$</td>
<td>\leq</td>
<td>“小于等于” 的英文：<strong>l</strong>ess than or <strong>eq</strong>ual to</td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
<td>“不等于” 的英文：<strong>n</strong>ot <strong>eq</strong>ual to</td>
</tr>
<tr>
<td>$\approx$</td>
<td>\approx</td>
<td>“约等于” 的英文：<strong>approx</strong>imately equal to</td>
</tr>
<tr>
<td>$\propto$</td>
<td>\propto</td>
<td>“正比于” 的英文：be <strong>prop</strong>ortional <strong>to</strong></td>
</tr>
</tbody></table>
<h3 id="圈与点"><a href="#圈与点" class="headerlink" title="圈与点"></a>圈与点</h3><table>
<thead>
<tr>
<th>渲染结果</th>
<th> LaTeX 写法</th>
</tr>
</thead>
<tbody><tr>
<td> $\degree$</td>
<td>\degree</td>
</tr>
<tr>
<td>$\circ$</td>
<td>\circ</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
</tr>
<tr>
<td>$\cdotp$</td>
<td>\cdotp</td>
</tr>
<tr>
<td>$\cdots$</td>
<td>\cdots</td>
</tr>
<tr>
<td>$\ddots$</td>
<td>\ddots</td>
</tr>
<tr>
<td>$\bullet$</td>
<td>\bullet</td>
</tr>
<tr>
<td>$\dot{a}$</td>
<td>\dot{a}</td>
</tr>
</tbody></table>
<h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><table>
<thead>
<tr>
<th>渲染结果</th>
<th> LaTeX 写法</th>
</tr>
</thead>
<tbody><tr>
<td> $\in$</td>
<td>\in</td>
</tr>
<tr>
<td>$\notin$</td>
<td>\notin</td>
</tr>
<tr>
<td>$\subset$</td>
<td>\subset</td>
</tr>
<tr>
<td>$\subseteq$</td>
<td>\subseteq</td>
</tr>
<tr>
<td>$\supset$</td>
<td>\supset</td>
</tr>
<tr>
<td>$\supseteq$</td>
<td>\supseteq</td>
</tr>
<tr>
<td>$\cap$</td>
<td>\cap</td>
</tr>
<tr>
<td>$\cup$</td>
<td>\cap</td>
</tr>
<tr>
<td>$\complement$</td>
<td>\complement</td>
</tr>
</tbody></table>
<h2 id="上下标的输入方法"><a href="#上下标的输入方法" class="headerlink" title="上下标的输入方法"></a>上下标的输入方法</h2><p>上标 <code>^</code> ，下标 <code>_</code>，例如：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line">X<span class="built_in">_</span>1 = a<span class="built_in">^</span>2,X<span class="built_in">_</span>2 = b<span class="built_in">^</span>2</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>X_1 = a^2,X_2 = b^2<br>$$</p>
<p>同时上下标，只要连续输入 <code>_</code> 和 <code>^</code> 即可，例如:</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line">X<span class="built_in">_</span>3<span class="built_in">^</span>2 = 9,X<span class="built_in">_</span>4<span class="built_in">^</span>2 = 16</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>X_3^2 = 9,X_4^2 = 16<br>$$</p>
<p>上下标如果由多字符组成，则需要加上花括号，例如：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line">X<span class="built_in">_</span>{i+j}<span class="built_in">^</span>{k+l}</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>X_{i+j}^{k+l}<br>$$</p>
<p>左边的上下标只要写在前面就行了，例如：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">^</span>a<span class="built_in">_</span>bX<span class="built_in">^</span>c<span class="built_in">_</span>d</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>^a_bX^c_d<br>$$</p>
<p>所以除了通过 <code>\degree</code> 的方法写度数，也可以通过上标的方法达到类似效果：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line">45<span class="keyword">\degree</span>,90<span class="built_in">^</span>{<span class="keyword">\circ</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>45\degree,90^{\circ}<br>$$</p>
<p>“上升”：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line">X<span class="built_in">^</span>{X<span class="built_in">^</span>{X<span class="built_in">^</span>{X<span class="built_in">^</span>{X<span class="built_in">^</span>{X}}}}}</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>X^{X^{X^{X^{X^{X}}}}}<br>$$</p>
<p>” 下降 “：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line">X<span class="built_in">_</span>{X<span class="built_in">_</span>{X<span class="built_in">_</span>{X<span class="built_in">_</span>{X<span class="built_in">_</span>{X}}}}}</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>X_{X_{X_{X_{X_{X}}}}}<br>$$</p>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>{a}{b}</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>\frac{a}{b}<br>$$</p>
<h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><table>
<thead>
<tr>
<th>渲染结果</th>
<th> LaTeX 写法</th>
</tr>
</thead>
<tbody><tr>
<td> $\sqrt{2}$</td>
<td>\sqrt{2}</td>
</tr>
<tr>
<td>$\sqrt[3]{2}$</td>
<td>\sqrt[3]{2}</td>
</tr>
</tbody></table>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>[b]{a}</span><br></pre></td></tr></tbody></table></figure>

<p>$$<br>\sqrt[b]{a}<br>$$</p>
<h2 id="其他常用符号写法"><a href="#其他常用符号写法" class="headerlink" title="其他常用符号写法"></a>其他常用符号写法</h2><table>
<thead>
<tr>
<th>渲染结果</th>
<th> LaTeX 写法</th>
<th>记法</th>
</tr>
</thead>
<tbody><tr>
<td> $\to$</td>
<td>\to</td>
<td></td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
<td>” 无穷 “的英文：<strong>inf</strong>ini<strong>ty</strong></td>
</tr>
<tr>
<td>$\lim_{x \to 0}$</td>
<td>\lim_{x \to 0}</td>
<td></td>
</tr>
<tr>
<td>$\bot$</td>
<td>\bot</td>
<td></td>
</tr>
<tr>
<td>$\perp$</td>
<td>\perp</td>
<td>” 相互垂直 “的英文：<strong>perp</strong>endicular to each other</td>
</tr>
<tr>
<td>$\dot{a}$</td>
<td>\dot{a}</td>
<td></td>
</tr>
<tr>
<td>$\hat{a}$</td>
<td>\hat{a}</td>
<td></td>
</tr>
<tr>
<td>$\bar{a}$</td>
<td>\bar{a}</td>
<td></td>
</tr>
<tr>
<td>$\vec{a}$</td>
<td>\vec{a}</td>
<td>” 向量 “的英文：<strong>vec</strong>tor</td>
</tr>
<tr>
<td>$\tilde{a}$</td>
<td>\tilde{a}</td>
<td>” 波浪号 “的英文：<strong>tilde</strong></td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/erciyuan_/article/details/90273268">latex 公式语法_ecy_uooki 的博客 - CSDN 博客_latex 公式语法</a></li>
<li><a href="https://blog.csdn.net/bagba/article/details/123608562">latex 不等于符号_Bagba 的博客 - CSDN 博客_latex 不等于</a></li>
<li><a href="https://www.codeleading.com/article/36564801982/">latex 补集怎么打 - 代码先锋网 (codeleading.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/262907455">如何用 latex 编写上标、下标？ - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 简单笔记</title>
    <url>/posts/b5f1b38d.html</url>
    <content><![CDATA[<p>这是一篇笔记，原视频是 <a href="https://space.bilibili.com/519963684">@于仕琪</a> 老师的 <a href="https://www.bilibili.com/video/BV188411L7d2">《Makefile 20 分钟入门，简简单单，展示如何使用 Makefile 管理和编译 C++ 代码》</a>。</p>
<span id="more"></span>

<h2 id="老师所给的四个版本"><a href="#老师所给的四个版本" class="headerlink" title="老师所给的四个版本"></a>老师所给的四个版本</h2><figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 版本一</span></span><br><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">    g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本二</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c factorial.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本三</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本四</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>首先是关于 g++ 这个 C++ 编译器的一些知识点。</p>
<ul>
<li><code>-c</code> 参数表示生成 obj 文件（<code>*.o</code>）；</li>
<li><code>-o</code> 用于指定生成的可执行文件的名称，比如上边 <code>-o hello</code> 就表示生成的可执行文件叫 hello；</li>
<li><code>-Wall</code> 表示 Warning all，也就是打开全部的警告。</li>
</ul>
<p>接着是 Makefile 文件的大致原理。</p>
<p>首先看最易理解的版本一。</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">    g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></tbody></table></figure>

<p>第一行冒号前的部分表示我们需要的文件（这里是 <code>hello</code>），冒号后表示冒号前文件的依赖项（这里是三个 <code>.cpp</code> 文件），第二行表示为了生成冒号前的文件，需要执行什么命令。Make 工具通过检测冒号后文件的时间戳是否比冒号前文件更新来判断是否要执行第二行语句。</p>
<p>在第二个版本中，引入了变量的概念。形似 <code>XXX = YYY</code> 的东西就是在给变量赋值，使用 <code>$(XXX)</code> 来取得值 <code>YYY</code>。</p>
<p>第三个版本中出现了 <code>$@</code>、<code>$^</code>、<code>$&lt;</code> 等符号，他们分别表示冒号前面的内容、冒号后边的全部内容和冒号后边第一个内容。</p>
<p>第三个版本中的 <code>.PHONY: clean</code> 标识了 <code>clean</code> 是个命令而不是一个文件，这样结合下边的 <code>clean:</code> 的内容，就可以实现直接在终端输入 <code>make clean</code> 来执行 <code>rm -f *.o $(TARGET)</code> 的命令，清空生成出来的文件。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>GNU Make</tag>
        <tag>Compiling</tag>
      </tags>
  </entry>
  <entry>
    <title>Package managers in Linux (To be continued)</title>
    <url>/posts/4ee6ac78.html</url>
    <content><![CDATA[<p>This post tries to simply introduce some package managers and their basic usage.</p>
<span id="more"></span>

<h2 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h2><p>The pacman package manager is the default package manager of Arch Linux. Learn more about pacman on the official wiki <a href="https://wiki.archlinux.org/title/Pacman">here</a>.</p>
<h3 id="pacman-Changing-to-mirror"><a href="#pacman-Changing-to-mirror" class="headerlink" title="pacman - Changing to mirror"></a>pacman - Changing to mirror</h3><p>Before you start to use pacman, changing its source to mirror source in your country might be greatly helpful.</p>
<p>Firstly, find a mirror you need on <a href="https://archlinux.org/mirrors/">Mirror Overview of ArchLinux offical site</a>. Here I choose the mirror from my mother school, whose URL is <code>https://mirrors.njupt.edu.cn/archlinux/</code>.</p>
<p>Then, edit <code>/etc/pacman.d/mirrorlist</code> , and paste the string below into the file.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Server = https://mirrors.njupt.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></tbody></table></figure>

<p>Last, save the file and run <code>sudo pacman -Syu</code> to update.</p>
<blockquote>
<p>The file <code>/etc/pacman.d/mirrorlist</code> has already provided many mirrors in it. So you can just skip the first step above, just edit the mirrorlist file. Find the server you want, and delete the <code>#</code> at the begining of that line to uncomment it.</p>
</blockquote>
<p>For an easy copy, here are some mirrors in China:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">### China</span><br><span class="line">## Aliyun</span><br><span class="line"># Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br><span class="line">## Netease</span><br><span class="line"># Server = https://mirrors.163.com/archlinux/$repo/os/$arch</span><br><span class="line">## Tsinghua</span><br><span class="line"># Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">## NJU</span><br><span class="line"># Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">## NJUPT</span><br><span class="line"># Server = https://mirrors.njupt.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></tbody></table></figure>

<h3 id="pacman-Upgrading-packages"><a href="#pacman-Upgrading-packages" class="headerlink" title="pacman - Upgrading packages"></a>pacman - Upgrading packages</h3><p>Run the command below to upgrade packages.</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></tbody></table></figure>

<p>You are recommended to immediately run this command after changing to a mirror.</p>
<h3 id="pacman-Querying-package-s"><a href="#pacman-Querying-package-s" class="headerlink" title="pacman - Querying package(s)"></a>pacman - Querying package(s)</h3><p>To find the package you need in the sync database:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pacman -Ss &lt;package_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>The “s” in the small case means “search”.</p>
<p>To list the packages installed:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pacman -Qq  // list all the packages, ignore version (-q)</span><br><span class="line">pacman -Qqe // list explicitly installed packages (-e)</span><br><span class="line">pacman -Qqd // list the packages installed as dependencies (-d)</span><br><span class="line">pacman -Qqdt // list the packages <span class="built_in">which</span> are no longer dependencies (-t), usually can be removed</span><br></pre></td></tr></tbody></table></figure>

<h3 id="pacman-Installing-package-s"><a href="#pacman-Installing-package-s" class="headerlink" title="pacman - Installing package(s)"></a>pacman - Installing package(s)</h3><p>This command helps install one or more packages.</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo pacman -S &lt;package_name1&gt; &lt;package_name2&gt; ...</span><br></pre></td></tr></tbody></table></figure>

<p>For example, to install <em>bat</em>, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo pacman -S bat</span><br></pre></td></tr></tbody></table></figure>

<h3 id="pacman-Removing-package-s"><a href="#pacman-Removing-package-s" class="headerlink" title="pacman - Removing package(s)"></a>pacman - Removing package(s)</h3><p>This command helps remove a single package, leaving all of its dependencies installed:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo pacman -R &lt;package_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To remove a package and its dependencies that are not required by any other installed package:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo pacman -Rs &lt;package_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>Here I found a helpful article that provides more information: <a href="https://www.cnblogs.com/sztom/p/10652624.html">《Arch Linux 软件包的查询及清理》</a>.</p>
<h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>The APT(Advanced Packaging Tools) is(Maybe “are”? Since it’s “tools”?) widely used in Debian and Ubuntu etc. It mainly includes <code>apt-get</code> ,<code>apt-cache</code> and <code>apt-file</code>.</p>
<h3 id="APT-Changing-to-mirror"><a href="#APT-Changing-to-mirror" class="headerlink" title="APT - Changing to mirror"></a>APT - Changing to mirror</h3><p>Take Tsinghua’s mirror as an example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">## Tsinghua</span><br><span class="line">## from https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu</span><br><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></pre></td></tr></tbody></table></figure>

<h3 id="APT-Useful-commands"><a href="#APT-Useful-commands" class="headerlink" title="APT - Useful commands"></a>APT - Useful commands</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt update // update the package info </span><br><span class="line">sudo apt upgrade // upgrade all the packages installed</span><br><span class="line">apt list --upgradeable // list all the packages that can upgrade</span><br><span class="line"></span><br><span class="line">sudo apt install &lt;package_name&gt; // install a specific package</span><br><span class="line">sudo apt install -f // fix the dependencies</span><br><span class="line"></span><br><span class="line">sudo apt remove &lt;package_name&gt; // remove a specific package</span><br><span class="line">sudo apt autoremove // auto remove the packages that no longer needed</span><br><span class="line"></span><br><span class="line">apt show &lt;package_name&gt; // show the info about a specific package</span><br></pre></td></tr></tbody></table></figure>

<h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Package manager</tag>
        <tag>ArchLinux</tag>
        <tag>Ubuntu</tag>
        <tag>pacman</tag>
        <tag>APT</tag>
      </tags>
  </entry>
  <entry>
    <title>Replace cat with bat</title>
    <url>/posts/e7bc2e88.html</url>
    <content><![CDATA[<p>When using Linux, I often use <code>cat</code> to browse some short codes. But it doesn’t support syntax highlighting originally. So, I found one of its replacements: <code>bat</code>.</p>
<span id="more"></span>

<h2 id="Brief-introduction"><a href="#Brief-introduction" class="headerlink" title="Brief introduction"></a>Brief introduction</h2><p><a href="https://github.com/sharkdp/bat"><img data-src="https://github.com/sharkdp/bat/raw/master/doc/logo-header.svg" alt="BAT Logo"></a></p>
<p>On <a href="https://github.com/sharkdp/bat">BAT</a>‘s official GitHub page, it defines itself “a cat clone with wings”. In my opinion, one is “syntax highlighting”, and the other is “git integration”.</p>
<p>Here are some of its important features:</p>
<ul>
<li>Syntax highlighting</li>
<li>Git integration</li>
<li>Show non-printable characters</li>
<li>Automatic paging</li>
</ul>
<p><img data-src="https://camo.githubusercontent.com/7b7c397acc5b91b4c4cf7756015185fe3c5f700f70d256a212de51294a0cf673/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67" alt="BAT's syntax highlighting"></p>
<p><img data-src="https://camo.githubusercontent.com/c436c206f2c86605ab2f9fb632dd485afc05fccbf14af472770b0c59d876c9cc/68747470733a2f2f692e696d6775722e636f6d2f326c53573452452e706e67" alt="BAT's git integration"></p>
<p><img data-src="https://camo.githubusercontent.com/643244c46834769e0ea2802e15518c49e0c7cf10aa82d00c7c69a406f2aa161d/68747470733a2f2f692e696d6775722e636f6d2f576e64477039482e706e67" alt="BAT's non-printable characters showing"></p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>In ArchLinux, you can run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo pacman -S bat</span><br></pre></td></tr></tbody></table></figure>

<p>In Termux, you can run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pkg install bat</span><br></pre></td></tr></tbody></table></figure>

<p>In Ubuntu, you can run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install bat</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <a href="https://github.com/sharkdp/bat">BAT</a>‘s GitHub page.</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Display a single file:</span></span><br><span class="line">bat &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display multi files at once:</span></span><br><span class="line">bat &lt;filename1&gt; &lt;filename2&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show and highlight non-printable characters:</span></span><br><span class="line">bat -A &lt;filename&gt; <span class="comment"># or</span></span><br><span class="line">bat --show-all &lt;filename&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <a href="https://github.com/sharkdp/bat">BAT</a>‘s GitHub page.</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>You can use BAT’s configuration file to customize your BAT.</p>
<p>To generate a default config file, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">bat --generate-config-file</span><br></pre></td></tr></tbody></table></figure>

<p>Here is an example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Set the theme</span><br><span class="line">--theme="Dracula"</span><br><span class="line"></span><br><span class="line"># Use C++ syntax for Arduino .ino files</span><br><span class="line">--map-syntax "*.ino:C++"</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>cat</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>Simple Git tutorial</title>
    <url>/posts/9363e311.html</url>
    <content><![CDATA[<p>This is a simple tutorial of Git, also including some info about GitHub.</p>
<span id="more"></span>

<h2 id="BRIEF"><a href="#BRIEF" class="headerlink" title="BRIEF"></a>BRIEF</h2><p>You may have learnt Git and GitHub before, and also may have confused them because their similar names. What are these two things on earth?</p>
<p><img data-src="https://software.3metas.com/wp-content/uploads/2017/06/git.png" alt="Git (This picture is from the Internet)"></p>
<p><img data-src="https://kinsta.com/wp-content/uploads/2018/04/what-is-github-1-1.png" alt="GitHub (This picture is from the Internet)"></p>
<p>In short, <a href="https://git-scm.com/">Git</a> is a version control system (VCS), which enables you to create a repository of your codes, to track changes in your project and to manage your files efficiently. <a href="https://github.com/">GitHub</a> is a platform used to host remote Git repositories for collaboration and sharing projects.</p>
<p>In this post, you will learn the basic usage of Git and GitHub.</p>
<h2 id="CREATING-A-GITHUB-ACCOUNT"><a href="#CREATING-A-GITHUB-ACCOUNT" class="headerlink" title="CREATING A GITHUB ACCOUNT"></a>CREATING A GITHUB ACCOUNT</h2><p>See <em><a href="https://docs.github.com/en/get-started/signing-up-for-GitHub/signing-up-for-a-new-GitHub-accountt">Signing up for a new GitHub account - GitHub Docs</a></em></p>
<h2 id="DOWNLOADING-AND-INSTALLING-GIT"><a href="#DOWNLOADING-AND-INSTALLING-GIT" class="headerlink" title="DOWNLOADING AND INSTALLING GIT"></a>DOWNLOADING AND INSTALLING GIT</h2><p>Many operations in Git run locally. Before using Git, you need to install it in your local environment.</p>
<p>Download Git from the official website:</p>
<p><em><a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></em></p>
<h2 id="CONFIGURING"><a href="#CONFIGURING" class="headerlink" title="CONFIGURING"></a>CONFIGURING</h2><p>To configure user info for all local repositories:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"&lt;your_name&gt;"</span></span><br><span class="line">$ git config --global user.email <span class="string">"&lt;your_email@example.com&gt;"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="GETTING-HELP"><a href="#GETTING-HELP" class="headerlink" title="GETTING HELP"></a>GETTING HELP</h2><p>To get help when using Git, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ git &lt;verb&gt; --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="GETTING-A-GIT-REPOSITORY"><a href="#GETTING-A-GIT-REPOSITORY" class="headerlink" title="GETTING A GIT REPOSITORY"></a>GETTING A GIT REPOSITORY</h2><h3 id="CREATING-ONE-IN-AN-EXISTING-DIRECTORY"><a href="#CREATING-ONE-IN-AN-EXISTING-DIRECTORY" class="headerlink" title="CREATING ONE IN AN EXISTING DIRECTORY"></a>CREATING ONE IN AN EXISTING DIRECTORY</h3><p>To create a new Git repo in the current directory, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></tbody></table></figure>

<p>This command will create a directory called <code>.git</code>.</p>
<h3 id="CLONING-ONE-FROM-AN-EXISTING-REPO"><a href="#CLONING-ONE-FROM-AN-EXISTING-REPO" class="headerlink" title="CLONING ONE FROM AN EXISTING REPO"></a>CLONING ONE FROM AN EXISTING REPO</h3><p>To clone an existing repo from a remote server. Run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;url&gt; &lt;local_directory_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>&lt;url&gt;</code> can be <code>https://</code>, <code>git://</code> and <code>user@server:path/to/repo.git</code> etc.</li>
<li><code>&lt;local_directory_name&gt;</code> is optional.</li>
</ul>
<p>If you want to specify a branch when cloning, you can use <code>-b</code> option:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b &lt;branch&gt; &lt;url&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="TRACKING-FILES"><a href="#TRACKING-FILES" class="headerlink" title="TRACKING FILES"></a>TRACKING FILES</h2><p>To add file(s) to your tracked list, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add &lt;directory&gt;/&lt;file&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>This command tells Git to track the file(s) you specified and put them onto the stage. If you mistakenly tracked wrong file(s) (like a lot of log files), run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> &lt;file&gt;     <span class="comment"># only if these file are newly added</span></span><br><span class="line">$ git <span class="built_in">rm</span> -f &lt;file&gt;  <span class="comment"># to the files in the stage before, -f(force) option is needed</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>git rm</code> command will not only stop tracking the files you specified, but also remove them. If you only want to stop tracking them, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> --cached &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure>

<div class="note "><p>There is another command very similar to <code>git rm --cached &lt;file&gt;</code>: <code>git reset HEAD &lt;file&gt;</code>. Both of them will remove the file from the stage. But the former one will also remove the file from the tracked list (stop tracking it), while the latter will keep the file there.</p>
</div>

<div class="note danger no-icon"><p><code>git reset</code> is a dangerous command, especially when a <code>--hard</code> flag is added.</p>
</div>

<h2 id="CHECKING-THE-STATUS"><a href="#CHECKING-THE-STATUS" class="headerlink" title="CHECKING THE STATUS"></a>CHECKING THE STATUS</h2><p>To check the status of the files in the repo, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># a short version</span></span><br><span class="line">$ git status -s</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ git status --short</span><br></pre></td></tr></tbody></table></figure>

<p>In the short version, there are two columns in the front of every line. The left column shows the status of the stage. The right column shows the status of the working area. The statuses are showed like this:</p>
<ul>
<li><code>??</code>: untracked file</li>
<li><code>A</code>: file newly added to the stage</li>
<li><code>M</code>: modified file</li>
</ul>
<p>To check the modifications in your files, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># to show the files haven't been staged</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># to show the files have been staged</span></span><br><span class="line">$ git diff --staged</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ git diff --cached</span><br></pre></td></tr></tbody></table></figure>

<h2 id="COMMITTING"><a href="#COMMITTING" class="headerlink" title="COMMITTING"></a>COMMITTING</h2><p>To commit your files, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></tbody></table></figure>

<p>This command will open a editor. You need to edit your commit message here.</p>
<p>Or, you can simplify this by using <code>-m</code> option:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m &lt;commit_message&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><em>Oops, I forgot to add this file!</em> If you meet this issue, you can amend it like this:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"a wrong commit message"</span></span><br><span class="line">$ git add &lt;forgotten_file&gt;</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></tbody></table></figure>

<p>The second commit will <strong>replace</strong> the first commit, as if the first commit never occurred.</p>
<p>If you are tired of using the stage (<code>git add</code> first,<code>git commit</code> later), you can use <code>-a</code> flag like this to skip it:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -a</span><br></pre></td></tr></tbody></table></figure>

<p>This command is equivalent to these two command bellow:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add &lt;all_tracked_files_that_have_been_modified&gt;</span><br><span class="line">$ git commit</span><br></pre></td></tr></tbody></table></figure>

<h2 id="HISTORY"><a href="#HISTORY" class="headerlink" title="HISTORY"></a>HISTORY</h2><p>To review the commit history, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>-p</code> or <code>--patch</code> flag make logs output in the patch way.</p>
</li>
<li><p><code>-&lt;n&gt;</code> flag to limit the number of logs (e.g. <code>-2</code> only show two latest logs).</p>
</li>
<li><p><code>--stat</code> flag shows simple statistics.</p>
</li>
<li><p><code>--pretty</code> option provides some different ways to show the history.</p>
<ul>
<li><code>--pretty=oneline</code> option make every commit be showed in one line</li>
<li><code>--pretty=short</code></li>
<li><code>--pretty=full</code></li>
<li><code>--pretty=fuller</code></li>
</ul>
</li>
<li><p><code>--graph</code> flag adds some ascii characters to vividly show your history.</p>
</li>
</ul>
<h2 id="UNDO"><a href="#UNDO" class="headerlink" title="UNDO"></a>UNDO</h2><p>To discard changes in working, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>This command will abandon the modifications to the file after your last commit.</p>
<div class="note danger no-icon"><p>This is a DANGEROUS command. In Git, it’s usually easy to restore the files have been committed, but usually very hard to restore the files haven’t been committed.</p>
</div>

<h2 id="REMOTE"><a href="#REMOTE" class="headerlink" title="REMOTE"></a>REMOTE</h2><p>To connect your local repo to the remote server, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote add &lt;server_name&gt; &lt;server&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><code>server_name</code> is a short name of your server. Usually we use <code>origin</code>.</p>
<p>To show all the names, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></tbody></table></figure>

<p>To fetch the files in the remote repo, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git fetch &lt;server_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<div class="note "><p>There is a magic called <code>git pull</code>. Usually, it means <code>git fetch</code> and <code>git merge</code>.</p>
</div>

<p>To push your local changes to your remote repo, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git push &lt;server_name&gt; &lt;remote_branch&gt;</span><br><span class="line">$ git push &lt;server_name&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To make the local branch track the remote branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git push -u &lt;server_name&gt; &lt;remote_branch&gt;</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ git push --set-upstream &lt;server_name&gt; &lt;remote_branch&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To check your remote repo, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote show &lt;server_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To rename your remote repo, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote rename &lt;old_server_name&gt; &lt;new_server_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To remove a remote repo, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote remove &lt;server_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<div class="note "><p>It’s recommended to connect to GitHub with SSH. You can do it like this:</p>
<p>Open your Git bash, and run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-keygen -t ed25519 -C <span class="string">"&lt;your_email@example.com&gt;"</span>      <span class="comment"># for newer system</span></span><br><span class="line">                                                           <span class="comment"># or</span></span><br><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">"&lt;your_email@example.com&gt;"</span>  <span class="comment"># for older system</span></span><br></pre></td></tr></tbody></table></figure>

<p>Go to <a href="https://github.com/settings/profile">Your profile on GitHub</a>. Click <code>SSH and GPG keys</code> on the left. Click <code>New SSH key</code>. Choose a title, and paste all content in <code>~/.ssh/id_ed25519.pub</code>. Then click <code>Add SSH key</code>.</p>
<p>Simply explaining what we’ve done. <code>ssh-keygen</code> is a tool that help us create a key(<code>~/.ssh/id_ed25519</code>) and a lock(<code>~/.ssh/id_ed25519.pub</code>). Then, we use the <code>id_ed25519.pub</code> file to lock our repos on GitHub, and leave the <code>id_ed25519</code>, the key, in our PC. We can then avoid repeating login GitHub using password.</p>
<p>Learn more on <em><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">Connecting to GitHub with SSH - GitHub Docs</a></em>.</p>
</div>

<h2 id="BRANCH"><a href="#BRANCH" class="headerlink" title="BRANCH"></a>BRANCH</h2><p>To list all the local branches, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></tbody></table></figure>

<p>To list all the local and the remote branches, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></tbody></table></figure>

<p>To show the last commits of every branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -v</span><br></pre></td></tr></tbody></table></figure>

<p>The local branch is called the <strong>tracking branch</strong>. The corresponding branch on the remote server is called the  <strong>upstream branch</strong>.</p>
<p>To track a remote branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout --track &lt;server_name&gt;/&lt;branch&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>It is equivalent to:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">$ git branch -u &lt;server_name&gt;/&lt;branch&gt;</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ git branch --set-upstream &lt;server_name&gt;/&lt;branch&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To stop tracking, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch --unset-upstream &lt;branch&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To show the correspondence, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br></pre></td></tr></tbody></table></figure>


<p>To create a new local branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch &lt;branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To checkout to another local branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout &lt;branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>You can create a new local branch and check out to it with one command:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To rename a local branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -m &lt;new_branch_name&gt;</span><br><span class="line">$ git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To delete a local branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -d &lt;branch_name&gt;</span><br><span class="line">$ git branch -D &lt;branch_name&gt;  <span class="comment"># force</span></span><br></pre></td></tr></tbody></table></figure>

<p>To delete a remote branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin --delete &lt;branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<div class="note "><p>There are no direct commands to create a new remote repo or rename a remote repo. But you can rename a remote repo like this:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git pull origin &lt;old_branch_name&gt;</span><br><span class="line">$ git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</span><br><span class="line">$ git push -u origin &lt;new_branch_name&gt;</span><br><span class="line">$ git push origin --delete &lt;old_branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>
</div>

<p>To merge the other branch to this one, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git merge &lt;branch_name&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>If your current branch is <code>master</code>, this command merge <code>&lt;branch_name&gt;</code> to <code>master</code>.</p>
<p>To show all the branches that have/haven’t been merged to this branch, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">$ git branch --no-merged</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Learn-more"><a href="#Learn-more" class="headerlink" title="Learn more"></a>Learn more</h2><p><em><a href="https://missing.csail.mit.edu/2020/version-control/">MIT - Missing Semester - Version Control (Git)</a></em></p>
<p><em><a href="https://git-scm.com/book/en/v2">Pro Git</a></em></p>
<p><em><a href="http://rogerdudler.github.io/git-guide/index.html">git - the simple guide - no deep shit!</a></em></p>
<p><em><a href="https://training.github.com/">GitHub Training Kit</a></em></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Version control</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>The chmod command in Linux</title>
    <url>/posts/a9dc5c1e.html</url>
    <content><![CDATA[<p>I accidentally ran a wrong <code>chmod</code> command in my Linux, and it messed up everything! I hate the permission management in Linux. :|</p>
<span id="more"></span>

<h2 id="PERMISSION-MANAGEMENT-IN-LINUX"><a href="#PERMISSION-MANAGEMENT-IN-LINUX" class="headerlink" title="PERMISSION MANAGEMENT IN LINUX"></a>PERMISSION MANAGEMENT IN LINUX</h2><p>When you run <code>ls -l</code> in your terminal, you can always see strings like <code>-rw-r–r–</code> and <code>drwxr-xr-x</code> etc. To understand them, we can always split a such string into four part. The first one is a single character, <code>-</code> if it’s a file and <code>d</code> if it’s a directory. The rest 9 characters can be equally divided into three parts, representing the permission of the owner, the members of the group and other users relatively. Every part contains three characters, showing the permission of <strong>r</strong>(read), <strong>w</strong>(write) and <strong>x</strong>(execute).</p>
<p><img data-src="https://s1.ax1x.com/2023/03/23/pp0Z5YF.png" alt="When you run `ls -l`"><br><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="From www.runoob.com"></p>
<p>Besides the bit pattern, you can also use octal notation to express these permissions, which uses 4 for <strong>r</strong>, 2 for <strong>w</strong> and 1 for <strong>x</strong>. The sum of these octal numbers then can replace the <code>rwx</code> pattern. For example, using 6 for <strong>rw</strong>.</p>
<p>Why is 4, 2 and 1? Actually, you can view every 3-character unit as 3 binary bits. So, 100(r–) means 4 in decimal, 010(-w-) means 2, and 001(–x) means 1. You can then understand what dose the sum means.</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png" alt="From www.runoob.com"></p>
<p>Now, you can read this:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">-rw------- <span class="comment"># (600) Owner:RW</span></span><br><span class="line">-rw-r--r-- <span class="comment"># (644) Owner:RW Group:R Other:R</span></span><br><span class="line">-rw-rw-rw- <span class="comment"># (666) Owner:RW Group:RW Other:RW</span></span><br><span class="line">-rwx------ <span class="comment"># (700) Owner:RWX</span></span><br><span class="line">-rwx--x--x <span class="comment"># (711) Owner:RWX Group:X Other:X</span></span><br><span class="line">-rwxr-xr-x <span class="comment"># (755) Owner:RWX Group:RX Other:RX</span></span><br><span class="line">-rwxrwxrwx <span class="comment"># (777) Owner:RWX Group:RWX Other:RWX</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="DEFAULT-PERMISSION"><a href="#DEFAULT-PERMISSION" class="headerlink" title="DEFAULT PERMISSION"></a>DEFAULT PERMISSION</h2><p>The default permission for a file is 666, which means <code>-rw-rw-rw-</code>, indicating that the owner, group and other users can read and write the file. The default permission for a directory is 777, which means <code>drwxrwxrwx</code>, indicating that the owner, group and other users can read, write and access the directory.</p>
<p>However, these default permissions are affected by the user’s <strong>umask</strong> setting. The umask is a value that controls which permissions are removed when creating a new file or directory. For example, if the user’s umask is 022, then the write permission for group and other users will be removed when creating a new file, and the write and execute permission for group and other users will be removed when creating a new directory. Therefore:</p>
<p>The actual default permission for a file is 666 - 022 = 644, which means <code>-rw-r–r–</code>. The actual default permission for a directory is 777 - 022 = 755, which means <code>drwxr-xr-x</code>.</p>
<p>You can run the <code>umask</code> command to see what your setting is.</p>
<p><img data-src="https://s1.ax1x.com/2023/03/23/pp0eZtS.png"></p>
<h2 id="THE-CHMOD-COMMAND"><a href="#THE-CHMOD-COMMAND" class="headerlink" title="THE CHMOD COMMAND"></a>THE CHMOD COMMAND</h2><p><img data-src="https://s1.ax1x.com/2023/03/23/pp0mVD1.png"></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-cfvR] [--<span class="built_in">help</span>] [--version] &lt;mode&gt; &lt;file&gt;...</span><br></pre></td></tr></tbody></table></figure>

<p>The <code>-R</code> means recursively. You will need it.</p>
<p>The most important part is <code>&lt;mode&gt;</code> obviously. Its pattern is:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>[ugoa…]: <code>u</code> means user, <code>g</code> means group, <code>o</code> means other, and <code>a</code> means all.</li>
<li>[+-=]: <code>+</code> means adding permission, <code>-</code> means removing, and <code>=</code> means setting the permissions for a specific user type, <strong>regardless of the previous permissions</strong>.</li>
<li>[rwxX]: You have known <code>rwx</code>, and the <code>X</code> means setting the execute permission only if the file is a directory or already has execute permission for some user.</li>
</ol>
<p>For example:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x &lt;file&gt; <span class="comment"># adding execute permission to the owner of the file, and leaving the group and other permissions unchanged</span></span><br><span class="line"><span class="built_in">chmod</span> o-rwx &lt;file&gt; <span class="comment"># removing all permissions from others, and leaving the owner and group permissions unchanged</span></span><br><span class="line"><span class="built_in">chmod</span> a=r &lt;file&gt; <span class="comment"># setting all user types’ permissions to read only, overwriting any previous permissions</span></span><br><span class="line"><span class="built_in">chmod</span> a+X &lt;file&gt; <span class="comment"># adding execute permission to all user types only if file is a directory or already executable by some user</span></span><br></pre></td></tr></tbody></table></figure>

<p>You can also use octal pattern represents the <code>&lt;mode&gt;</code>. For example:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 &lt;file&gt; <span class="comment"># now everyone can read, write and execute the &lt;file&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="CHANGE-PERMISSIONS-TO-FILE-OR-DIR-INDIVIDUALLY"><a href="#CHANGE-PERMISSIONS-TO-FILE-OR-DIR-INDIVIDUALLY" class="headerlink" title="CHANGE PERMISSIONS TO FILE OR DIR INDIVIDUALLY"></a>CHANGE PERMISSIONS TO FILE OR DIR INDIVIDUALLY</h2><p>To change permissions to file or dir individually, you can use the <code>-exec</code> option of <code>find</code> to execute chmod on each matching file or directory. For example: To find all files in the current directory and its subdirectories and change their permissions to 644, you can use: <code>find . -type f -exec chmod 644 {} ;</code></p>
<p><code>-type f</code> means file. You can use <code>-type d</code> to find all the dir.</p>
<h2 id="THANKS"><a href="#THANKS" class="headerlink" title="THANKS"></a>THANKS</h2><p>By the way, this blog was completed with the help of new bing. I asked her many questions and got great answers. She also helped me correct errors and polish my writing. She is just too amazing!</p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><ul>
<li><a href="https://www.runoob.com/linux/linux-comm-chmod.html">《Linux chmod 命令 | 菜鸟教程》</a></li>
<li><a href="https://blog.csdn.net/u013197629/article/details/73608613">《Linux 权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）》</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>chmod</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code 中文乱码问题</title>
    <url>/posts/ca05bed5.html</url>
    <content><![CDATA[<p><strong>2023 年 1 月 12 日更新：</strong> 找到了方便地改变 Windows 中终端默认编码的方法，所以原来的改变 C/C++ 文件默认编码的方法可以淘汰了。</p>
<span id="more"></span>

<p>现在的新办法是：</p>
<p>打开 “控制面板 - 时钟和区域 - 区域 - 管理 - 更改系统区域设置 (C)…”</p>
<p>勾选 “Beta 版：使用 Unicode UTF-8 提供全球语言支持 (U)”</p>
<p>确定，重启电脑。</p>
<p>打开 CMD 测试一下，输入 <code>chcp</code> 可以发现已经变成了 <code>65001</code>，说明成功了。</p>
<p>方法来源：<a href="https://blog.csdn.net/weixin_44285445/article/details/112325994">《Git Bash 中文显示乱码，options 修改为 zh_CN 和 utf-8 还是不行怎么办？》</a></p>
<div class="note danger no-icon"><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>该方法全局更改 Windows 系统的默认编码，可能引起某些软件运行异常。</p>
</div>

<p><strong>以下是原来的文章</strong></p>
<p>开门见山，我最后采用的解决方案是对 C/C++ 文件单独设置默认编码。大致的操作方法是，打开 VS Code 的 <code>settings.json</code> 文件，添加如下配置：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">"[cpp]"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"files.encoding"</span><span class="punctuation">:</span> <span class="string">"gbk"</span></span><br><span class="line"><span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">"[c]"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"files.encoding"</span><span class="punctuation">:</span> <span class="string">"gbk"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>具体的操作请参见原文：<a href="https://blog.csdn.net/qq_45538473/article/details/107258234">《VSCODE C 语言终端输出中文乱码编码设置》</a></p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>复盘一下解决这个问题的过程。</p>
<p>首先了解到的是 VS Code 中文乱码的根本原因 ——VS Code 默认的编码格式是 UTF-8 （这一点可在 VS Code 右下角看到），而 VS Code 调用的终端是 CMD，默认的编码格式是 gbk。所以解决方案就是两个方向：要么是更改终端的默认编码，从默认的 gbk 转为 utf8；要么就是更改 VS Code 中的 C/C++ 文件的编码。</p>
<p><strong>2022/10/26 更新：</strong></p>
<p>看到一个有意思的科普视频，贴在这里，可以看看乱码到底是如何产生的。</p>
<p><a href="https://www.bilibili.com/video/BV1cB4y177QR/">锟斤拷 �⊠ 是怎样炼成的 —— 中文显示 “⼊” 门指南【柴知道】</a></p>
<h3 id="第一个方向：更改终端默认编码"><a href="#第一个方向：更改终端默认编码" class="headerlink" title="第一个方向：更改终端默认编码"></a>第一个方向：更改终端默认编码</h3><p>了解到更改 CMD 编码为 utf8 的命令如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></tbody></table></figure>

<p>顺便一提，查看当前编码的命令为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">chcp</span><br></pre></td></tr></tbody></table></figure>

<p><code>chcp 65001</code> 这串命令的意思就是更改代码页为 65001，也就是用 utf8 编码。</p>
<p>这串命令不是永久生效的，所以每次都要输入，比较麻烦。网上也有一些解决方案，比如通过修改注册表每次都自动运行一下上边的命令（<a href="https://www.jianshu.com/p/f40e494dc01d">《修改 Windows10 命令终端 cmd 的编码为 UTF-8》</a>），或者是配置 VS Code 让其自动输入的（<a href="https://blog.csdn.net/lzyws739307453/article/details/89823900">《永久解决 VS Code 终端中文乱码问题》</a>），可以去看看。</p>
<h3 id="第二个方向：更改-VS-Code-中的-C-C-文件的编码"><a href="#第二个方向：更改-VS-Code-中的-C-C-文件的编码" class="headerlink" title="第二个方向：更改 VS Code 中的 C/C++ 文件的编码"></a>第二个方向：更改 VS Code 中的 C/C++ 文件的编码</h3><p>最初这个方法我只是想临时解决一下，就比较简单。点一下右下角的 UTF-8，选择 <code>通过编码重新打开</code>，选择 gbk 就行了。但这样只有一次，然后就想看看有没有永久的方法，便看到了上边的文章。</p>
<p>顺便一提，这里可能还要把 VS Code 设置中的自动猜测编码功能打开，具体操作如下：</p>
<ol>
<li>使用 <code>Ctrl + ,</code> 快捷键打开设置；</li>
<li>在搜索框输入 <code>encoding</code> ，找到 <code>Files:Auto Guess Encoding</code>，勾上它。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/qq_45538473/article/details/107258234">《VSCODE C 语言终端输出中文乱码编码设置》</a></li>
<li><a href="https://www.jianshu.com/p/f40e494dc01d">《修改 Windows10 命令终端 cmd 的编码为 UTF-8》</a></li>
<li><a href="https://blog.csdn.net/lzyws739307453/article/details/89823900">《永久解决 VS Code 终端中文乱码问题》</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code 中设置显示最大列数边界线</title>
    <url>/posts/bb929dc9.html</url>
    <content><![CDATA[<p>很多时候我们会避免一行代码过长，常见的限制有 80 字符、120 个字符等。我希望能在 VS Code 中显示一条边界线来提醒我已经到达这个限制了，需要换行。下边是设置的方法。</p>
<span id="more"></span>

<p>打开设置（快捷键 <code>Ctrl+,</code>），搜索 <code>Editor: Rulers</code>，点击 “在 settings.json” 中编辑，添加如下内容：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">"editor.rulers"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">80</span><span class="punctuation">,</span><span class="number">120</span><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure>

<p>当然你也可以按照自己的喜好设置字符数。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code 的安装与配置基础 C/C++ 开发环境</title>
    <url>/posts/a7a0ce82.html</url>
    <content><![CDATA[<p>我以前学习 C++ 的时候，使用的是 DevCpp 。这个软件让我这个初学者比较舒服的点是，我不用太过详细地考虑编译的过程 —— 新建一个 cpp 文件，写一点小程序，按下 F11，程序运行。我不需要管选择编译器啊、配置编译命令啊啥啥的。但是到 VS Code 这边，这都要我自己做了，对于新手并不是那么友好。这里记录一下我配置 VS Code 的 C/C++ 环境的完整过程，希望对你有所帮助。需要注意的是：学习一下基本的编译链接指令还是很有必要的！</p>
<span id="more"></span>

<h2 id="安装-Visual-Studio-Code"><a href="#安装-Visual-Studio-Code" class="headerlink" title="安装 Visual Studio Code"></a>安装 Visual Studio Code</h2><p>打开 <a href="https://code.visualstudio.com/">VS Code 官网</a>，点击 <code>Download for Windows</code> 按钮（其他平台请选择对应平台的安装包，此处以 Windows 平台为例），等待下载完成。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSRlss.png"></p>
<div class="note "><h4 id="国内-VS-Code-下载速度慢的解决方案"><a href="#国内-VS-Code-下载速度慢的解决方案" class="headerlink" title="国内 VS Code 下载速度慢的解决方案"></a>国内 VS Code 下载速度慢的解决方案</h4><p>此方法来自：<a href="https://zhuanlan.zhihu.com/p/112215618">https://zhuanlan.zhihu.com/p/112215618</a></p>
<p>在你的下载软件处（我这里是 IDM，你如果是浏览器下载的就去浏览器的下载管理器里找），找到下载地址。将下载地址中的 <code>az764295.vo.msecnd.net</code> 替换为 <code>vscode.cdn.azure.cn</code>，然后取消原任务，用修改过的下载链接新建一个下载。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSR8Zq.png" alt="修改前"></p>
</div>

<p>打开安装包，一路下一步，直到下面这个界面，按照下边的进行选择，直到安装完毕。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSWzge.png"></p>
<h2 id="VS-Code-设置中文"><a href="#VS-Code-设置中文" class="headerlink" title="VS Code 设置中文"></a>VS Code 设置中文</h2><p>打开 VS Code，点击图示左侧第五个图标或使用快捷键 <code>Ctrl+Shift+X</code> 打开 <code>拓展</code> 页面，搜索：<code>Chinese</code>，找到 <code>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</code> 这个插件，点击 <code>Install</code> 安装，等待安装完成后按照提示点击右下角 <code>Restart</code> 按钮重启 VS Code。<br><img data-src="https://s1.ax1x.com/2022/09/17/xSf1U0.png"><br><img data-src="https://s1.ax1x.com/2022/09/17/xSfJ8U.png"><br><img data-src="https://s1.ax1x.com/2022/09/17/xSftv4.png"></p>
<h2 id="安装并检查编译器"><a href="#安装并检查编译器" class="headerlink" title="安装并检查编译器"></a>安装并检查编译器</h2><p>DevCpp 安装的时候也帮我们安装好了编译器，但 VS Code 并没有。所以我们还得自己装一个编译器。这里以 Mingw-w64 为例（参考<a href="https://code.visualstudio.com/docs/languages/cpp#_example-install-mingwx64">官方教程</a>）。</p>
<p>参考 <a href="https://www.msys2.org/#installation">MSYS2 官网</a>下载安装和安装。</p>
<div class="note "><h4 id="国内-MSYS2-下载速度慢的解决方案"><a href="#国内-MSYS2-下载速度慢的解决方案" class="headerlink" title="国内 MSYS2 下载速度慢的解决方案"></a>国内 MSYS2 下载速度慢的解决方案</h4><p>在这个按钮上右键，选择<code>复制链接</code>。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xShuRO.png"></p>
<p>然后前往 <a href="https://ghproxy.com/">https://ghproxy.com/</a> 这个网站，粘贴上面复制的下载链接，点击下载。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xShGdI.png"></p>
</div>

<p>打开安装包，一路默认下一步。耐心等待（国内网络可以！只要耐心等！）直到出现下面的界面：</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xShqfK.png"></p>
<p>输入下面的命令安装 gcc：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ pacman -S mingw-w64-x86_64-gcc</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://s1.ax1x.com/2022/09/17/xS46nH.png" alt="画横线的是需要自己输入的"></p>
<p>接下来需要添加环境变量。直接搜索 <code>高级系统设置</code>：</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xS4bHs.png"></p>
<p>打开后点击环境变量。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xS4x3T.png"></p>
<p>添加系统变量。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xS5VC6.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xS5J8f.png"></p>
<p>打开 CMD 检查一下是否成功：<br>输入 <code>gcc -v</code>，如果有结果，就安装成功了。</p>
<h2 id="C-C-扩展的安装"><a href="#C-C-扩展的安装" class="headerlink" title="C/C++ 扩展的安装"></a>C/C++ 扩展的安装</h2><p>按照上面的方法打开扩展，首先是几个 C/C++ 基础扩展，直接搜索 <code>C++</code>。</p>
<p>第一个：<code>C/C++</code></p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSfhVI.png"></p>
<p>直接点击安装（我这里截图的时候还没重启，如果按照上述步骤已经安装了中文语言包并重启了 Code，这里的 <code>Install</code> 按钮就会变成 <code>安装</code>）。</p>
<p>第二个：<code>C/C++ Extension Pack</code></p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSf7RS.png"></p>
<p>第三个：<code>C/C++ Compile Run</code></p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSfLrj.png"></p>
<p>这个扩展提供了极其简单的 <code>F6</code> 一键编译运行功能。</p>
<h2 id="正常运行测试"><a href="#正常运行测试" class="headerlink" title="正常运行测试"></a>正常运行测试</h2><p>新建一个文件夹，就叫 <code>HelloWorld</code> 吧。打开文件夹，右键，选择 <code>通过 Code 打开</code>。新建一个 <code>HelloWorld.cpp</code>，粘贴下面的代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Ctrl+S</code> 保存，<code>F6</code> 运行，成功输出结果。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xS5oPx.png"></p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><strong>2022 年 10 月 6 日更新：</strong></p>
<p>完成上边的步骤之后，你应该可以正常运行程序了。下面的教程是安装调试器以及通过 <code>C/C++ Runner</code> 让调试等工作变得简单。</p>
<p>首先再次打开 msys2.exe (默认位置是：C:\msys64\msys2.exe)，类似上边安装 gcc ，输入下边的命令安装 gdb。<br>类似的，还需要输入下面的命令安装 gdb:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ pacman -S mingw-w64-x86_64-gdb</span><br></pre></td></tr></tbody></table></figure>

<p>然后在 VS Code 中搜索并安装 <code>C/C++ Runner</code> 插件。</p>
<div class="note "><h4 id="安装-C-C-Runner-插件时其依赖项-CodeLLDB-无法安装的解决方案"><a href="#安装-C-C-Runner-插件时其依赖项-CodeLLDB-无法安装的解决方案" class="headerlink" title="安装 C/C++ Runner 插件时其依赖项 CodeLLDB 无法安装的解决方案"></a>安装 C/C++ Runner 插件时其依赖项 CodeLLDB 无法安装的解决方案</h4><p>按照右下角的提示手动下载 <code>codelldb-x86_64-windows.vsix</code> 文件。</p>
<p>在 VS Code 中按下 <code>Ctrl + Shift + P</code>，输入 <code>install</code>，选择<code>从VSIX安装...</code>，选择上边下好的文件，等待安装完成。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSTBad.png"></p>
</div>

<p>安装完成后，左下角点击 <code>Select folder.</code>，选择当前文件夹。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xSTRsS.png"></p>
<p>然后按下小齿轮进行编译，按下三角形运行，设置好断点按下小虫子进行 Debug。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/17/xST4aj.png"></p>
<h2 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h2><p><strong>2022 年 10 月 13 日更新：</strong></p>
<p>参见我的另一篇文章：<a href="https://blocklune.github.io/posts/ca05bed5.html">《VS Code 中文乱码问题》</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/112215618">国内下载 vscode 速度慢问题解决</a></li>
<li>官方教程：<a href="https://code.visualstudio.com/docs/languages/cpp">C++ programming with Visual Studio Code</a></li>
<li><a href="https://www.cnblogs.com/zychengzhiit1/p/5776962.html">windows 10 环境下 使用 msys2 + vs code 配置 c++ 的编译环境</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Installing Ubuntu</title>
    <url>/posts/ca281680.html</url>
    <content><![CDATA[<p>This is NOT a tutorial of installing Ubuntu. Just write down some issues I met during my installation.</p>
<span id="more"></span>

<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>It’s not recommended to login your ubuntu as <code>root</code>. To create a new user with the default home directory, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ useradd --create-home &lt;username&gt;</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ useradd -m &lt;username&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To add the new user to sudoers, run the command below as <code>root</code>:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># visudo</span></span><br></pre></td></tr></tbody></table></figure>

<div class="note "><p>You may install <code>sudo</code> first. Run the command below as <code>root</code>:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># apt install sudo</span></span><br></pre></td></tr></tbody></table></figure>
</div>

<h2 id="SOFTWARE"><a href="#SOFTWARE" class="headerlink" title="SOFTWARE"></a>SOFTWARE</h2><h3 id="PACKAGE-MANAGER"><a href="#PACKAGE-MANAGER" class="headerlink" title="PACKAGE MANAGER"></a>PACKAGE MANAGER</h3><p>The first thing you need to do is configuring <code>apt</code>‘s mirror.</p>
<p>If you also want to use the mirror from Tsinghua:</p>
<p>See <em><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></em></p>
<p>To update your <code>apt</code> repository, press <code>Ctrl + Alt + T</code> to run a terminal, and run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></tbody></table></figure>

<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>I often use fishshell as my default login shell. To install it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo apt install fish</span><br></pre></td></tr></tbody></table></figure>

<p>To set fishshell for the current user:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ chsh --shell &lt;path/to/fish&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>To find out where fishshell is, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> fish</span><br></pre></td></tr></tbody></table></figure>

<h3 id="APPSTORE"><a href="#APPSTORE" class="headerlink" title="APPSTORE"></a>APPSTORE</h3><p>This one is interesting. You may give it a try.</p>
<p><em><a href="https://gitee.com/deepin-community-store/spark-store">Spark-Store</a></em></p>
<h3 id="BROWSER"><a href="#BROWSER" class="headerlink" title="BROWSER"></a>BROWSER</h3><p>I use Microsoft Edge. It’s pretty easy to download the <code>.deb</code> on its <em><a href="https://www.microsoft.com/en-us/edge/download">official website</a></em>. But if you want to install it from command line:</p>
<p>See <em><a href="https://www.linuxcapable.com/how-to-install-microsoft-edge-on-ubuntu-linux/">How to Install Microsoft Edge on Ubuntu 22.04 | 20.04 - LinuxCapable</a></em></p>
<h3 id="PROXY"><a href="#PROXY" class="headerlink" title="PROXY"></a>PROXY</h3><p>Maybe <em><a href="https://github.com/zzzgydi/clash-verge">zzzgydi/clash-verge: A Clash GUI based on tauri. Supports Windows, macOS and Linux</a></em> or <em><a href="https://github.com/Fndroid/clash_for_windows_pkg">Fndroid/clash_for_windows_pkg</a></em></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: The operating system always freezes on the welcome page.<br>A: Install / Update NVIDIA driver.</p>
<p>See <em><a href="https://www.cnblogs.com/Leozi/p/13281224.html">Ubuntu 下安装 NVIDIA 驱动的三种方法</a></em></p>
<p>and <em><a href="https://superuser.com/questions/1750975/nouveau-00000100-0-drm-failed-to-idle-channel-0-drm">ubuntu - nouveau 0000:01:00.0: DRM: failed to idle channel 0 [DRM] - Super User</a></em></p>
<p>Q: Why the Microsoft Edge always show <em>This page is having a problem</em>?</p>
<p>A: See <em><a href="https://answers.microsoft.com/en-us/microsoftedge/forum/all/this-page-is-having-a-problem-error-code-sigill/e2a09ac0-f243-40cb-a235-41abb2148f07">This page is having a problem Error Code: SIGILL - Microsoft Community</a></em></p>
<p>and <a href="https://www.linuxcapable.com/how-to-install-microsoft-edge-on-ubuntu-linux/">here</a></p>
<p>Q: Why does the settings disappear?<br>A: Run <code>sudo apt install gnome-control-center</code> to (re)install gnome-control-center.</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>My &quot;.vimrc&quot;</title>
    <url>/posts/96f7ff9f.html</url>
    <content><![CDATA[<p>There are a huge amount of options in Vim. It enables us to customize our own Vim as our wishes.</p>
<span id="more"></span>

<h2 id="BRIEF"><a href="#BRIEF" class="headerlink" title="BRIEF"></a>BRIEF</h2><p>To see the complete option list, run:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:<span class="keyword">help</span> option-<span class="keyword">list</span></span><br></pre></td></tr></tbody></table></figure>

<p>To change an option only for this time, run:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="symbol">&lt;option&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>Add an <code>!</code> at the tail to reverse the option:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="symbol">&lt;option&gt;</span>!</span><br></pre></td></tr></tbody></table></figure>

<p>To see the current status of an option, add a <code>?</code>:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="symbol">&lt;option&gt;</span>?</span><br></pre></td></tr></tbody></table></figure>

<p>If you want to save your options, edit <code>~/.vimrc</code>.</p>
<h2 id="GETTING-STARTED"><a href="#GETTING-STARTED" class="headerlink" title="GETTING STARTED"></a>GETTING STARTED</h2><p>Here is an example <code>.vimrc</code> provided by MIT:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">" Comments in Vimscript start with a `"</span>`.</span><br><span class="line"></span><br><span class="line"><span class="comment">" If you open this file in Vim, it'll be syntax highlighted for you.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Vim is based on Vi. Setting `nocompatible` switches from the default</span></span><br><span class="line"><span class="comment">" Vi-compatibility mode and enables useful Vim functionality. This</span></span><br><span class="line"><span class="comment">" configuration option turns out not to be necessary for the file named</span></span><br><span class="line"><span class="comment">" '~/.vimrc', because Vim automatically enters nocompatible mode if that file</span></span><br><span class="line"><span class="comment">" is present. But we're including it here just in case this config file is</span></span><br><span class="line"><span class="comment">" loaded some other way (e.g. saved as `foo`, and then Vim started with</span></span><br><span class="line"><span class="comment">" `vim -u foo`).</span></span><br><span class="line"><span class="keyword">set</span> nocompatible</span><br><span class="line"></span><br><span class="line"><span class="comment">" Turn on syntax highlighting.</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Disable the default Vim startup message.</span></span><br><span class="line"><span class="keyword">set</span> shortmess+=I</span><br><span class="line"></span><br><span class="line"><span class="comment">" Show line numbers.</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" This enables relative line numbering mode. With both number and</span></span><br><span class="line"><span class="comment">" relativenumber enabled, the current line shows the true line number, while</span></span><br><span class="line"><span class="comment">" all other lines (above and below) are numbered relative to the current line.</span></span><br><span class="line"><span class="comment">" This is useful because you can tell, at a glance, what count is needed to</span></span><br><span class="line"><span class="comment">" jump up or down to a particular line, by {count}k to go up or {count}j to go</span></span><br><span class="line"><span class="comment">" down.</span></span><br><span class="line"><span class="keyword">set</span> relativenumber</span><br><span class="line"></span><br><span class="line"><span class="comment">" Always show the status line at the bottom, even if you only have one window open.</span></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" The backspace key has slightly unintuitive behavior by default. For example,</span></span><br><span class="line"><span class="comment">" by default, you can't backspace before the insertion point set with 'i'.</span></span><br><span class="line"><span class="comment">" This configuration makes backspace behave more reasonably, in that you can</span></span><br><span class="line"><span class="comment">" backspace over anything.</span></span><br><span class="line"><span class="keyword">set</span> backspace=<span class="built_in">indent</span>,eol,start</span><br><span class="line"></span><br><span class="line"><span class="comment">" By default, Vim doesn't let you hide a buffer (i.e. have a buffer that isn't</span></span><br><span class="line"><span class="string">" shown in any window) that has unsaved changes. This is to prevent you from "</span></span><br><span class="line"><span class="comment">" forgetting about unsaved changes and then quitting e.g. via `:qa!`. We find</span></span><br><span class="line"><span class="comment">" hidden buffers helpful enough to disable this protection. See `:help hidden`</span></span><br><span class="line"><span class="comment">" for more information on this.</span></span><br><span class="line"><span class="keyword">set</span> hidden</span><br><span class="line"></span><br><span class="line"><span class="comment">" This setting makes search case-insensitive when all characters in the string</span></span><br><span class="line"><span class="comment">" being searched are lowercase. However, the search becomes case-sensitive if</span></span><br><span class="line"><span class="comment">" it contains any capital letters. This makes searching more convenient.</span></span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="keyword">set</span> smartcase</span><br><span class="line"></span><br><span class="line"><span class="comment">" Enable searching as you type, rather than waiting till you press enter.</span></span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"></span><br><span class="line"><span class="comment">" Unbind some useless/annoying default key bindings.</span></span><br><span class="line"><span class="keyword">nmap</span> Q <span class="symbol">&lt;Nop&gt;</span> <span class="comment">" 'Q' in normal mode enters Ex mode. You almost never want this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Disable audible bell because it's annoying.</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells visualbell t_vb=</span><br><span class="line"></span><br><span class="line"><span class="comment">" Enable mouse support. You should avoid relying on this too much, but it can</span></span><br><span class="line"><span class="comment">" sometimes be convenient.</span></span><br><span class="line"><span class="keyword">set</span> mouse+=<span class="keyword">a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Try to prevent bad habits like using the arrow keys for movement. This is</span></span><br><span class="line"><span class="comment">" not the only possible bad habit. For example, holding down the h/j/k/l keys</span></span><br><span class="line"><span class="comment">" for movement, rather than using more efficient movement commands, is also a</span></span><br><span class="line"><span class="comment">" bad habit. The former is enforceable through a .vimrc, while we don't know</span></span><br><span class="line"><span class="comment">" how to prevent the latter.</span></span><br><span class="line"><span class="comment">" Do this in normal mode...</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Left&gt;</span>  :<span class="keyword">echoe</span> <span class="string">"Use h"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Right&gt;</span> :<span class="keyword">echoe</span> <span class="string">"Use l"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Up&gt;</span>    :<span class="keyword">echoe</span> <span class="string">"Use k"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Down&gt;</span>  :<span class="keyword">echoe</span> <span class="string">"Use j"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">" ...and in insert mode</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Left&gt;</span>  <span class="symbol">&lt;ESC&gt;</span>:<span class="keyword">echoe</span> <span class="string">"Use h"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Right&gt;</span> <span class="symbol">&lt;ESC&gt;</span>:<span class="keyword">echoe</span> <span class="string">"Use l"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Up&gt;</span>    <span class="symbol">&lt;ESC&gt;</span>:<span class="keyword">echoe</span> <span class="string">"Use k"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;Down&gt;</span>  <span class="symbol">&lt;ESC&gt;</span>:<span class="keyword">echoe</span> <span class="string">"Use j"</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <em><a href="https://missing.csail.mit.edu/2020/editors/">Editors (Vim) · Missing Semester (mit.edu)</a></em>.</p>
<h2 id="MY-OPTIONS"><a href="#MY-OPTIONS" class="headerlink" title="MY OPTIONS"></a>MY OPTIONS</h2><p>I use <a href="https://github.com/junegunn/vim-plug">vim-plug</a> as my vim plugin manager. If you also want to use it, run:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more on <em><a href="https://github.com/junegunn/vim-plug">junegunn/vim-plug: Minimalist Vim Plugin Manager</a></em>.</p>
<p>Then you can use my <code>.vimrc</code>. Attention that it is based on the MIT basic version.</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">" Plugin options</span></span><br><span class="line"><span class="comment">" vim-plug</span></span><br><span class="line"><span class="keyword">call</span> plug#begin()</span><br><span class="line">Plug <span class="string">'kien/ctrlp.vim'</span></span><br><span class="line">Plug <span class="string">'mileszs/ack.vim'</span></span><br><span class="line">Plug <span class="string">'preservim/nerdtree'</span></span><br><span class="line">Plug <span class="string">'easymotion/vim-easymotion'</span></span><br><span class="line">Plug <span class="string">'tpope/vim-commentary'</span></span><br><span class="line">Plug <span class="string">'tpope/vim-fugitive'</span></span><br><span class="line">Plug <span class="string">'itchyny/lightline.vim'</span></span><br><span class="line">Plug <span class="string">'maxbrunsfeld/vim-yankstack'</span></span><br><span class="line">Plug <span class="string">'preservim/vim-indent-guides'</span></span><br><span class="line">Plug <span class="string">'dense-analysis/ale'</span></span><br><span class="line">Plug <span class="string">'dracula/vim'</span>, { <span class="string">'as'</span>: <span class="string">'dracula'</span> }</span><br><span class="line">Plug <span class="string">'jiangmiao/auto-pairs'</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"><span class="comment">" lightline.vim</span></span><br><span class="line"><span class="keyword">set</span> noshowmode</span><br><span class="line"><span class="keyword">if</span> !has(<span class="string">'gui_running'</span>)</span><br><span class="line">  <span class="keyword">set</span> t_Co=<span class="number">256</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:lightline</span> = {</span><br><span class="line">      \ <span class="string">'colorscheme'</span>: <span class="string">'wombat'</span>,</span><br><span class="line">      \ }</span><br><span class="line"></span><br><span class="line"><span class="comment">" vim-indent-guides</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">2</span> <span class="keyword">sw</span>=<span class="number">2</span> et</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_start_level</span>=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">" Set color scheme.</span></span><br><span class="line"><span class="keyword">colorscheme</span> dracula</span><br><span class="line"></span><br><span class="line"><span class="comment">" Let vim automatically infer indents based on context.</span></span><br><span class="line"><span class="keyword">set</span> smartindent</span><br><span class="line"></span><br><span class="line"><span class="comment">" Mapping configurations</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" leader is space</span></span><br><span class="line"><span class="keyword">let</span> mapleader = <span class="string">" "</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Insert mode, no recursively</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Map jk to &lt;ESC&gt;.</span></span><br><span class="line"><span class="keyword">inoremap</span> jk <span class="symbol">&lt;ESC&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Automatically complete pairs.</span></span><br><span class="line"><span class="comment">" Replaced by jiangmiao/auto-pairs.</span></span><br><span class="line"><span class="comment">"inoremap ( ()&lt;esc&gt;i</span></span><br><span class="line"><span class="comment">"inoremap [ []&lt;esc&gt;i</span></span><br><span class="line"><span class="comment">"inoremap { {}&lt;esc&gt;i</span></span><br><span class="line"><span class="comment">"inoremap ' ''&lt;esc&gt;i</span></span><br><span class="line"><span class="string">"inoremap "</span> <span class="string">""</span><span class="symbol">&lt;esc&gt;</span>i</span><br><span class="line"></span><br><span class="line"><span class="comment">" Normal mode, no recursively</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Move vertically by visual line.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="keyword">j</span> gj</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="keyword">k</span> gk</span><br><span class="line"><span class="comment">" Yank to system clipboard</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">y</span> <span class="comment">"+y</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">p</span> <span class="comment">"+p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Visual mode, no recurseively</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Put from system clipboard</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">y</span> <span class="comment">"+y</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">p</span> <span class="comment">"+p</span></span><br></pre></td></tr></tbody></table></figure>

<p>To use <code>vim-plug</code> to install the plugins, run:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line">:PlugInstall</span><br></pre></td></tr></tbody></table></figure>

<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><ul>
<li><em><a href="https://missing.csail.mit.edu/2020/editors/">Editors (Vim) · Missing Semester (mit.edu)</a></em></li>
<li><em><a href="https://ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门 - 阮一峰的网络日志 (ruanyifeng.com)</a></em></li>
<li><em><a href="https://dougblack.io/words/a-good-vimrc.html">A Good Vimrc (dougblack.io)</a></em></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>RLCraft 新手教程一：过渡到你的正常生存</title>
    <url>/posts/a1ada34d.html</url>
    <content><![CDATA[<p>本教程是笔者自己游玩过程中写的，出发点是笔者自己想玩但又不想花费时间看很多实况去了解一些细节，又找不到比较详细的文字版中文教程，以致于无从下手，只能慢慢啃各种模组的百科和 RLCraft Wiki，便以教程形式写下自己的游玩过程，希望对后来者有所帮助。笔者不是什么资深玩家，故难免有疏漏，请大家多多包涵。</p>
<span id="more"></span>

<p>由于 NTP 模组（<a href="https://www.mcmod.cn/class/2138.html">No Tree Punching，无树可撸</a>）的存在，初入 RLCraft，你的第一件事情不再是获取原木，而是撸树叶获取木棍，然后找到沙砾获取燧石。你可以按住鼠标左键徒手破坏树叶和沙砾，然后用右键点击掉落物以拿起它（或者你也可以按下 shift 来吸取附近的掉落物）。</p>
<p>手拿燧石右击石头 / 圆石等坚硬方块（?）上表面，你可以获取燧石碎块，然后打开背包，在 2*2 的合成栏上边放燧石碎块，下边放木棍，获取一把粗糙的小刀。</p>
<p>使用粗糙的小刀破坏草，可以获得植物纤维，在背包合成栏用三个植物纤维合成一个植物绳。然后再使用燧石碎块、植物绳、木棍合成粗糙的斧头。恭喜你获取了这个游戏的第一把斧头，用这把斧头你就可以开采原木了 —— 当心，树倒下来可能会砸死你！</p>
<p>你不再能够直接使用背包合成栏分解原木，而是需要把原木竖直放在地上，并用斧头右击其上表面，以获取两块木板。木棍也可以用类似的方式获取 —— 将木板放在地上，然后用斧头右击。</p>
<p>你可以看 jei 获取更多燧石工具的制作方法，但你更可以开始制作原版的木制工具。用木镐挖石头会掉落石子，四个石子 2*2 摆放可以获取圆石，而挖圆石则会直接掉落圆石。</p>
<p>恭喜你进入石器时代！现在，你可以开始下矿了！但要时刻注意的一点是照明 —— 恐怖生物会在黑暗中生成… 别自己怎么死的都不知道。你会发现木棍加煤炭不再能合成原版火把，它们现在只能合成熄灭的火把。要点亮它们，你需要的是一颗打火石 —— 将熄灭的火把和打火石放在合成栏里，你就可以获得点燃的火把。但这火把仍然会熄灭 —— 比如一场雨过后，比如燃烧很久之后…</p>
<p>虽然还有很多路要走，但你现在基本上可以短暂地享受一回类原版的 MC 了。</p>
<p>To be continue…</p>
]]></content>
      <categories>
        <category>Game</category>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>Minecraft</tag>
        <tag>RLCraft</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中赋值语句的返回值问题</title>
    <url>/posts/9693ba6.html</url>
    <content><![CDATA[<p>我曾经一直以为 C/C++ 中赋值语句的返回值不是 0 就是 1 —— 成功执行赋值操作返回 1，没有成功执行就返回 0。直到今天课上的一个例子，才让我知道，原来<strong>赋值语句的返回值就是赋的值的大小</strong>！</p>
<span id="more"></span>

<p>起因是下边的这道题目：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 下边各个循环的执行次数是多少：</span></span><br><span class="line"><span class="comment">// 1: 死循环</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2：0 次循环</span></span><br><span class="line"><span class="keyword">for</span> (; i = <span class="number">0</span>; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 3：0 次循环</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0</span>; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 4：死循环</span></span><br><span class="line"><span class="keyword">while</span> (i = <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一个因为 for 语句的第二个参数缺失，所以该循环不会停止；第三个初值 <code>i=0;</code> 即不满足 <code>i&lt;0;</code>，故不执行。</p>
<p>第四个，按照我错误的理解，赋值成功返回 1，所以说得通是 <code>while(true)</code> 永远执行，但四二个却无法这么解释了。去试了试写个下边两个东西输出赋值语句的返回值，才发现原来<strong>赋值语句的返回值就是赋的值</strong>。</p>
<p>C 代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">5</span>, c = <span class="number">-5</span>, d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="type">int</span>)(d = a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="type">int</span>)(d = b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="type">int</span>)(d = c));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>C++ 代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">5</span>, c = <span class="number">-5</span>, d;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(d = a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(d = b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(d = c) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果均如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br><span class="line">-5</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 格式化输入输出汇总</title>
    <url>/posts/b4e7acd7.html</url>
    <content><![CDATA[<p>本文汇总一下 C 语言 <code>scanf</code> 和 <code>printf</code> 的格式控制方法以及 C++ 的 <code>&lt;iomanip&gt;</code> 库。</p>
<span id="more"></span>

<h1 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h1><p>此处内容来源于 《C Primer Plus （第 6 版）中文版》。</p>
<h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf() 函数"></a>printf () 函数</h2><h3 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h3><p>ANSI C 中 printf () 的转换说明（P69，表 4.3：转换说明及其打印的输出结果）</p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><table>
<thead>
<tr>
<th>转换说明</th>
<th>打印的结果</th>
</tr>
</thead>
<tbody><tr>
<td> %d / %i</td>
<td> 有符号十进制整数</td>
</tr>
<tr>
<td> %u</td>
<td> 无符号十进制整数</td>
</tr>
<tr>
<td> %o</td>
<td> 无符号八进制整数</td>
</tr>
<tr>
<td> %x</td>
<td> 无符号十六进制整数，使用十六进制数 0f</td>
</tr>
<tr>
<td>%X</td>
<td> 无符号十六进制整数，使用十六进制数 0F</td>
</tr>
<tr>
<td>%a / %A</td>
<td> 十六进制数、浮点数和 p 计数法（C99/C11）</td>
</tr>
</tbody></table>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><table>
<thead>
<tr>
<th>转换说明</th>
<th>打印的结果</th>
</tr>
</thead>
<tbody><tr>
<td> %e / %E</td>
<td> 浮点数，e 计数法</td>
</tr>
<tr>
<td> %f</td>
<td> 浮点数，十进制计数法</td>
</tr>
<tr>
<td> %g / %G</td>
<td> 根据值的不同，自动选择 % f 或 % e / % E。% e / % E 格式用于指数小于 - 4 或大于等于精度时。</td>
</tr>
<tr>
<td>%a / %A</td>
<td> 十六进制数、浮点数和 p 计数法（十六进制指数计数法）（C99/C11）</td>
</tr>
</tbody></table>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table>
<thead>
<tr>
<th>转换说明</th>
<th>打印的结果</th>
</tr>
</thead>
<tbody><tr>
<td> %c</td>
<td> 单个字符<strong>（包括空白字符）</strong></td>
</tr>
<tr>
<td>%s</td>
<td> 字符串</td>
</tr>
<tr>
<td> %p</td>
<td> 指针</td>
</tr>
<tr>
<td> %%</td>
<td> 百分号</td>
</tr>
</tbody></table>
<h3 id="转换说明修饰符"><a href="#转换说明修饰符" class="headerlink" title="转换说明修饰符"></a>转换说明修饰符</h3><p>（P71，表 4.4：printf () 的修饰符）：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记</strong></td>
<td>共 5 种（-, +, 空格，# , 0）</td>
</tr>
<tr>
<td><strong>数字</strong></td>
<td>最小字段宽度（不够自动变宽）</td>
</tr>
<tr>
<td><strong>. 数字</strong></td>
<td>精度（具体见下边说明）</td>
</tr>
<tr>
<td><strong>h</strong></td>
<td> 和整型转换说明一起使用，表示 short int 或 unsigned short int</td>
</tr>
<tr>
<td>hh</td>
<td> 和整型转换说明一起使用，表示 signed char 或 unsigned char</td>
</tr>
<tr>
<td>j</td>
<td> 和整型转换说明一起使用，表示 intmax_t 或 uintmax_t （这些类型定义在 &lt;stdint.h&gt; 中）</td>
</tr>
<tr>
<td><strong>l</strong></td>
<td> 和整型转换说明一起使用，表示 long int 或 unsigned long int（和浮点型转换说明构成 % lf，表示 double）</td>
</tr>
<tr>
<td><strong>ll</strong></td>
<td> 和整型转换说明一起使用，表示 long long int 或 unsigned long long int（C99）</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td> 和浮点转换说明一起使用，表示 long double 类型的值</td>
</tr>
<tr>
<td> t</td>
<td> 和整型转换说明一起使用，表示 ptrdiff_t （ptrdiff_t 是两个指针差值的类型，C99）</td>
</tr>
<tr>
<td>z</td>
<td> 和整型转换说明一起使用，表示 size_t （size_t 是 sizeof 返回的类型，C99）</td>
</tr>
</tbody></table>
<blockquote>
<p>上边的 <strong>. 数字</strong>：</p>
<p>对于 % e、% E、% f，表示小数点右边数字的位数；</p>
<p>对于 % g、% G，表示有效数字的最大位数；</p>
<p>对于 % s，表示待打印字符的最大数量；</p>
<p>对于整型转换，表示待打印数字的最小位数，如有必要，使用前导 0 来达到这个位数。</p>
<p>只是用。表示其后跟随了一个 0，所以 %.f 和 %.0f 相同。</p>
</blockquote>
<p>（P72，表 4.5：printf () 中的标记）：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td> -</td>
<td> 左对齐</td>
</tr>
<tr>
<td> +</td>
<td> 有符号值前加正负号</td>
</tr>
<tr>
<td>空格</td>
<td>有符号值正不加，负加负号</td>
</tr>
<tr>
<td>#</td>
<td>把结果转换为另一种形式，具体看下边</td>
</tr>
<tr>
<td> 0</td>
<td> 对于数值格式，用前导 0 代替空格填充字段宽度。对于整数格式，如果出现 - 标记或者指定精度，则忽略该标记</td>
</tr>
</tbody></table>
<blockquote>
<p># 的说明：</p>
<p>% o：以 0 开始；</p>
<p>% x / % X：以 0x / 0X 开始；</p>
<p>所有浮点格式：保证即使后边没有任何数字，也打印一个小数点字符；</p>
<p>% g / % G：防止结果后边的 0 被删除。</p>
</blockquote>
<h2 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf () 函数</h2><p>大部分与上边相同，只讲不一样的。</p>
<p>（P80，表 4.7：scanf () 转换说明中的修饰符）：</p>
<table>
<thead>
<tr>
<th>转换说明</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td> *</td>
<td> 抑制赋值</td>
</tr>
<tr>
<td>数字</td>
<td>最大字符宽度。输入达到这个宽度或者第一次遇到空白字符时停止。</td>
</tr>
</tbody></table>
<p>scanf () 的返回值是成功读取的项数。如果没有读取任何项，则返回 0；如果检测到 “文件结尾”，返回 EOF （EOF 是定义 &lt;stdio.h&gt; 中定义的特殊值，一般用 #define 定义为 -1）。</p>
<p><strong>注意：</strong>输入数字的时候，在不设置分隔符号时，scanf () 默认使用空白字符进行分隔；但是输入字符时，空白字符不会被忽略，而是被顺利读入。</p>
<p>比如下边这道题：</p>
<p>有如下程序段：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1, a2;</span><br><span class="line"><span class="type">char</span> c1, c2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%c%d%c"</span>, &amp;a1, &amp;c1, &amp;a2, &amp;c2);</span><br></pre></td></tr></tbody></table></figure>

<p>若要求 a1, a2, c1, c2 的值分别为 10, 20, A, B，正确的数据输入是（ ）：</p>
<p>A. 10A20 B&lt;CR&gt;</p>
<p>B. 10 A 20 B&lt;CR&gt;</p>
<p>C. 10 A20B&lt;CR&gt;</p>
<p>D. 10A 20B&lt;CR&gt;</p>
<p>正确答案为 D。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>参考：<a href="https://blog.csdn.net/Jacky_Feng/article/details/109119782">【C++】C++ 标准库之 iomanip 库（格式输入输出）_Jacky_Feng 的博客 - CSDN 博客</a></p>
<table>
<thead>
<tr>
<th>控制符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td> oct</td>
<td> 八进制输入 / 输出</td>
</tr>
<tr>
<td> dec</td>
<td> 十进制输入 / 输出</td>
</tr>
<tr>
<td> hex</td>
<td> 十六进制输入 / 输出</td>
</tr>
<tr>
<td> setbase(n)</td>
<td> 设置为 n 进制 (n = 8, 10, 16)</td>
</tr>
<tr>
<td>setprecision(n)</td>
<td> 设置浮点数的有效数字为 n 位</td>
</tr>
<tr>
<td> setfill(c)</td>
<td> 设置字符填充为 c</td>
</tr>
<tr>
<td>setw(n)</td>
<td> 设置宽度</td>
</tr>
<tr>
<td> setiosflags(ios::fixed)</td>
<td> 设置浮点数以固定的小数位数显示</td>
</tr>
<tr>
<td> setiosflags(ios::scientific)</td>
<td> 设置浮点数以科学计数法表示</td>
</tr>
<tr>
<td> setiosflags(ios::left)</td>
<td> 输出左对齐</td>
</tr>
<tr>
<td> setiosflags(ios::right)</td>
<td> 输出右对齐</td>
</tr>
<tr>
<td> setiosflags(ios::skipws)</td>
<td> 忽略前导空格</td>
</tr>
<tr>
<td> setiosflags(ios::uppercase)</td>
<td> 在以科学计数法输出 E 与十六进制输出 X 以大写输出，否则小写</td>
</tr>
<tr>
<td> setiosflags(ios::showpos)</td>
<td> 输出正数时显示”+” 号</td>
</tr>
<tr>
<td> setiosflags(ios::showpoint)</td>
<td> 强制显示小数点</td>
</tr>
<tr>
<td> resetiosflags()</td>
<td> 终止已经设置的输出格式状态，在括号中应指定内容</td>
</tr>
</tbody></table>
<p>更多请见：<a href="https://www.w3cschool.cn/doc_cpp/cpp-header-iomanip.html">iomanip CPP 官方教程 _w3cschool</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>iomanip</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ const 用法汇总</title>
    <url>/posts/7ec6ba38.html</url>
    <content><![CDATA[<p>最开始只是用 const 来定义常量，学到了指针传参的时候又知道了用 const 来防止一些值的修改，学到类的时候又看到非静态成员函数后边加个 const 来干嘛干嘛，然后么又听说什么顶层 const、底层 const… 真是越学越迷糊了，赶紧做一波整理。</p>
<span id="more"></span>

<p><strong>[2023 年 3 月 24 日更新：]</strong> 此文章已经重写，请查看：_<a href="https://blocklune.github.io/posts/3358bcc1.html">The const and constexpr in C++ (REMAKE)</a>_</p>
<h2 id="最基本的用法-——-定义常量"><a href="#最基本的用法-——-定义常量" class="headerlink" title="最基本的用法 —— 定义常量"></a>最基本的用法 —— 定义常量</h2><p>这个不必多说，直接上代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 正确：a 没有 const 修饰，可以改变其值</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">// 错误：b 有 const 修饰，不能改变其值</span></span><br></pre></td></tr></tbody></table></figure>

<p>除了这个，还有一点是，虽然似乎我们可以通过一些 “骚操作” 改变 const 修饰的变量（常量？）的值，但是输出的时候，会发现结果并没有改变。看下边的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    <span class="comment">// 奇怪的骚操作</span></span><br><span class="line">    <span class="comment">// 直接 int *p = &amp;x; 是不行的</span></span><br><span class="line">    <span class="comment">// 但这样可以</span></span><br><span class="line">    <span class="comment">// 这样我们就可以通过指针 p 来直接操作那块内存</span></span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是如果加上 <code>volatile</code> 关键词，却可以发现结果也可以跟着变：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是，上边的 <code>const</code> 修饰的都不是全局变量。如果修饰的是全局变量，我们似乎就不能通过指针的小把戏来改变 <code>const</code> 的值了：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 错误代码：</span></span><br><span class="line"><span class="comment">// 这玩意儿能通过编译，但是压根跑不起来</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    *p1 = <span class="number">7</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*p1 = "</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但如果加上了 <code>volatile</code> 依然可以跑，并且也可以用指针来修改它的值：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)&amp;y;</span><br><span class="line">    *p2 = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"y = "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*p2 = "</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">y = 8</span></span><br><span class="line"><span class="comment">*p2 = 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>总结一下，就是 ——</p>
<ol>
<li>如果是局部的 <code>const</code>，那至少有两方面的保护：一是编译检查，看看我们下边的代码是否显而易见地尝试去改变它的值，如果有那就报错；二是编译器的自动优化，编译器会把这个变量的值复制一份放到寄存器里，所以即使我们用指针改变了原来内存里的值，输出的结果还是原来的值（备份到寄存器的原来的值的拷贝），所以当我们使用 <code>voliatile</code> 关键字关闭了编译器的这种优化，让程序每运行到要用到这个 <code>const</code> 修饰的变量的时候都去原来的地址读取值的时候，我们的小把戏成功了。</li>
<li>如果是全局的 <code>const</code>，还会有其他的机制，具体还没弄清楚，不过你可以看看<a href="https://zhuanlan.zhihu.com/p/145323002">《Linux 系统编程学习总结 （二）ELF - 知乎》</a>这篇文章，也许会有帮助？</li>
</ol>
<h2 id="顶层-const-和底层-const"><a href="#顶层-const-和底层-const" class="headerlink" title="顶层 const 和底层 const"></a>顶层 const 和底层 const</h2><p>首先，讨论顶层底层的 const，一般都是对指针变量才有意义。那么啥是顶层 const？啥是底层 const？</p>
<blockquote>
<p><strong>顶层 const</strong>（top-level const）表示指针<strong>本身</strong>是个常量；<br><strong>底层 const</strong>（low-level const）表示指针所指的<strong>对象</strong>是一个常量。</p>
</blockquote>
<p>举几个例子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;x;       <span class="comment">// 顶层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;x;       <span class="comment">// 底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;x; <span class="comment">// 左边是底层 const, 右边是顶层 const</span></span><br><span class="line">p1 = &amp;y;                  <span class="comment">// 错误，p1 是顶层 const 修饰的，所以 p1 指向的地址是确定的，无法更改它的指向</span></span><br><span class="line">p2 = &amp;y;                  <span class="comment">// 正确，p2 没有被顶层 const 修饰，这意味着我们可以修改它的指向</span></span><br><span class="line">p3 = &amp;y;                  <span class="comment">// 错误</span></span><br><span class="line">*p1 = y;                  <span class="comment">// 正确，p1 没有被底层 const 修饰，这意味着我们可以修改它指向的值</span></span><br><span class="line">*p2 = y;                  <span class="comment">// 错误，p2 是底层 const 修饰的，我们无法改变它指向的值</span></span><br><span class="line">*p3 = y;                  <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure>

<p>也就是说：</p>
<ul>
<li>仅仅被顶层 const 修饰，意味着指针变量的指向无法改变，但可以操作指向的值（指针常量？指针（地址）是个常量）；</li>
<li>仅仅被底层 const 修饰，意味着指针变量的指向可以改变，但无法操作指向的值（常量指针？ 指向常量的指针）；</li>
<li>如果两重修饰，那么就就没办法改变指针的指向，也没办法操作指向的值。</li>
</ul>
<p>顺便一说对于引用的情况。因为引用必须初始化并且初始化完成后（起玩别名后就不能改变它引用的对象了），所以 <code>const int &amp;</code> 就是顶层的，并且没有 <code>int &amp; const</code> 这种写法。</p>
<h2 id="函数中的-const"><a href="#函数中的-const" class="headerlink" title="函数中的 const"></a>函数中的 const</h2><h3 id="参数列表中的-const"><a href="#参数列表中的-const" class="headerlink" title="参数列表中的 const"></a>参数列表中的 const</h3><p>其实就是希望函数运行过程中不改变这个变量的值。比如写函数原型的时候用 <code>const int &amp;</code>，其中 <code>const</code> 表示这个函数对这个变量的操作是只读的，不会改变原来的值，而 <code>&amp;</code> 的作用就是，既然这里只是要读一读这个变量的值，并不对它进行操作，那我就不创建副本了，直接用它自己。</p>
<h3 id="返回的-const"><a href="#返回的-const" class="headerlink" title="返回的 const"></a>返回的 const</h3><p>这边还没弄清楚，以后弄清楚了再写。</p>
<h2 id="类的非静态成员函数后边跟的-const"><a href="#类的非静态成员函数后边跟的-const" class="headerlink" title="类的非静态成员函数后边跟的 const"></a>类的非静态成员函数后边跟的 const</h2><p>这样可以让这个函数的 <code>this</code> 是只读的。</p>
<p>看这篇文章：<a href="https://blog.51cto.com/u_11495341/3040168">《C\C++ 中函数后面加 const_51CTO 博客_c++ const 函数》</a></p>
<blockquote>
<p>非静态成员函数后面加 const（加到非成员函数或静态成员后面会产生编译错误）表示成员函数隐含传入的 this 指针为 const 指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对 this 指针的 const 引用）<br>唯一的例外是对于 mutable 修饰的成员。加了 const 的成员函数，可以被非 const 对象和 const 对象调用，但不加 const 的成员函数 只能被非 const 对象调用。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/Forever-Kenlen-Ja/p/3776991.html">《C++ const 用法小结 （欢迎大家拍砖） - karllen - 博客园》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/145323002">《Linux 系统编程学习总结 （二）ELF - 知乎》</a></li>
<li><a href="https://blog.51cto.com/u_11495341/3040168">《C\C++ 中函数后面加 const_51CTO 博客_c++ const 函数》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/499784237">《C++ 顶层 const 和底层 const - 知乎》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/161560391">《C++ 干货系列 —— 顶层 const 和底层 const - 知乎》</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中 cin 与 cout 的转进制输入输出</title>
    <url>/posts/9e863176.html</url>
    <content><![CDATA[<p>笔者的朋友有道输入八进制输出十进制的题目，他是使用数学方法实现的。笔者隐隐约约记得好像 cin 和 cout 有控制输入输出数字进制的方法，查找了一些资料，做一下笔记。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>进制</th>
<th>对应缩写</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td> bin</td>
</tr>
<tr>
<td> 八进制</td>
<td> oct</td>
</tr>
<tr>
<td> 十进制</td>
<td> dec</td>
</tr>
<tr>
<td> 十六进制</td>
<td> hex</td>
</tr>
</tbody></table>
<p>接下来只要在输入 / 输出的时候加上这些缩写就行了。</p>
<p>比如输入一个八进制数然后以十进制输出它：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">    cin &gt;&gt; oct &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>程序运行结果：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">1750</span><br><span class="line">1000</span><br></pre></td></tr></tbody></table></figure>

<p>（”1750” 是输入，”1000” 是输出）</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C 标准库中 qsort 和 C++ STL 中 sort 的用法</title>
    <url>/posts/eab95d6e.html</url>
    <content><![CDATA[<p>虽然到现在还是不能完全理解 <code>qsort</code> 和 <code>sort</code> 这两个函数的底层原理，但至少，先学会如何使用吧。</p>
<span id="more"></span>

<h2 id="qsort"><a href="#qsort" class="headerlink" title="qsort"></a>qsort</h2><p><strong>需要包含的库:</strong></p>
<p>stdlib.h (C++ 中 是 cstdlib)</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>参数解释：</strong></p>
<ul>
<li>base: 必选，数组名（数组首元素的地址）；</li>
<li>nitems: 必选，数组中元素的个数；</li>
<li>size: 必选，数组中单个元素的大小；</li>
<li>compar: 必选，一个函数指针，具体这个函数要干嘛下边细说。</li>
</ul>
<p>最后一个参数是函数指针，这个指针指向的函数的原型应该类似于下边这样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个返回值为 <code>-1</code>、<code>0</code> 或 <code>1</code> 的函数。</p>
<p>如果要实现升序，那么应该是：</p>
<blockquote>
<p>a&gt;b：返回 1（或其他正数）;<br>a==b：返回 0;<br>a&lt;b: 返回 -1（或其他负数）;</p>
</blockquote>
<p>如果是降序，那么就应该反过来，像下边这样：</p>
<blockquote>
<p>a&gt;b：返回 -1（或其他负数）;<br>a==b：返回 0;<br>a&lt;b: 返回 1（或其他正数）;</p>
</blockquote>
<p>比如我要对 int 类型的数组升序排序，那么我的 cmp 函数应该像下边这样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *x = (<span class="type">const</span> <span class="type">int</span> *)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *y = (<span class="type">const</span> <span class="type">int</span> *)b;</span><br><span class="line">    <span class="keyword">if</span> (*x &gt; *y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*x == *y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或者也可以简化成下边这样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">const</span> <span class="type">int</span> *)a - *(<span class="type">const</span> <span class="type">int</span> *)b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 a&gt;b 等比较方式只是形式上我这么写，实际上有可能这两个元素我并不能直接这么比（比如如果这里的 a、b 都是 struct），那么就应该类似下边这样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> score;</span><br><span class="line">} STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    STUDENT stu[<span class="number">5</span>] = {{<span class="number">1</span>, <span class="number">5</span>}, {<span class="number">2</span>, <span class="number">3</span>}, {<span class="number">3</span>, <span class="number">1</span>}, {<span class="number">4</span>, <span class="number">2</span>}, {<span class="number">5</span>, <span class="number">4</span>}};</span><br><span class="line">    qsort(stu, <span class="number">5</span>, <span class="keyword">sizeof</span>(STUDENT), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ID: %u, Score: %u\n"</span>, stu[i].ID, stu[i].score);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> STUDENT *x = (<span class="type">const</span> STUDENT *)a;</span><br><span class="line">    <span class="type">const</span> STUDENT *y = (<span class="type">const</span> STUDENT *)b;</span><br><span class="line">    <span class="comment">// 降序排序</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;score &gt; y-&gt;score)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;score == y-&gt;score)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ID: 1, Score: 5</span><br><span class="line">ID: 5, Score: 4</span><br><span class="line">ID: 2, Score: 3</span><br><span class="line">ID: 4, Score: 2</span><br><span class="line">ID: 3, Score: 1</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><strong>需要包含的库:</strong></p>
<p>algorithm（C++ STL 中的算法库）</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>参数解释：</strong></p>
<p>first: 必选，排序开始处（参与排序的第一个元素）；<br>last: 必选，排序结束处的<strong>后一个紧挨着的位置</strong>（参与排序的最后一个元素的<strong>后一个位置</strong>）；<br>comp: 可选，用来指定怎么排序的函数，没有的话如果可以默认升序。</p>
<p>下边给出一些例子：</p>
<p>给一个数组升序排序：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = {<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>};</span><br><span class="line"><span class="built_in">sort</span>(arr, arr + <span class="number">5</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>给一个 vector 降序排序：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>};</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></tbody></table></figure>

<p>这里用了 <code>greater&lt;typename&gt;()</code> 这个东东直接表达我这个排序需要降序排序，类似的还有 <code>less&lt;typename&gt;()</code> 用来指定升序。</p>
<p>然后是自定义这第三个参数，我们就用上边 qsort 那个例子吧：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">STUDENT</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> score;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(STUDENT, STUDENT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    STUDENT stu[<span class="number">5</span>] = {{<span class="number">1</span>, <span class="number">5</span>}, {<span class="number">2</span>, <span class="number">3</span>}, {<span class="number">3</span>, <span class="number">1</span>}, {<span class="number">4</span>, <span class="number">2</span>}, {<span class="number">5</span>, <span class="number">4</span>}};</span><br><span class="line">    <span class="built_in">sort</span>(stu, stu + <span class="number">5</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ID: %u, Score: %u\n"</span>, stu[i].ID, stu[i].score);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(STUDENT a, STUDENT b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (a.score &gt; b.score)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或者也可以把 cmp 写成下边这种更容易记住的方式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(STUDENT a, STUDENT b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="comment">// 表示排序完成后前一个元素比后一个元素大，即降序排序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出和上边是一样的。</p>


<article class="message message-immersive is-danger">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i><strong>注意</strong>

<p>在 qsort 中，最后一个参数的函数的返回值应是一个有符号整型。在期望<strong>升序</strong>排序时，这个返回值应该指定为：<strong>第一个元素大于第二个元素，返回正数；</strong>第一个元素等于第二个元素，返回 0；第一个元素小于第二个元素，返回负数。</p>
<p>在 C++ STL 的 sort 中，最后一个参数的返回值应是一个布尔值。在期望<strong>升序</strong>排序时，这个返回值应该是 (第一个元素 &lt; 第二个元素) 的运算结果。</p>


</div>
</article>

]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Sorting</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中与 (&amp;&amp;) 和或 (||) 运算符的短路运算</title>
    <url>/posts/13d09bbb.html</url>
    <content><![CDATA[<p>此篇笔记来源于下边的这个题目。<br><img data-src="https://s1.ax1x.com/2022/10/12/xaK5c9.png"></p>
<span id="more"></span>

<p>本来以为结果为 3，但是实际跑了一下发现结果是 1。请教了一下大佬知道了这叫做或运算符（||）的短路运算。</p>
<p>正常来说，或运算中只要有一个为真，结果就为真。所谓或的短路运算就是说，如果已经出现了真，那么后续的运算就不会进行了。以上面的题目为例就是，因为第一个 ++x 这个运算结果肯定为真，那么后面的另外两个 ++x 就不会运行。</p>
<p>类似的，还有与（&amp;&amp;）的短路运算。正常来说，与运算中必须所有均为真，结果才为真。所以与的短路就是，如果前面的运算结果已经有假了，那么就可以确定这个与运算总体的结果为假，也就不会运行后边的运算了。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中使用变量输出小数点位数</title>
    <url>/posts/45e2d42.html</url>
    <content><![CDATA[<p>这事儿要从一周前讲起，有人在群里问了这么一道题，要求用 C 实现：</p>
<span id="more"></span>

<blockquote>
<p>习题 2-5 分数化小数（decimal）<br>输入正整数 a,b,c，输出 a/b 的小数形式，精确到小数点后 c 位。a,b&lt;=10^6，c&lt;=100。输入包含多组数据，结束标记为 a=b=c=0。<br>样例输入：<br>1 6 4<br>0 0 0<br>样例输出：<br>0.1667</p>
</blockquote>
<p>当时我做了个简化的版本 —— 最多处理 1000 组输入，并且 c 比较小（即不需要高精度）的情况的代码，主要是做一个字符串处理，来构造一个传给 <code>printf()</code> 的格式控制字符串，代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 需要用到它的 itoa() 函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 用到strcat拼接字符数组，memset清空字符数组</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 仅实现了最多有 1000 个输入的情况</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a[<span class="number">1000</span>], b[<span class="number">1000</span>], c[<span class="number">1000</span>], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> ans[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1000</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%u%u%u"</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (!(a[i] == <span class="number">0</span> &amp;&amp; b[i] == <span class="number">0</span> &amp;&amp; c[i] == <span class="number">0</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (b[i] != <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                ans[i] = a[i] * <span class="number">1.0</span> / b[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt - <span class="number">1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">char</span> formatMsgP1[] = <span class="string">"%."</span>;</span><br><span class="line">        <span class="type">char</span> *formatMsgP2;</span><br><span class="line">        <span class="comment">// 根据位数动态确定 char 数组的大小</span></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; <span class="number">99</span>)</span><br><span class="line">        {</span><br><span class="line">            formatMsgP2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">3</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i] &gt; <span class="number">9</span>)</span><br><span class="line">        {</span><br><span class="line">            formatMsgP2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            formatMsgP2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        }</span><br><span class="line">        itoa(c[i], formatMsgP2, <span class="number">10</span>);</span><br><span class="line">        <span class="type">char</span> formatMsgP3[] = <span class="string">"lf\n"</span>;</span><br><span class="line">        <span class="type">char</span> formatMsg[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">strcat</span>(formatMsg, formatMsgP1);</span><br><span class="line">        <span class="built_in">strcat</span>(formatMsg, formatMsgP2);</span><br><span class="line">        <span class="built_in">strcat</span>(formatMsg, formatMsgP3);</span><br><span class="line">        <span class="built_in">printf</span>(formatMsg, ans[i]);</span><br><span class="line">        <span class="built_in">memset</span>(formatMsg, <span class="number">0</span>, <span class="keyword">sizeof</span>(formatMsg)); <span class="comment">// 清空数组</span></span><br><span class="line">        <span class="built_in">free</span>(formatMsgP2);                       <span class="comment">// 释放指针</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样的代码就比较麻烦，大量的代码都用在字符串拼接了。但今天看到一篇文章（<a href="https://mxte.cc/90.html">《使用变量设定小数点位数》</a>），才知道原来根本不需要那么麻烦。</p>
<p>本来我的目标是构造这么一个格式控制字符串 <code>%.&lt;c&gt;lf</code>，其中 <code>&lt;c&gt;</code> 需要由用户输入。上边的思路就是输入数字之后用 <code>itoa()</code> 函数把输入的数字转成字符串，然后拼一拼。</p>
<p>但实际上可以这样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%.*lf"</span>, c[i], ans[i]);</span><br></pre></td></tr></tbody></table></figure>

<p>使用 <code>*</code>，<code>printf()</code> 就知道了，需要去后边找这么一个参数。</p>
<p>所以上边 <code>return 0;</code> 前面那个 <code>for</code> 里那么多东西都只要换成这一句就行了。</p>
<p>下边贴出一个用动态数组实现的任意组数数据输入的代码（依然没有高精度，我不会啊）：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUMS</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="type">double</span> ans;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUMS</span> *<span class="title">p</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">append</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">double</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%u%u%u"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="type">double</span> tmp_ans = a * <span class="number">1.0</span> / b;</span><br><span class="line">            append(c, tmp_ans);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.*lf\n"</span>, (p + i)-&gt;c, (p + i)-&gt;ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">append</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> _c, <span class="type">double</span> _ans)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        p = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS));</span><br><span class="line">        p-&gt;c = _c;</span><br><span class="line">        p-&gt;ans = _ans;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">struct</span> NUMS *tmp = <span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS));</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, p, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS) * size);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="built_in">calloc</span>(size + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS));</span><br><span class="line">        <span class="built_in">memcpy</span>(p, tmp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS) * (size + <span class="number">1</span>));</span><br><span class="line">        (p + size)-&gt;c = _c;</span><br><span class="line">        (p + size)-&gt;ans = _ans;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言文件操作</title>
    <url>/posts/914118ff.html</url>
    <content><![CDATA[<p>简单记录一下 C 语言的文件操作的相关内容。</p>
<span id="more"></span>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// stdio.h 提供了 C 语言中的许多 IO，当然包括文件 IO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义文件指针</span></span><br><span class="line">FILE *fp;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="打开文件-fopen"><a href="#打开文件-fopen" class="headerlink" title="打开文件 fopen()"></a>打开文件 fopen ()</h2><div class="note "><p>函数名称：fopen<br>参数：待打开文件的名称（包含该文件名的字符串地址），打开文件的模式；<br>返回值：成功打开文件则返回一个文件指针，否则返回空指针（NULL）</p>
</div>

<p>例如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span> (fp = fopen(<span class="string">"example.file"</span>, <span class="string">"r"</span>) == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fail to open the file.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意，该函数第二个参数是一个字符串，可能的值如下（表来自《C Primer Plus（第 6 版）中文版》P357 表 13.1）：</p>
<table>
<thead>
<tr>
<th>模式字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td> “r”</td>
<td> 以读模式打开文件</td>
</tr>
<tr>
<td> “w”</td>
<td> 以写模式打开文件，把现有文件长度截为 0，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td> “a”</td>
<td> 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td> “r+”</td>
<td> 以更新模式打开文件（即可以读写文件）</td>
</tr>
<tr>
<td>“w+”</td>
<td> 以更新模式打开文件，如果文件存在，则将其长度截为 0，如果文件不存在则创建一个新文件</td>
</tr>
<tr>
<td> “a+”</td>
<td> 以更新模式打开文件，在现有文件的末尾添加内容，如果文件不存在则创建一个新文件，<strong>可以读整个文件，但只能从末尾添加内容</strong></td>
</tr>
<tr>
<td> “rb”、”wb”、”ab”、”rb+”、”r+b”、”wb+”、”w+b”、”ab+”、”a+b”</td>
<td> 与上边的对应类似，但以二进制模式打开文件</td>
</tr>
<tr>
<td> “wx”、”wbx”、”w+x”、”wb+x” 或”w+bx”</td>
<td>（C11）与上边对应类似，但如果文件已存在或以独占模式打开文件，则打开文件失败</td>
</tr>
</tbody></table>
<p>带字母 x 的写模式比以前的具有更多特性：</p>
<ol>
<li>如果以传统的一种写模式打开一个现有文件，fopen () 会把该文件的长度截为 0，这样就丢失了该文件的内容。但是使用带 x 字母的写模式，即使 fopen () 操作失败，原文件的内容也不会被删除；</li>
<li>如果环境允许，x 模式的独占特性使得其他程序或线程无法访问正在被打开的文件。</li>
</ol>
<h2 id="关闭文件-fclose"><a href="#关闭文件-fclose" class="headerlink" title="关闭文件 fclose()"></a>关闭文件 fclose ()</h2><div class="note "><p>函数名称：fclose<br>参数：待关闭文件的名称（包含该文件名的字符串地址）；<br>返回值：成功关闭返回 0，否则返回 EOF。</p>
</div>

<div class="note warning no-icon"><p>注意区分 fopen () 和 fclose () 的返回值！前者失败时返回 NULL（通常情况下就是 0），后者成功时返回 0。</p>
</div>

<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="fprintf-和-fscanf"><a href="#fprintf-和-fscanf" class="headerlink" title="fprintf() 和 fscanf()"></a>fprintf () 和 fscanf ()</h3><p>这两个函数分别和 printf () 和 scanf () 类似，只不过 printf () 和 scanf () 分别默认了写和读的标准文件是 stdout 和 stdin，而 fprintf () 和 fscanf () 的第一个参数都需要指定文件指针。</p>
<h3 id="getc-和-putc"><a href="#getc-和-putc" class="headerlink" title="getc() 和 putc()"></a>getc () 和 putc ()</h3><p>这两个函数分别和 getchar () 和 putchar () 类似，只是需要提供文件指针。</p>
<h3 id="ungetc"><a href="#ungetc" class="headerlink" title="ungetc()"></a>ungetc()</h3><div class="note "><p>函数名称：ungetc<br>函数原型：<code>int ungetc(int c, FILE *fp);</code><br>函数作用：把 c 指定的字符放回输入流中<br>返回值：如果成功，则返回被推入的字符，否则返回 EOF</p>
</div>

<h3 id="fgets-和-fputs"><a href="#fgets-和-fputs" class="headerlink" title="fgets() 和 fputs()"></a>fgets () 和 fputs ()</h3><p>虽然这两个函数也分别类似于 gets () 和 puts ()，但比起上边几个函数的” 类似”，这个要低一点，所以详细说明一下。</p>
<div class="note "><p>函数名称：fgets<br>函数原型：<code>char *fgets (char * restrict str, int n, FILE * restrict fp);</code><br>返回值：如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。</p>
</div>

<p>需要注意 fgets () 的第二个参数，因为 fgets () 读取输入知道第一个换行符的后边（<strong>意味着它会读入换行符</strong>），或读到文件结尾，或读取 n-1 个字符，并在结尾加上一个 <code>\0</code> 使之成为一个字符串。</p>
<div class="note "><p>函数名称：fputs<br>函数原型：<code>int fputs (char * restrict str, FILE * restrict fp);</code><br>返回值：该函数返回一个非负值，如果发生错误则返回 EOF。</p>
</div>

<p>fputs () 与 puts () 类似，但<strong>不会在结尾自动添加换行</strong>。</p>
<div class="note warning no-icon"><p>注意区分 fgets () 与 gets ()， fputs () 与 puts ()！gets () 不保留换行符所以 puts () 自动添加换行符；fgets () 保留换行符所以 fputs () 不会添加换行符。</p>
</div>

<h3 id="fread-和-fwrite"><a href="#fread-和-fwrite" class="headerlink" title="fread() 和 fwrite()"></a>fread () 和 fwrite ()</h3><p>上述的函数都是以文本形式读写文件，这两个函数用于以二进制形式读写文件。</p>
<div class="note "><p>函数名称：fread<br>函数原型：<code>size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);</code><br>返回值：返回成功读取项的数量。正常情况下返回值等于 nmemb，发生错误则返回值小于 nmemb。</p>
</div>

<div class="note "><p>函数名称：fwrite<br>函数原型：<code>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);</code><br>返回值：返回成功写入项的数量。正常情况下返回值等于 nmemb，发生错误则返回值小于 nmemb。</p>
</div>

<p>参数 size 表示待写入数据块的大小（以字节为单位），nmemb 表示待写入数据块的数量。</p>
<p>下边是两个使用这两个函数的例子。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 保存一个大小为 256 字节的 buffer 数组</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">fwrite(buffer, <span class="number">256</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存一个内含 10 个 double 类型值的数组</span></span><br><span class="line"><span class="comment">// 或者说理解成保存 10 个 double 类型的值</span></span><br><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fwrite(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 10 个 double 类型的值到一个数组中</span></span><br><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="随机访问-fseek-和-ftell"><a href="#随机访问-fseek-和-ftell" class="headerlink" title="随机访问 fseek() 和 ftell()"></a>随机访问 fseek () 和 ftell ()</h2><div class="note "><p>函数名称：fseek<br>函数原型：<code>int fseek(FILE *_File,long _Offset,int _Origin);</code><br>参数：文件指针，偏移量 (long 类型)，模式<br>返回值：正常则返回 0，错误则返回 -1。</p>
</div>

<p>第二个参数偏移量必须是一个 long 类型的值，代表偏移的<strong>字节数</strong>。这个值为正，则表示像文件末尾方向移动；为负则表示向文件开头处。<br>第三个参数可以理解成起点位置，可以使用 <code>SEEK_SET</code>、<code>SEEK_CUR</code> 或 <code>SEEK_END</code> 分别定位到文件开始、当前位置或文件末尾（老版本应分别使用 <code>0</code>、<code>1</code>、<code>2</code>）。</p>
<p>下边是一些例子（来自《C Primer Plus（第 6 版）中文版》P364）：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);   <span class="comment">// 定位至文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET);  <span class="comment">// 定位至文件中第 10 个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR);   <span class="comment">// 从文件当前位置向结尾方向移动 2 个字节</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);   <span class="comment">// 定位至文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END); <span class="comment">// 从文件结尾处回退 10 个字节</span></span><br></pre></td></tr></tbody></table></figure>

<div class="note "><p>函数名称：ftell<br>函数原型：<code>long ftell(FILE *_File);</code><br>返回值：返回当前位置距文件开始的字节数，如文件的第一个字节到文件开始处的距离为 0。</p>
</div>

<p>下边是书中给出的一个例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END); <span class="comment">// 首先定位到文件结尾</span></span><br><span class="line">last = ftell(fp);        <span class="comment">// 统计字节数，并存储到 last 中</span></span><br><span class="line"><span class="comment">// 逆序打印每一个字节的字符</span></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= last; count++)</span><br><span class="line">{</span><br><span class="line">    fseek(fp, -count, SEEK_END);</span><br><span class="line">    ch = getc(fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="刷新缓冲区-fflush"><a href="#刷新缓冲区-fflush" class="headerlink" title="刷新缓冲区 fflush()"></a>刷新缓冲区 fflush ()</h3><div class="note "><p>函数名称：fflush<br>函数原型：<code>int fflush(FILE *fp);</code><br>函数作用：调用该函数将刷新缓冲区，即将输出缓冲区中所有的未写入数据被发送到 fp 指定的输出文件。如果 fp 为空指针，所有输出缓冲区都被刷新。<br>返回值：成功返回 0，错误返回 EOF。</p>
</div>

<h3 id="创建替换使用缓冲区-setvbuf"><a href="#创建替换使用缓冲区-setvbuf" class="headerlink" title="创建替换使用缓冲区 setvbuf()"></a>创建替换使用缓冲区 setvbuf ()</h3><div class="note "><p>函数名称：setvbuf<br>函数原型：<code>int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);</code><br>返回值：成功返回 0，否则返回非零值。</p>
</div>

<p>第二个参数指向待使用的缓冲区。如果是 NULL，则自动分配。<br>第三个参数为模式，有下边几种：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_IOFBF</td>
<td align="left"><strong> 全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td align="left">_IOLBF</td>
<td align="left"><strong> 行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td align="left">_IONBF</td>
<td align="left"><strong> 无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody></table>
<h3 id="feof-和-ferror"><a href="#feof-和-ferror" class="headerlink" title="feof() 和 ferror()"></a>feof () 和 ferror ()</h3><p>当上一次输入调用检测到文件结尾时，feof () 函数返回一个非零值，否则返回 0。<br>当读写出现错误，ferror () 函数返回一个非零值，否则返回 0。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>The const and constexpr in C++ (REMAKE)</title>
    <url>/posts/3358bcc1.html</url>
    <content><![CDATA[<p>I have written a post about <code>const</code> in C++ in Chinese before, but <a href="https://blocklune.github.io/posts/7ec6ba38.html">it</a> was too verbose and unclear. :( So, I decided to rewrite it.</p>
<span id="more"></span>

<h2 id="BASIC-USAGE-OF-CONST"><a href="#BASIC-USAGE-OF-CONST" class="headerlink" title="BASIC USAGE OF CONST"></a>BASIC USAGE OF CONST</h2><h3 id="MODIFIES-BASIC-DATE-TYPE-WITH-CONST"><a href="#MODIFIES-BASIC-DATE-TYPE-WITH-CONST" class="headerlink" title="MODIFIES BASIC DATE TYPE WITH CONST"></a>MODIFIES BASIC DATE TYPE WITH CONST</h3><p>The most basic usage of <code>const</code> is to define a constant. A constant is a variable whose value cannot be changed after initialization.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> b = <span class="number">1.0</span>; <span class="comment">// now b is immutable</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// a is a variable. It's okay.</span></span><br><span class="line"><span class="comment">// b = 2.0; // WRONG! b is a constant.</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="MODIFIES-POINTERS-WITH-CONST"><a href="#MODIFIES-POINTERS-WITH-CONST" class="headerlink" title="MODIFIES POINTERS WITH CONST"></a>MODIFIES POINTERS WITH CONST</h3><p>When it comes to pointers, <code>const</code> can be used in two ways: <strong>top-level const</strong> and <strong>low-level const</strong>.</p>
<blockquote>
<p>Top-level const means that the pointer itself is a constant, i.e. you can’t change what it points to.<br>Low-level const means that the object that the pointer points to is a constant, i.e. you can’t change the value of that object through this pointer.</p>
</blockquote>
<p>For example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;x;       <span class="comment">// top-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;x;       <span class="comment">// low-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;x; <span class="comment">// The first is low-level</span></span><br><span class="line">                          <span class="comment">// The second is top-level</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p1 = &amp;y;               // WRONG! p1 is a constant pointer, it can't change its direction.</span></span><br><span class="line">*p1 = y;                  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">p2 = &amp;y;                  <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// *p2 = y;               // WRONG! p2 points at a constant.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p3 = &amp;y;               // WRONG!</span></span><br><span class="line"><span class="comment">// *p3 = y;               // WRONG!</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="MODIFIES-REFERENCE-WITH-CONST"><a href="#MODIFIES-REFERENCE-WITH-CONST" class="headerlink" title="MODIFIES REFERENCE WITH CONST"></a>MODIFIES REFERENCE WITH CONST</h3><p>For reference, there is only one way to use <code>const</code>: <code>const T &amp;</code> (T is type name). Reference itself (like <code>T &amp;</code>) is always top-level, since you can’t change what it refers to after its initialization. So, <code>const T &amp;</code> makes the reference both top-level and low-level.</p>
<h3 id="MODIFIES-OBJECTS-WITH-CONST"><a href="#MODIFIES-OBJECTS-WITH-CONST" class="headerlink" title="MODIFIES OBJECTS WITH CONST"></a>MODIFIES OBJECTS WITH CONST</h3><p>Modifying an object with <code>const</code> means that this object is immutable after its initialization.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::string str = <span class="string">"This is an immutable string."</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="CONST-IN-FUNCTIONS"><a href="#CONST-IN-FUNCTIONS" class="headerlink" title="CONST IN FUNCTIONS"></a>CONST IN FUNCTIONS</h2><h3 id="CONST-IN-PARAMETER-LIST"><a href="#CONST-IN-PARAMETER-LIST" class="headerlink" title="CONST IN PARAMETER LIST"></a>CONST IN PARAMETER LIST</h3><p>A parameter modified with <code>const</code> means it is <strong>read-only</strong> to the function. Usually, we use this feature together with reference. So, when we don’t want a function to change a specific argument, the parameter’s type may look like <code>const T &amp;</code>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  std::string str = <span class="string">"This is an example."</span>;</span><br><span class="line">  <span class="built_in">Show</span>(str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">const</span> T &amp;in)</span> </span>{</span><br><span class="line">  <span class="comment">// in is read-only</span></span><br><span class="line">  std::cout &lt;&lt; in &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="THE-CONST-AFTER-A-MEMBER-FUNCTION"><a href="#THE-CONST-AFTER-A-MEMBER-FUNCTION" class="headerlink" title="THE CONST AFTER A MEMBER FUNCTION"></a>THE CONST AFTER A MEMBER FUNCTION</h3><p>The const after a member function indicates that the function does not modify any non-mutable data members of the class. In other words, this means that the <code>this</code> pointer is const, implying that this member function does not alter the state of this object.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> {</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> weight_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fish</span>() : <span class="built_in">weight_</span>(<span class="number">0</span>) {}</span><br><span class="line">  <span class="built_in">Fish</span>(<span class="type">const</span> <span class="type">double</span>&amp; weight) : <span class="built_in">weight_</span>(weight) {}</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ModifyWeight</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; weight)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ShowWeight</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Just show the weight. Read-only.</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fish::ModifyWeight</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; weight)</span> </span>{ <span class="keyword">this</span>-&gt;weight_ = weight; }</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fish::ShowWeight</span><span class="params">()</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; <span class="keyword">this</span>-&gt;weight_ &lt;&lt; std::endl; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="function">Fish <span class="title">fish</span><span class="params">(<span class="number">5.0</span>)</span></span>;</span><br><span class="line">  fish.<span class="built_in">ShowWeight</span>();</span><br><span class="line">  fish.<span class="built_in">ModifyWeight</span>(<span class="number">10.0</span>);</span><br><span class="line">  fish.<span class="built_in">ShowWeight</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="RETURNS-A-CONST"><a href="#RETURNS-A-CONST" class="headerlink" title="RETURNS A CONST"></a>RETURNS A CONST</h3><p>When returning an object, the <code>const</code> before the return type indicates that this object is a constant and is immutable. For example: <code>const int&amp; GetAgeConst()</code>, which returns a rvalue whose referenced content cannot be modified.</p>
<p>When return a pointer type (or a reference), <code>const</code> helps protect the pointer or reference content from being modified. For example: <code>const char * const Fun()</code>, which returns a pointer to a constant, whose pointed content and the pointer itself cannot be modified.</p>
<p>Here is an example generated by new bing:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> a) : <span class="built_in">age</span>(a) {}</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">GetAgeConst</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> age; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">"The age is "</span> &lt;&lt; p.<span class="built_in">GetAgeConst</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// p.GetAgeConst() = 30; // WRONG</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="CONSTEXPR-NEW-IN-C-11"><a href="#CONSTEXPR-NEW-IN-C-11" class="headerlink" title="CONSTEXPR (NEW IN C++11)"></a>CONSTEXPR (NEW IN C++11)</h2><p><code>constexpr</code> keyword helps the compiler find those constant expressions at compile stage. A really common place of use is defining an array:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetConstexprLen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> variable_len = <span class="number">10</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> const_len = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> constexpr_len = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int arr1[variable_len];    // Illegal. Not OK.</span></span><br><span class="line">  <span class="comment">// int arr2[const_len];       // Illegal. But usually OK.</span></span><br><span class="line">  <span class="type">int</span> arr3[constexpr_len];      <span class="comment">// Legal. OK.</span></span><br><span class="line">  <span class="type">int</span> arr4[<span class="built_in">GetConstexprLen</span>()];  <span class="comment">// Legal. OK.</span></span><br><span class="line">  <span class="type">int</span> arr5[<span class="built_in">Fibonacci</span>(<span class="number">5</span>)];       <span class="comment">// Legal. OK.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetConstexprLen</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="number">10</span>; }</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>{</span><br><span class="line">  <span class="comment">// These codes are from https://changkun.de/modern-cpp/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can't use local variables, loops,</span></span><br><span class="line">  <span class="comment">// and conditional statements here in C++11</span></span><br><span class="line">  <span class="comment">// But in C++14, that's OK.</span></span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">Fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>To learn more, you may read <em><a href="https://changkun.de/modern-cpp/">Modern C++ Tutorial</a></em></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>Uses std::cin.ignore() to keep the user typing until the input meets the requirements</title>
    <url>/posts/f96b3358.html</url>
    <content><![CDATA[<p>I used to control users’ input by making the input a string and process it later. But today, my friend posed this question to me: Can we control input without a char array or string class?</p>
<span id="more"></span>

<p>On <em><a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore">cppreference.com</a></em>, I found <code>std::cin.ignore()</code>. This function can help us solve the previous question. Here is an example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Please input a number: "</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (!std::cin.<span class="built_in">good</span>()) {</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">"Error input."</span> &lt;&lt; std::endl;</span><br><span class="line">      std::cin.<span class="built_in">clear</span>();</span><br><span class="line">      std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Your input is: "</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Const Correctness in C++</title>
    <url>/posts/4eb7504e.html</url>
    <content><![CDATA[<p>This is a note for Lecture 8, <a href="https://web.stanford.edu/class/cs106l/index.html">CS106L</a>, Spring 2023.</p>
<span id="more"></span>

<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>What’s const?</p>
<p><strong>Def.</strong></p>
<ul>
<li><code>const</code>: keyword indicating a variable, function or parameter can’t be modified</li>
</ul>
<p><code>const</code> variables can be references or not.</p>
<p><strong>Ex.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; c_vec{<span class="number">7</span>, <span class="number">8</span>};  <span class="comment">// a const variable</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;&amp; ref = vec;         <span class="comment">// a regular reference</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; c_ref = vec; <span class="comment">// a const reference</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">3</span>);    <span class="comment">// OKAY</span></span><br><span class="line">c_vec.<span class="built_in">push_back</span>(<span class="number">3</span>);  <span class="comment">// BAD - const</span></span><br><span class="line">ref.<span class="built_in">push_back</span>(<span class="number">3</span>);    <span class="comment">// OKAY</span></span><br><span class="line">c_ref.<span class="built_in">push_back</span>(<span class="number">3</span>);  <span class="comment">// BAD - const</span></span><br></pre></td></tr></tbody></table></figure>

<p>Why const?</p>
<p>It helps find out mistakes.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> ((x==<span class="number">2</span> &amp;&amp; y==<span class="number">3</span>) || (x==<span class="number">1</span>)) {</span><br><span class="line">    cout &lt;&lt; <span class="string">'a'</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> ((y==x<span class="number">-1</span>) &amp;&amp; (x==<span class="number">-1</span> || y=<span class="number">-1</span>)) {</span><br><span class="line">    cout &lt;&lt; <span class="string">'b'</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> ((x==<span class="number">3</span>) &amp;&amp; (y==<span class="number">2</span>*x)) {</span><br><span class="line">    cout &lt;&lt; <span class="string">'c'</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Since the variable <code>y</code> is const, <code>y=-1</code> can be found by the compiler.</p>
<h2 id="CONST-AND-CLASSES"><a href="#CONST-AND-CLASSES" class="headerlink" title="CONST AND CLASSES"></a>CONST AND CLASSES</h2><h3 id="INTRODUCTION-OF-CONST-INTERFACE"><a href="#INTRODUCTION-OF-CONST-INTERFACE" class="headerlink" title="INTRODUCTION OF CONST-INTERFACE"></a>INTRODUCTION OF CONST-INTERFACE</h3><p>Recall our <code>Student</code> class:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// student.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string name)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string state;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"student.h"</span></span></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(string name)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">error</span>(<span class="string">"Age cannot be negative!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>What if we use a const <code>Student</code>?</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function">std::string <span class="title">stringify</span><span class="params">(<span class="type">const</span> Student&amp; s)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">getName</span>() + <span class="string">"is"</span> + std::<span class="built_in">to_string</span>(s.<span class="built_in">getAge</span>()) + <span class="string">" years old."</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>It causes compile error! The compiler doesn’t know <code>getName</code> and <code>getAge</code> don’t modify <code>s</code>! We need to promise that it doesn’t by defining them as <strong>const functions</strong>, by adding <code>const</code> to the <strong>end</strong> of function.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// student.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string name)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::string state;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// student.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"student.h"</span></span></span><br><span class="line"><span class="function">std::string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(string name)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">error</span>(<span class="string">"Age cannot be negative!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Def.</strong></p>
<ul>
<li><strong>const-interface</strong>: All member functions marked <code>const</code> in a class definition. Objects of type <code>const ClassName</code> may ONLY use the const-interface.</li>
</ul>
<h3 id="PRACTICE"><a href="#PRACTICE" class="headerlink" title="PRACTICE"></a>PRACTICE</h3><p>Let’s make <code>StrVector</code>‘s const-interface!</p>
<div class="note info"><p>Questions to ask whether a function should be a const-interface:</p>
<ol>
<li>Should this function be able available to a const object?<br>1.1. Can I mark the function const as is (i.e. the function doesn’t modify the object)?<br>1.2. Otherwise, can I make a const version of the function?</li>
</ol>
</div>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVector</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator = std::string*;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> kInitialSize = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// const-interface. Yes</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// const-interface. Yes</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string&amp; elem)</span></span>;</span><br><span class="line">  <span class="function">std::string&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> indx)</span></span>; <span class="comment">// like vec[] but with error checking</span></span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>; <span class="comment">// const-interface?</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;   <span class="comment">// const-interface?</span></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">StrVector::at</span><span class="params">(<span class="type">size_t</span> index)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"Index out of range in at."</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">operator</span>[](index); <span class="comment">// operator[] = return *(begin() + index)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>size()</code> and <code>empty()</code> should be const-interfaces. Of course. What about <code>at()</code>? Seems like <code>at</code> doesn’t modify the vector… can we just mark <code>at</code> const like we did with the other functions?</p>
<p><strong>NO!</strong></p>
<p>The problem is that <code>at</code> returns a reference to an element in the vector. That element reference could be modified (thereby modifying the vector). For example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// StrVector my_vec = { "sarah", "haven" };</span></span><br><span class="line">std::string&amp; elem_ref = my_vec.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line">elem_ref = <span class="string">"Now I'm Different"</span>;</span><br><span class="line"><span class="comment">// my_vec = { "sarah", "Now I'm Different" }</span></span><br></pre></td></tr></tbody></table></figure>

<p>The solution should be adding a const version <code>at</code> function.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> indx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> indx)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>And implement them like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">StrVector::at</span><span class="params">(<span class="type">size_t</span> index)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"Index out of range in at."</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> *(<span class="built_in">begin</span>() + index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">StrVector::at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(</span><br><span class="line">      <span class="built_in">const_cast</span>&lt;StrVector*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">at</span>(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more about <code>static_cast</code> and <code>const_cast</code> <a href="https://blocklune.github.io/posts/f5746381.html">here</a></p>
<p>Should <code>begin()</code> and <code>end()</code> be <code>const</code>?</p>
<p>Consider a function with const <code>StrVector</code> param:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVec</span><span class="params">(<span class="type">const</span> StrVector&amp; vec)</span> </span>{</span><br><span class="line">  cout &lt;&lt; <span class="string">"{ "</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    *it = <span class="string">"dont mind me modifying a const vector :D"</span>;</span><br><span class="line">  }</span><br><span class="line">  cout &lt;&lt; <span class="string">"}"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This code will compile! <code>begin()</code> and <code>end</code> don’t explicitly change <code>vec</code>, but they give us an iterator that can! But, we also need a way to iterate through a const <code>vec</code> just to access it.</p>
<p>The solution is <code>const_iterator</code>:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVector</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator = std::string*;</span><br><span class="line">  <span class="keyword">using</span> const_iterator = <span class="type">const</span> std::string*;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="CONST-ITERATOR-vs-CONST-ITERATOR"><a href="#CONST-ITERATOR-vs-CONST-ITERATOR" class="headerlink" title="CONST ITERATOR vs CONST_ITERATOR"></a>CONST ITERATOR vs CONST_ITERATOR</h3><p>This is tricky!</p>
<table>
<thead>
<tr>
<th>Iterator Type</th>
<th>Increment Iterator?</th>
<th>Change underlying value?</th>
</tr>
</thead>
<tbody><tr>
<td>iterator</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>const_iterator</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>const iterator</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>const const_iterator</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> iterator = std::string*;</span><br><span class="line"><span class="keyword">using</span> const_iterator = <span class="type">const</span> std::string*;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> iterator it_c = vec.<span class="built_in">begin</span>(); <span class="comment">// string * const, const ptr to non-const obj</span></span><br><span class="line">*it_c = <span class="string">"hi"</span>; <span class="comment">// OK! it_c is a const pointer to non-const object</span></span><br><span class="line">it_c++; <span class="comment">// not ok! can't change where a const pointer points!</span></span><br><span class="line"></span><br><span class="line">const_iterator c_it = vec.<span class="built_in">begin</span>(); <span class="comment">// const string*, a non-const ptr to const object</span></span><br><span class="line">c_it++; <span class="comment">// totally ok! The pointer itself is non-const</span></span><br><span class="line">*c_it = <span class="string">"hi"</span>; <span class="comment">// not ok! Can't change underlying const object</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl; <span class="comment">// allowed! Can always read a const object, just can't change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const string * const, const ptr to const obj</span></span><br><span class="line"><span class="type">const</span> const_iterator c_it_c = vec.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; c_it_c &lt;&lt; <span class="string">" points to "</span> &lt;&lt; *c_it_c &lt;&lt; endl; <span class="comment">// only reads are allowed!</span></span><br><span class="line">c_it_c++; <span class="comment">// not ok! can't change where a const pointer points!</span></span><br><span class="line">*c_it_c = <span class="string">"hi"</span>; <span class="comment">// not ok! can't change underlying const object</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="RECAP"><a href="#RECAP" class="headerlink" title="RECAP"></a>RECAP</h2><ul>
<li>Use const parameters and variables wherever you can in application code</li>
<li>Every member function of a class that doesn’t change it member variables should be marked <code>const</code></li>
<li><strong>Don’t reinvent the wheel! Use our fancy <code>static_cast</code>/<code>const_cast</code> trick to use the non-const version to implement a const version of a function</strong></li>
<li><code>auto</code> will drop all <code>const</code> and <code>&amp;</code>, so be sure to specify</li>
<li>Make iterators and const_iterators for all your classes!</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>const</tag>
        <tag>C &amp; C++</tag>
        <tag>CS106L</tag>
      </tags>
  </entry>
  <entry>
    <title>error: summary string parsing error 错误解决方法</title>
    <url>/posts/78dc947f.html</url>
    <content><![CDATA[<p>直接先说解决方法：在使用 clang 工具链进行编译的时候，添加编译选项 <code>-fstandalone-debug</code>。</p>
<span id="more"></span>

<p>下边是完整的发现及解决问题的过程。</p>
<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>在按照 <a href="https://www.bilibili.com/video/BV1sW411v7VZ">《使用 VS Code + Clangd + CMake 搭建 C/C++ 开发环境》</a> 搭建我在 ArchWSL 内的 C/C++ 开发环境时，我创建了一个用于测试的 HelloWorld 工程。这个工程的文件结构长这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── .clang-format</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># @file CMakeLists.txt</span></span><br><span class="line"><span class="comment"># old</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// @file main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    std::string str = <span class="string">"你好"</span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调试的时候发现，int 型变量 a 是可以查看的，但 std::string 型的变量 str 却显示 <code>error: summary string parsing error</code> 错误。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>在测试中我发现，这个问题只在我使用 clang 工具链编译时产生，使用 g++ 就没有这个问题，所以猜测不是 lldb 调试器的问题，而是 clang 编译器的问题。</p>
<p>在网上搜索到了类似的问题：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/ask/sof/1542916">无法在 lldb 中检查 std::string 变量 - 问答 - 腾讯云开发者社区</a></li>
<li><a href="https://github.com/vadimcn/vscode-lldb/issues/415">Cannot inspect any strings · Issue #415 · vadimcn/vscode-lldb</a></li>
</ul>
<p>都说要使用 <code>-fstandalone-debug</code> 重新编译。</p>
<p>于是修改 CMakeLists.txt 为：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># @file CMakeLists.txt</span></span><br><span class="line"><span class="comment"># new</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用的是 clang 工具链，那么需要添加上 -fstandalone-debug，否则 lldb 无法查看 std::string 的东东</span></span><br><span class="line"><span class="comment"># 见 https://cloud.tencent.com/developer/ask/sof/1542916</span></span><br><span class="line"><span class="comment"># 又见 https://github.com/vadimcn/vscode-lldb/issues/415</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-fstandalone-debug)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"optional: -fstandalone-debug"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br></pre></td></tr></tbody></table></figure>

<p>至此成功解决。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>Issue</tag>
        <tag>Solved</tag>
        <tag>Debug</tag>
        <tag>LLDB</tag>
        <tag>LLVM</tag>
        <tag>Clang</tag>
      </tags>
  </entry>
  <entry>
    <title>Move Semantics in C++</title>
    <url>/posts/d5786049.html</url>
    <content><![CDATA[<p>This is a note for Lecture 13, <a href="https://web.stanford.edu/class/cs106l/index.html">CS106L</a>, Spring 2023.</p>
<span id="more"></span>

<h2 id="DEFINITION"><a href="#DEFINITION" class="headerlink" title="DEFINITION"></a>DEFINITION</h2><h3 id="L-VALUE"><a href="#L-VALUE" class="headerlink" title="L-VALUE"></a>L-VALUE</h3><p><strong>l-value</strong> can appear on the <strong>left</strong> or <strong>right</strong> of an <code>=</code>.</p>
<p>For example, here <code>x</code> is an l-value:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> y = x;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>l-values have names</li>
<li>l-values are <strong>not temporary</strong></li>
<li>l-values live until the end of the <strong>scope</strong></li>
</ul>
<h3 id="R-VALUE"><a href="#R-VALUE" class="headerlink" title="R-VALUE"></a>R-VALUE</h3><p><strong>r-value</strong> can ONLY appear on the <strong>right</strong> of an <code>=</code></p>
<p>For example, here <code>3</code> is an r-value:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> y = x;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>r-values don’t have names</li>
<li>r-values are <strong>temporary</strong></li>
<li>r-values live until the end of the <strong>line</strong></li>
</ul>
<h3 id="EXAMPLES"><a href="#EXAMPLES" class="headerlink" title="EXAMPLES"></a>EXAMPLES</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;                       <span class="comment">// 3 is an r-value</span></span><br><span class="line"><span class="type">int</span> *ptr = <span class="number">0x02248837</span>;           <span class="comment">// 0x02248837 is an r-value</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};         <span class="comment">// {1, 2, 3} is an r-value, v1 is an l-value</span></span><br><span class="line"><span class="keyword">auto</span> v4 = v1 + v2;               <span class="comment">// v1 + v2 is an r-value</span></span><br><span class="line"><span class="type">size_t</span> size = v.<span class="built_in">size</span>();          <span class="comment">// v.size() is an r-value</span></span><br><span class="line">v1[<span class="number">1</span>] = <span class="number">4</span> * i;                   <span class="comment">// 4 * i is an r-value, v1[1] is an l-value</span></span><br><span class="line">ptr = &amp;x;                        <span class="comment">// &amp;x is an r-value</span></span><br><span class="line">v1[<span class="number">2</span>] = *ptr;                    <span class="comment">// *ptr is an l-value</span></span><br><span class="line">MyClass obj;                     <span class="comment">// obj is an l-value</span></span><br><span class="line">x = obj.public_member_variable;  <span class="comment">// obj.public_member_variable is l-value</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="MOVE-SEMANTICS"><a href="#MOVE-SEMANTICS" class="headerlink" title="MOVE SEMANTICS"></a>MOVE SEMANTICS</h2><p>In our generic <code>vector</code> class, we have a vector copy assignment operator like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp; other) {</span><br><span class="line">  <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _size = other._size;</span><br><span class="line">  _capacity = other._capacity;</span><br><span class="line">  <span class="keyword">delete</span>[] _elems;</span><br><span class="line">  _elems = <span class="keyword">new</span> T[other._capacity];</span><br><span class="line">  std::<span class="built_in">copy</span>(other._elems, other._elems + other._size, _elems);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>Aside: <code>std::copy</code> is a generic copy function used to copy a range of elements from one container to another.</em></p>
<p>And in the code fragment below:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  vec = <span class="built_in">make_me_a_vec</span>(<span class="number">123</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>vec</code> is created using the <strong>default constructor</strong></li>
<li><code>make_me_a_vec</code> creates a vector using the <strong>default constructor</strong></li>
<li><code>vec</code> is reassigned to a <strong>copy</strong> of that return value using <strong>copy assignment</strong></li>
<li><strong>copy assignment</strong> creates a new array and <strong>copies</strong> the contents of the old one</li>
<li>The original return value’s lifetime ends and it calls its <strong>destructor</strong></li>
<li><code>vec</code>‘s lifetime ends and it calls its <strong>destructor</strong></li>
</ul>
<p>Here is a problem: <code>make_me_a_vec(123)</code> is an r-value, and in <code>vector&lt;T&gt;::operator=(const vector&lt;T&gt;&amp; other)</code>, <code>other</code> should be an l-value (referenced using &amp;). Can r-values be bound to <code>const &amp;</code>?</p>
<p>The answer is Yes.</p>
<p>Another problem is that, we creates a vector, copies its content to another and deleted it. Can we do better?</p>
<p>We can use <strong>move assignment</strong> like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;T&gt;&amp; vector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp; other) {</span><br><span class="line">  <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _size = other._size;</span><br><span class="line">  _capacity = other._capacity;</span><br><span class="line">  _elems = other._elems; <span class="comment">// we don't copy in this version</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>But what about this?</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;string&gt; vec1 = {<span class="string">"hello"</span>, <span class="string">"world"</span>};</span><br><span class="line">  vector&lt;string&gt; vec2;</span><br><span class="line">  vec2 = vec1;</span><br><span class="line">  vec1.<span class="built_in">push_back</span>(<span class="string">"Sure hope vec2 doesn't see this!"</span>);</span><br><span class="line">} <span class="comment">// BAD!</span></span><br></pre></td></tr></tbody></table></figure>

<p>A problem occurs here!<strong>We need both a copy assignment AND a move assignment.</strong></p>
<p>How do we know when to use move assignment and when to use copy assignment?</p>
<p><strong>When the item on the right of the = is an r-value we should use move assignment.</strong></p>
<p>Why? r-values are always about to die, so we can steal their resources.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  vec = <span class="built_in">make_me_a_vec</span>(<span class="number">123</span>); <span class="comment">// using move assignment</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;string&gt; vec1 = {<span class="string">"hello"</span>, <span class="string">"world"</span>};</span><br><span class="line">  vector&lt;string&gt; vec2;</span><br><span class="line">  vec2 = vec1; <span class="comment">// using copy assignment</span></span><br><span class="line">  vec1.<span class="built_in">push_back</span>(<span class="string">"Sure hope vec2 doesn't see this!"</span>);</span><br><span class="line">} <span class="comment">// and vec2 never saw a thing</span></span><br></pre></td></tr></tbody></table></figure>

<p>And now the question is: how to make two different assignment operator?</p>
<p>Answer: Overload <code>vector::operator=</code>!</p>
<p>Introducing… the r-value reference using <code>&amp;&amp;</code></p>
<h2 id="R-VALUE-REFERENCE"><a href="#R-VALUE-REFERENCE" class="headerlink" title="R-VALUE REFERENCE"></a>R-VALUE REFERENCE</h2><p>By using r-value reference, we can do this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">change</span>(x); <span class="comment">// this will call version 2</span></span><br><span class="line">  <span class="built_in">change</span>(<span class="number">7</span>); <span class="comment">// this will call version 1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span>&amp;&amp; num)</span> </span>{...} <span class="comment">// version 1 takes r-values</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>{...}  <span class="comment">// version 2 takes l-values</span></span><br><span class="line"><span class="comment">// num is a reference to int</span></span><br></pre></td></tr></tbody></table></figure>

<p>So, we should keep our copy assignment:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp; other) {</span><br><span class="line">  <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _size = other._size;</span><br><span class="line">  _capacity = other._capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// must **copy** entire array</span></span><br><span class="line">  <span class="keyword">delete</span>[] _elems;</span><br><span class="line">  _elems = <span class="keyword">new</span> T[other._capacity];</span><br><span class="line">  std::<span class="built_in">copy</span>(other._elems, other._elems + other.size, _elems);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>And overload <code>vector::operator=</code> (move assignment) like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(vector&lt;T&gt;&amp;&amp; other) {</span><br><span class="line">  <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _size = other._size;</span><br><span class="line">  _capacity = other._capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we can **steal** the array</span></span><br><span class="line">  <span class="keyword">delete</span>[] _elems;</span><br><span class="line">  _elems = other._elems;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>But actually, we still copy <code>_size</code> and <code>_capacity</code>, etc.</p>
<p>Introducing…<code>std::move</code>!</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><ul>
<li><code>std::move(x)</code> <strong>doesn’t do anything</strong> except <strong>cast x as an r-value</strong></li>
<li>It is a way to force C++ to choose the <code>&amp;&amp;</code> version of a function</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">change</span>(x);             <span class="comment">// this will call version 2</span></span><br><span class="line">  <span class="built_in">change</span>(std::<span class="built_in">move</span>(x));  <span class="comment">// this will call version 1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span>&amp;&amp; num)</span> </span>{...} <span class="comment">// version 1 takes r-values</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>{...}  <span class="comment">// version 2 takes l-values</span></span><br></pre></td></tr></tbody></table></figure>

<p>We can modify our move assignment like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(vector&lt;T&gt;&amp;&amp; other) {</span><br><span class="line">  <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _size = std::<span class="built_in">move</span>(other._size);          <span class="comment">// force move assignment</span></span><br><span class="line">  _capacity = std::<span class="built_in">move</span>(other._capacity);  <span class="comment">// force move assignment</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// we can **steal** the array</span></span><br><span class="line">  <span class="keyword">delete</span>[] _elems;</span><br><span class="line">  _elems = std::<span class="built_in">move</span>(other._elems);        <span class="comment">// force move assignment</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This works!</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  vec = <span class="built_in">make_me_a_vec</span>(<span class="number">123</span>); <span class="comment">// this will use move assignment</span></span><br><span class="line">  vector&lt;string&gt; vec1 = {<span class="string">"hello"</span>, <span class="string">"world"</span>};</span><br><span class="line">  vector&lt;string&gt; vec2;</span><br><span class="line">  vec2 = vec1; <span class="comment">// this will use copy assignment</span></span><br><span class="line">  vec1.<span class="built_in">push_back</span>(<span class="string">"Sure hope vec2 doesn't see this!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>However, what if we wanted to declare and initialize a vec on the same line?</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  vec = <span class="built_in">make_me_a_vec</span>(<span class="number">123</span>); <span class="comment">// this will use move assignment</span></span><br><span class="line">  vector&lt;string&gt; vec1 = {<span class="string">"hello"</span>, <span class="string">"world"</span>};</span><br><span class="line">  vector&lt;string&gt; vec2 = vec1; <span class="comment">// this will use copy constructor</span></span><br><span class="line">  vec1.<span class="built_in">push_back</span>(<span class="string">"Sure hope vec2 doesn't see this!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Similarly, <code>vector&lt;string&gt; vec1 = {"hello", "world"};</code> will use <strong>move constructor</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;(vector&lt;T&gt;&amp;&amp; other) {</span><br><span class="line">  <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _size = std::<span class="built_in">move</span>(other._size);</span><br><span class="line">  _capacity = std::<span class="built_in">move</span>(other._capacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we can steal the array</span></span><br><span class="line">  <span class="keyword">delete</span>[] _elems;</span><br><span class="line">  _elems = std::<span class="built_in">move</span>(other._elems);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Where else should we use <code>std::move</code>?</p>
<blockquote>
<p>Rule of Thumb:<br>Wherever we take in a <code>const &amp;</code> parameter in a class member function and assign it to something else in our function<br>(TO BE CONTINUED)</p>
</blockquote>
<p>For example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// copy push_back</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>{</span><br><span class="line">  elems[_size++] = element;</span><br><span class="line">  <span class="comment">// this is copy assignment</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// move push_back</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; element)</span> </span>{</span><br><span class="line">  elems[_size++] = std::<span class="built_in">move</span>(element);</span><br><span class="line">  <span class="comment">// this forces T's move assignment</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Be careful with <code>std::move</code></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  vector&lt;string&gt; vec1 = {<span class="string">"hello"</span>, <span class="string">"world"</span>};</span><br><span class="line">  vector&lt;string&gt; vec2 = std::<span class="built_in">move</span>(vec1);</span><br><span class="line">  vec1.<span class="built_in">push_back</span>(<span class="string">"Sure hope vec2 doesn't see this!"</span>); <span class="comment">// WRONG</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Rule of Thumb:<br>Wherever we take in a <code>const &amp;</code> parameter in a class member function and assign it to something else in our function<br>Don’t use <code>std::move</code> outside of class definitions, never use it in application code!</p>
</blockquote>
<h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><ul>
<li><p>If your class has <strong>copy constructor</strong> and <strong>copy assignment</strong> defined, you should also define a <strong>move constructor</strong> and <strong>move assignment</strong></p>
</li>
<li><p>Define these by overloading your copy constructor and assignment to be defined for <code>Type&amp;&amp; other</code> as well as <code>Type&amp; other</code></p>
</li>
<li><p>Use <code>std::move</code> to force the use of other types’ move assignments and constructors</p>
</li>
<li><p>All <code>std::move(x)</code> does is cast <code>x</code> as an r-value</p>
</li>
<li><p>By wary of <code>std::move(x)</code> in main function code!</p>
</li>
</ul>
<h2 id="PHILOSOPHY-about-SMFs"><a href="#PHILOSOPHY-about-SMFs" class="headerlink" title="PHILOSOPHY about SMFs"></a>PHILOSOPHY about SMFs</h2><h3 id="The-6-Special-Member-Functions"><a href="#The-6-Special-Member-Functions" class="headerlink" title="The 6 Special Member Functions"></a>The 6 Special Member Functions</h3><ol>
<li><strong>Default constructor</strong>: Initializes an object to a default state</li>
<li><strong>Copy constructor</strong>: Creates a new object by copying an existing object</li>
<li><strong>Move constructor</strong>: Creates a new object by moving the resources of an existing object</li>
<li><strong>Copy Assignment Operator</strong>: Assigns the contents of one object to another object</li>
<li><strong>Move Assignment Operator</strong>: Moves the resources of one object to another object</li>
<li><strong>Destructor</strong>: Frees any dynamically allocated resources owned by an object when it is destroyed</li>
</ol>
<h3 id="Some-Philosophy-about-SMFs"><a href="#Some-Philosophy-about-SMFs" class="headerlink" title="Some Philosophy about SMFs"></a>Some Philosophy about SMFs</h3><p>There are three guiding rules:</p>
<h4 id="Rule-of-Zero"><a href="#Rule-of-Zero" class="headerlink" title="Rule of Zero"></a>Rule of Zero</h4><ul>
<li><strong>If you can avoid defining default operations, do</strong></li>
<li><strong>Why?</strong> It’s the simplest and gives the cleanest semantic</li>
<li><strong>Example:</strong> Since <code>std::map</code> and <code>std::string</code> have all the special functions, no further work is needed.</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Class Named_map {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...no default operations declared</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rep;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Named_map nm;      <span class="comment">// default construct</span></span><br><span class="line">Named_map nm2{nm}; <span class="comment">// copy construct</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Rule-of-Three"><a href="#Rule-of-Three" class="headerlink" title="Rule of Three"></a>Rule of Three</h4><ul>
<li><strong>If you need to implement a custom destructor, you almost certainly need to define a copy constructor and copy assignment operator</strong></li>
<li><strong>Why?</strong> You are probably managing your own memory somehow, so the shallow copies provided by the default operations won’t work correctly</li>
</ul>
<h4 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h4><ul>
<li><strong>If you define custom copy constructor/assignment operator, you should define move constructor/assignment operator as well</strong></li>
<li><strong>Why?</strong> This is about efficiency rather than correctness. It’s inefficient to make extra copies (although it’s “correct”)</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>CS106L</tag>
      </tags>
  </entry>
  <entry>
    <title>My personal summay of Stanford CS106L</title>
    <url>/posts/b16dfec9.html</url>
    <content><![CDATA[<p>This is <a href="https://web.stanford.edu/class/cs106l/index.html">CS106L</a>, an in-depth modern C++ language course from Stanford. I enrolled in it at the beginning of April and almost finished it today.</p>
<span id="more"></span>

<p>This class is amazing. It covers so many interesting and exciting features of modern C++ that I do not get a chance to learn in my school C++ class, including initialization lists, STL containers and algorithms, lambda expressions, templates, all the six SMFs, move semantics, r-value reference, cpp-style casting (static_cast/const_cast), smart pointers, RAII, etc. These make the code modern and robust! These are the real C++ things!</p>
<p>I learnt this course from the website. This is actually not an open source course. I can’t find the lecture videos and notes. What I am able to read are only the slides. Every week there are two lectures on Tuesday and Thursday. The slides are updated on the website the next day and I download them to my tab. They are not very clear so what I have learnt is really superficial. There are two assignments, I tried to finish the second locally, but the online submission system is only open to Stanford students, so… I don’t really know what level I’m at. But, on the plus side, at least I am learning the direction I should go.</p>
<p>If you also want to learn more about modern C++, give this course a try.</p>
<p><img data-src="https://s1.ax1x.com/2023/06/01/p9zRyPP.png" alt="Website of the course"></p>
<p><img data-src="https://s1.ax1x.com/2023/06/01/p9zRgxS.png" alt="Assignment 2"></p>
<p><img data-src="https://s1.ax1x.com/2023/06/01/p9zRRKg.jpg" alt="Slides in my Samsung Note"></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>Online course summary</tag>
        <tag>C &amp; C++</tag>
        <tag>CS106L</tag>
      </tags>
  </entry>
  <entry>
    <title>static_cast and const_cast in C++</title>
    <url>/posts/f5746381.html</url>
    <content><![CDATA[<p>This is a note for Lecture 8, <a href="https://web.stanford.edu/class/cs106l/index.html">CS106L</a>, Spring 2023.</p>
<span id="more"></span>

<p>In a class like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVector</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator = std::string*;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> kInitialSize = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string&amp; elem)</span></span>;</span><br><span class="line">  <span class="function">std::string&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> indx)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> indx)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>We implement the non-const <code>at</code> method like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">StrVector::at</span><span class="params">(<span class="type">size_t</span> index)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"Index out of range in at."</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> *(<span class="built_in">begin</span>() + index);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>It is bad to reimplement the same logic when writing the const version of the <code>at</code> method.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">StrVector::at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) {</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"Index out of range in at."</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> *(<span class="built_in">cbegin</span>() + index);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Instead, we should do this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">StrVector::at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(</span><br><span class="line">      <span class="built_in">const_cast</span>&lt;StrVector*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">at</span>(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>So, what’s <code>static_cast</code> and <code>const_cast</code>?</p>
<p><strong>static_cast&lt;new-type&gt;(expression)</strong> is used to convert from one type to another. For example: <code>int my_int = static_cast&lt;int&gt;(3.1)</code>. Note that it CANNOT BE USED WHEN conversion would cast away constness.</p>
<p>Learn more <a href="https://en.cppreference.com/w/cpp/language/static_cast">here</a></p>
<p><strong>const_cast&lt;new-type&gt;(expression)</strong> is used to cast away (remove) constness. It allows you to make non-const pointer or reference to const-object like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> const_int = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span>&amp; my_int = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(const_int);</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more <a href="https://en.cppreference.com/w/cpp/language/const_cast">here</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>const</tag>
        <tag>CS106L</tag>
      </tags>
  </entry>
  <entry>
    <title>Type Safety and std::optional in C++</title>
    <url>/posts/ab76f233.html</url>
    <content><![CDATA[<p>This is a note for Lecture 14, <a href="https://web.stanford.edu/class/cs106l/index.html">CS106L</a>, Spring 2023.</p>
<span id="more"></span>

<h2 id="RECAP-CONST-CORRECTNESS"><a href="#RECAP-CONST-CORRECTNESS" class="headerlink" title="RECAP: CONST-CORRECTNESS"></a>RECAP: CONST-CORRECTNESS</h2><ul>
<li>We pass big pieces of data <strong>by reference</strong> into helper functions by to avoid making copies of that data</li>
<li>If this function accidentally or sneakily changes that piece of data, it can lead to hard to find bugs!</li>
<li><strong>Solution</strong>: mark those reference parameters <code>const</code> to guarantee they won’t be changed in function</li>
</ul>
<p>How does the compiler know when it’s safe to call member functions of <code>const</code> variables?</p>
<p><strong>Def.</strong></p>
<ul>
<li><strong>const-interface</strong>: All member functions marked <code>const</code> in a class definition. Objects of type <code>const ClassName</code> may only use the const-interface.</li>
</ul>
<p><strong>Ex.</strong></p>
<p><code>RealVector</code>‘s const-interface</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">ValueType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealVector</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator = ValueType*;</span><br><span class="line">  <span class="keyword">using</span> const_iterator = <span class="type">const</span> ValueType*;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// const-interface</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// const-interface</span></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> ValueType&amp; elem)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// const-interface</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// const-interface</span></span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>KeyIdea.</strong></p>
<blockquote>
<p>Sometimes <strong>less</strong> functionality is <strong>better</strong> functionality</p>
</blockquote>
<ul>
<li>Technically, adding a const-interface only <strong>limits</strong> what <code>RealVector</code> objects marked <code>const</code> can do</li>
<li>Using types to enforce assumptions we make about function calls help us prevent programmer errors!</li>
</ul>
<h2 id="TYPE-SAFETY"><a href="#TYPE-SAFETY" class="headerlink" title="TYPE SAFETY"></a>TYPE SAFETY</h2><p><strong>Def.</strong></p>
<ul>
<li><strong>Type Safety</strong>: The extent to which a language prevents typing errors and <strong>guarantees the behavior of programs</strong></li>
</ul>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p>Let’s look at the code below:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeOddsFromEnd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (vec.<span class="built_in">back</span>() % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><em>Aside:</em><br><em><code>vector::back()</code> returns a reference to the last element in the vector</em><br><em><code>vector::pop_back()</code> is like the opposite of <code>vector::push_back(elem)</code>. It removes the last element from the vector</em></p>
<p>What happens when input is {}? It causes <strong>undefined behavior</strong>. Function could crash, could give us garbage, could accidentally give us some actual value.</p>
<p>We can make NO guarantees about this function does!</p>
<p>One solution to the issue above is:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeOddsFromEnd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (!vec.<span class="built_in">empty</span>() &amp;&amp; vec.<span class="built_in">back</span>() % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>KeyIdea.</strong></p>
<p>It’s the <strong>programmers’ job</strong> to enforce the <strong>precondition</strong> that <code>vec</code> be non-empty, otherwise we get undefined behavior!</p>
<h3 id="GO-DEEP"><a href="#GO-DEEP" class="headerlink" title="GO DEEP"></a>GO DEEP</h3><p>The problem here is, there may or may not be a “last element” in <code>vec</code>. How can <code>vec.back()</code> have deterministic behavior in either case?</p>
<p>Can this work?</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// WRONG</span></span><br><span class="line">valueType&amp; vector&lt;valueType&gt;::<span class="built_in">back</span>() {</span><br><span class="line">  <span class="keyword">return</span> *(<span class="built_in">begin</span>() + <span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>NO! Dereferencing a pointer without verifying it points to real memory is undefined behavior!</p>
<p>A solution is:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">valueType&amp; vector&lt;valueType&gt;::<span class="built_in">back</span>() {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">empty</span>()) <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(); <span class="comment">// check if empty first</span></span><br><span class="line">  <span class="keyword">return</span> *(<span class="built_in">begin</span>() + <span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Now, we will at least reliably error and stop the program <strong>or</strong> return the last element whenever <code>back()</code> is called.</p>
<p>Can we do better? Can <code>vec.back()</code> <strong>warn us</strong> if there may not be a “last element” when we call it?</p>
<p><strong>Def.</strong></p>
<ul>
<li><strong>Type Safety</strong>: The extent to which a <strong>function signature</strong> guarantees the behavior of a <strong>function</strong></li>
</ul>
<p>A solution is:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::pair&lt;<span class="type">bool</span>, valueType&amp;&gt; vector&lt;valueType&gt;::<span class="built_in">back</span>() {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">empty</span>()) <span class="keyword">return</span> { <span class="literal">false</span>, <span class="built_in">valueType</span>() };</span><br><span class="line">  <span class="keyword">return</span> { <span class="literal">true</span>, *(<span class="built_in">begin</span>() + <span class="built_in">size</span>() - <span class="number">1</span>) };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>back()</code> now advertises that there may or may not be a last element.</p>
<p>But this solution causes other problems:</p>
<ul>
<li><code>valueType</code> may not have a default constructor</li>
<li>Even if it does, calling constructors is <strong>expensive</strong></li>
</ul>
<p>What should <code>back()</code> return?</p>
<p>Introducing…<code>std::optional</code></p>
<h3 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h3><p>What is <code>std::optional&lt;T&gt;</code>?</p>
<ul>
<li><code>std::optional</code> is a template class which will either contain a value of type T or contain nothing (expressed as <code>nullopt</code>)</li>
</ul>
<div class="note warning"><p>Pay attention to <code>nullopt</code>! That’s NOT <code>nullptr</code>!</p>
<ul>
<li><code>nullptr</code>: an object that can be converted to a value of any <strong>pointer</strong> type</li>
<li><code>nullopt</code>: an object that can be converted to a value of any <strong>optional</strong> type</li>
</ul>
</div>

<p>Look at the code below:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  std::optional&lt;<span class="type">int</span>&gt; num1 = {};  <span class="comment">// num1 does not have a value</span></span><br><span class="line">  num1 = <span class="number">1</span>;                      <span class="comment">// now it does!</span></span><br><span class="line">  num1 = std::<span class="literal">nullopt</span>;           <span class="comment">// now it doesn't anymore</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// {} and std::nullopt can be used interchangeable</span></span><br></pre></td></tr></tbody></table></figure>

<p>With <code>std::optional</code>, we can make <code>back()</code> return an optional:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::optional&lt;valueType&gt; vector&lt;valueType&gt;::<span class="built_in">back</span>() {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">empty</span>()) {</span><br><span class="line">    <span class="keyword">return</span> {};</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> *(<span class="built_in">begin</span>() + <span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>To use this version of <code>back()</code>, let’s first look at some of <code>std::optional</code>‘s interfaces:</p>
<ul>
<li><code>.value()</code> returns the contained value or throws <code>bad_optional_access</code> error</li>
<li><code>.value_or(valueType val)</code> returns the contained value or default value, parameter <code>val</code></li>
<li><code>.has_value()</code> returns <code>true</code> if contained value exists, <code>false</code> otherwise</li>
</ul>
<p>We can do it like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeOddsFromEnd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (vec.<span class="built_in">back</span>().<span class="built_in">has_value</span>() &amp;&amp; vec.<span class="built_in">back</span>().<span class="built_in">value</span>() % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This will no longer error, but it is pretty unwieldy :/</p>
<p>Let’s do this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeOddsFromEnd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (vec.<span class="built_in">back</span>() &amp;&amp; vec.<span class="built_in">back</span>().<span class="built_in">value</span>() % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Is this…good?</p>
<p>Pros of using <code>std::optional</code> returns:</p>
<ul>
<li>Function signatures create more informative contracts</li>
<li>Class function calls have guaranteed and usable behavior</li>
</ul>
<p>Cons:</p>
<ul>
<li>You will need to use <code>.value()</code> EVERYWHERE</li>
<li>(In cpp) It’s still possible to do a <code>bad_optional_access</code></li>
<li>(In cpp) optionals can have undefined behavior too (*optional does same thing as <code>.value()</code> with no error checking)</li>
<li>In a lot of cases we want <code>std::optional&lt;T&amp;&gt;</code>… which we don’t have</li>
</ul>
<p>Why even bother with optionals?</p>
<p>Introducing… <code>std::optional</code> “monadic” interface (C++23)</p>
<ul>
<li><code>.and_then(function f)</code> returns the result of calling <code>f(value)</code> if contained value exists, otherwise <code>nullopt</code> (<code>f</code> must return <code>optional</code>)</li>
<li><code>.transform(function f)</code> returns the result of calling <code>f(value)</code> if contained value exists, otherwise <code>nullopt</code> (<code>f</code> must return <code>optional&lt;valueType&gt;</code>)</li>
<li><code>.or_else(function f)</code> returns value if it exists, otherwise returns result of calling <code>f</code></li>
</ul>
<p><strong>Def.</strong></p>
<ul>
<li><p><strong>Monadic</strong>: a software design pattern with a structure that combines program fragments (functions) and wraps their return values in a type with additional computation</p>
</li>
<li><p>These all let you try a function and will either return the result of the computation or some default value.</p>
</li>
</ul>
<p><strong>Ex.</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeOddsFromEnd</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">  <span class="keyword">auto</span> isOdd = [](optional&lt;<span class="type">int</span>&gt; num) {</span><br><span class="line">    <span class="keyword">return</span> num ? (num % <span class="number">2</span> == <span class="number">1</span>) : {};</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">while</span> (vec.<span class="built_in">back</span>().<span class="built_in">and_then</span>(isOdd)) {</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Disclaimer:</strong> <code>std::vector::back()</code> doesn’t actually return an optional (and probably never will)</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>CS106L</tag>
      </tags>
  </entry>
  <entry>
    <title>一个有关指针传参的问题</title>
    <url>/posts/50c16b14.html</url>
    <content><![CDATA[<p>这是我学习指针过程中遇到的一个问题，问过大佬才似乎懂了点，在此记录。顺便记下一句大佬说的话：</p>
<blockquote>
<p>注意到一点就行，指针其实也就是个存了内存地址的变量，<strong>它本身同时也具有内存地址</strong>。</p>
</blockquote>
<span id="more"></span>

<h2 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h2><p>事情是这样，学习了一点指针，就想自己实现一个会自动变长的数组。我也不期望把它做成一个类什么的，只有一个小目标，就是实现一个函数，能往这个动态数组后边加元素。我本来的 <strong>错误</strong> 代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (nums) <span class="comment">// 如果数组指针不为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 暂存原来的数据</span></span><br><span class="line">        <span class="type">int</span> *tmp_nums = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_nums, nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        <span class="comment">// 释放掉原指针</span></span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">        <span class="comment">// 元素数量 + 1</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(nums, tmp_nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        nums[size] = n;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp_nums;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> tmp_n;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *nums = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        tmp_n = i;</span><br><span class="line">        <span class="built_in">append</span>(nums, size, tmp_n);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt;nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在调试过程中发现一直会报 <code>Segmentation fault</code>，但是如果改成下边这样，却是可以的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *nums = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (nums) <span class="comment">// 如果数组指针不为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 暂存原来的数据</span></span><br><span class="line">        <span class="type">int</span> *tmp_nums = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_nums, nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        <span class="comment">// 释放掉原指针</span></span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">        <span class="comment">// 元素数量 + 1</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(nums, tmp_nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        nums[size] = n;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp_nums;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> tmp_n;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        tmp_n = i;</span><br><span class="line">        <span class="built_in">append</span>(size, tmp_n);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt;nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>改动的内容就是把原来的数组变成了全局的。局部的不正常，全局就对了，所以猜测，类似是形参和实参的区别。大佬们帮我分析了分析，提出了下边的解决方案：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> **, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> tmp_n;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *nums = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        tmp_n = i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        nums 是一个指针，这个指针是我们动态数组的第一个元素的地址</span></span><br><span class="line"><span class="comment">        对 nums 取地址传参，传的是 nums 这个指针的地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">append</span>(&amp;nums, size, tmp_n);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt;nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接上文的注释</span></span><br><span class="line"><span class="comment">ptr 是一个指针，这个指针是上边的 nums 的地址</span></span><br><span class="line"><span class="comment">*ptr 得到了这个地址的值，这个值是指向动态数组第一个元素的指针</span></span><br><span class="line"><span class="comment">**ptr 是第一个元素的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> **ptr, <span class="type">int</span> size, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (*ptr) <span class="comment">// 如果数组指针不为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 暂存原来的数据</span></span><br><span class="line">        <span class="type">int</span> *tmp_nums = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_nums, *ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        <span class="comment">// 释放掉原指针</span></span><br><span class="line">        <span class="keyword">delete</span>[] * ptr;</span><br><span class="line">        <span class="comment">// 元素数量 + 1</span></span><br><span class="line">        *ptr = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(*ptr, tmp_nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        (*ptr)[size] = n;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp_nums;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        (*ptr) = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">        (*ptr)[<span class="number">0</span>] = n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样运行结果就正常了。</p>
<h2 id="分析及解决方案"><a href="#分析及解决方案" class="headerlink" title="分析及解决方案"></a>分析及解决方案</h2><p><strong>2022 年 11 月 16 日更新：</strong>这边写的错误原因有点乱，我重新写了一篇：<a href="https://blocklune.github.io/posts/1ef1e20b.html">《当形参、实参是指针变量…》</a></p>
<p>下边给出两个简化的代码来解释这个问题。</p>
<p>首先来看代码 1，是对上边错误代码的简化:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMemory</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt;<span class="string">"The pointer in getMemory() points at:"</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">"The address of the pointer in getMemory():"</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">getMemory</span>(p);</span><br><span class="line">    cout &lt;&lt;<span class="string">"The pointer in main() points at:"</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">"The address of the pointer in main():"</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下边是代码 1 对应的程序的一个可能的输出 (具体内存地址可能不同):</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">The pointer in getMemory() points at: 0x10161c0</span><br><span class="line">The address of the pointer in getMemory(): 0x61fdf0</span><br><span class="line">The pointer in main() points at: 0x10</span><br><span class="line">The address of the pointer in main(): 0x61fe18</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，在 <code>getMemory()</code> 中的 <code>int*</code> 类型的指针 p 与 <code>main()</code> 中的 <code>int*</code> 类型的指针 p <strong>并不是同一个指针</strong>（存储这两个指针的内存地址不一样，在 <code>getMemory()</code> 中的指针 p 存储在 0x61fdf0，而 <code>main()</code> 中的存储在 0x61fe18），所以虽然我们在 <code>getMemory()</code> 中 new 得了存储空间（<code>getMemory()</code> 中的指针 p 指向了 0x10161c0），但这实际上只是为 <code>getMemory()</code> 中的指针 p 申请了存储空间，<code>main()</code> 中的指针 p 并没有申请到空间（<code>main()</code> 中的指针 p 指向了 0x10）。</p>
<p>也即，我们自己的函数中的指针是一个副本，给这个指针申请空间的操作并没有实现给 <code>main()</code> 中的同名指针也申请到空间！</p>
<p>接着是代码 2，类似于上边的正确解法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMemory2</span><span class="params">(<span class="type">int</span> **p2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The pointer in getMemory() points at:"</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of the pointer in getMemory():"</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p1;</span><br><span class="line">    <span class="built_in">getMemory2</span>(&amp;p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"The pointer in main() points at:"</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of the pointer in main():"</span> &lt;&lt; &amp;p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下边是代码 2 对应的程序的一个可能的输出 (具体内存地址可能不同):</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">The pointer in getMemory() points at: 0x7461c0</span><br><span class="line">The address of the pointer in getMemory(): 0x61fe18</span><br><span class="line">The pointer in main() points at: 0x7461c0</span><br><span class="line">The address of the pointer in main(): 0x61fe18</span><br></pre></td></tr></tbody></table></figure>

<p>从 <code>main()</code> 开始看，p1 是一个 <code>int*</code> 类型的指针。与上边代码 1 不同，现在 <code>getMemory2()</code> 这个函数接受的参数是指针的指针，也就是指针的地址，所以我们传入的是 <strong>&amp;p1</strong>，也就是指针 p1 的地址。</p>
<p>再看 <code>getMemory2()</code> 函数，传入参数后，相当于现在 p2 = &amp;p1，那么 *p2 = p1。这里的 “=” 表示 “就是” 而非赋值，所以我们对于 *p2 进行的任何操作，与对 p1 进行的操作都是等效的。</p>
<p>还有一种解决方案 —— 使用引用传递，对于上边的问题也就是使用 <code>int* &amp;</code> 类型，代码 3 如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMemory</span><span class="params">(<span class="type">int</span> *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The pointer in getMemory() points at: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of the pointer in getMemory(): "</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">getMemory</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"The pointer in main() points at: "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of the pointer in main(): "</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只要将上边的代码 1 中 <code>void getMemory(int *p)</code> 改为 <code>void getMemory(int *&amp;p)</code> 就行了，下边是可能的输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">The pointer in getMemory() points at: 0x10261c0</span><br><span class="line">The address of the pointer in getMemory(): 0x61fe18</span><br><span class="line">The pointer in main() points at: 0x10261c0</span><br><span class="line">The address of the pointer in main(): 0x61fe18</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到已经实现了我们想要的效果。</p>
<p>也可以参考参考这篇文章：<a href="https://developer.aliyun.com/article/297093">《C++ 函数的传入参数是指针的指针（**）的详解》</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Issue</tag>
        <tag>Solved</tag>
        <tag>Pointer</tag>
        <tag>pass by pointer</tag>
        <tag>pass by value</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组到底是啥啊...</title>
    <url>/posts/57fd79a.html</url>
    <content><![CDATA[<p>一维数组还是比较容易理解的，但是二维数组，我始终没弄清楚这玩意儿是按照什么规则从二维的样子转成一维然后存起来的，也因此常常犯下下标写反了的错误。我觉得是时候详细地理一理这玩意儿到底是个啥了…</p>
<span id="more"></span>

<h2 id="怎么转成了一维？"><a href="#怎么转成了一维？" class="headerlink" title="怎么转成了一维？"></a>怎么转成了一维？</h2><p>要知道二维数组到底是怎么转成了一维存在内存里，或者说，我到底是应该从前往后（前面的一个数字先不动，先让后边的数字动）读这个数组，还是从后往前（后面的一个数字先不动，先让前面的数字动）读这个数组，其实方法很简单 —— 我们只要把数组里每个元素的地址输出来就行了。比如下边这串代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="string">"&amp;a["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span></span><br><span class="line">                 &lt;&lt; <span class="string">"["</span> &lt;&lt; j &lt;&lt; <span class="string">"] = "</span> &lt;&lt; &amp;a[i][j] &lt;&lt; <span class="string">" "</span> &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可能的输出如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&amp;a[0][0] = 0x61fe00</span><br><span class="line">&amp;a[0][1] = 0x61fe04</span><br><span class="line">&amp;a[0][2] = 0x61fe08</span><br><span class="line">&amp;a[1][0] = 0x61fe0c</span><br><span class="line">&amp;a[1][1] = 0x61fe10</span><br><span class="line">&amp;a[1][2] = 0x61fe14</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，正确的读法应该是：<strong>从前往后，前面的保持不动，从最后一个开始变化。</strong></p>
<p>也就是说，对于 <code>a[2][3]</code> 这样一个数组，应该这么理解：<code>a[2][3]</code> 前面的 <code>[2]</code> 表示这是一个包含两个元素的数组，后面的 <code>[3]</code> 表示前面所说的两个元素每一个都是包含三个元素的数组。</p>
<h2 id="赋初值的一些问题"><a href="#赋初值的一些问题" class="headerlink" title="赋初值的一些问题"></a>赋初值的一些问题</h2><p>知道了上边的东西，所以我们知道，我们可以写一个类似 <code>int a[][3] = {0,0,0,0,0,0};</code> 的玩意儿，却不能写一个 <code>int a[2][] = {0,0,0,0,0,0}</code> 的玩意儿 —— 相当于第二个方括号里边是告诉了编译器后边这一串数字按几个为一组，由于 <code>{}</code> 中元素个数不足是会往后边自动补零的，所以少了这个每组几个的参数，编译器就不知道你这到底有多少个元素了。</p>
<h2 id="用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？"><a href="#用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？" class="headerlink" title="用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？"></a>用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？</h2><p>类似上边的赋初值时候的问题，这个动态的二维数组的内层，也就是按几个为一组的那一层，必须是已经确定的，例如，我们依然创建一个 2*3 的二维数组，其中前面的 2 是在运行时确定的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span>(*p)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">int</span>[n][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            p[i][j] = now;</span><br><span class="line">            now++;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            cout &lt;&lt; p[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></tbody></table></figure>

<h2 id="能不能用-int-p-来创建一个两个维度都能变化的二维数组？"><a href="#能不能用-int-p-来创建一个两个维度都能变化的二维数组？" class="headerlink" title="能不能用 int** p 来创建一个两个维度都能变化的二维数组？"></a>能不能用 int** p 来创建一个两个维度都能变化的二维数组？</h2><p>不知道啊就是说…</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Pointer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>值传递、指针传递、引用传递</title>
    <url>/posts/c8a20144.html</url>
    <content><![CDATA[<p>接上文<a href="https://blocklune.github.io/posts/50c16b14.html">《一个有关指针传参的问题》</a>，打算结合一些简单的例子系统地梳理一下 C/C++ 中的值传递、指针传递和 C++ 中特有的 引用传递。</p>
<span id="more"></span>

<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p><strong>值传递</strong>传递实际上只是在执行函数的时候将实参的值赋给了形参，在此之后函数体内对形参的任何操作都与原来的实参无关了。</p>
<p>例如下边这个代码 1:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递 (C++代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value of n in func(): "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of n in func(): "</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    n++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Then the value of n in func(): "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value of n in main(): "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of n in main(): "</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Then the value of n in main(): "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递 (C代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The value of n in func(): %d\n"</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The address of n in func(): 0x%x\n"</span>, &amp;n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then the value of n in func(): %d\n"</span>, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The value of n in main(): %d\n"</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The address of n in main(): 0x%x\n"</span>, &amp;n);</span><br><span class="line">    func(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then the value of n in main(): %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下边是可能的输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">The value of n in main(): 0</span><br><span class="line">The address of n in main(): 0x61fe1c</span><br><span class="line">The value of n in func(): 0</span><br><span class="line">The address of n in func(): 0x61fdf0</span><br><span class="line">Then the value of n in func(): 1</span><br><span class="line">Then the value of n in main(): 0</span><br></pre></td></tr></tbody></table></figure>

<p>第二行第四行说明，<code>main()</code> 中的实参 n 与 <code>func()</code> 中的形参 n 存储在内存的不同位置，不是同一个变量。第五第六行说明，对形参 n 的操作，不会影响实参 n。</p>
<h2 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h2><p><strong>指针传递</strong>也就是传参时不直接传某个参数的值，而是传它的地址。把这个地址作为实参，而形参又是复制实参而来的，所以形参也是原来参数的地址，这样再对形参解除引用，实际上就是对同一内存的值进行操作，所以当然在自定函数中的操作会在主函数中反映出来，请看下边的代码 2：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 指针传递 (C++代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value of n(*p) in func(): "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of n(p) in func(): "</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Then the value of n(*p) in func(): "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value of n in main(): "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of n in main(): "</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(&amp;n); <span class="comment">// 把想要传递的参数的地址作为实参传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Then the value of n in main(): "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 指针传递 (C代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The value of n(*p) in func(): %d\n"</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The address of n(p) in func(): 0x%x\n"</span>, p);</span><br><span class="line">    (*p)++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then the value of n(*p) in func(): %d\n"</span>, *p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The value of n in main(): %d\n"</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The address of n in main(): 0x%x\n"</span>, &amp;n);</span><br><span class="line">    func(&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then the value of n in main(): %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下边是可能的输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">The value of n in main(): 0</span><br><span class="line">The address of n in main(): 0x61fe1c</span><br><span class="line">The value of n(*p) in func(): 0</span><br><span class="line">The address of n(p) in func(): 0x61fe1c</span><br><span class="line">Then the value of n(*p) in func(): 1</span><br><span class="line">Then the value of n in main(): 1</span><br></pre></td></tr></tbody></table></figure>

<p>这实际上就是 <a href="https://blocklune.github.io/posts/50c16b14.html#%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">《一个有关指针传参的问题》- 分析及解决分案</a> 中的代码 2 的思路。只不过这里我们是对 <code>int</code> 类型的普通变量操作，所以函数接受的参数类型是 <code>int*</code>，而在那篇文章中是要对 <code>int*</code> 类型的变量操作，所以自定函数接受的参数类型变成了 <code>int**</code>。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2>

<article class="message message-immersive is-warning">
<div class="message-body">
<i class="fas fa-exclamation-triangle mr-2"></i>
注意引用传递是 C++ 的特性，C 没有这个特性。
</div>
</article>


<p><strong>引用传递</strong>相当于给实参取了个别名，对形参的操作会同步到实参那边去，还是来看下边的代码 3 吧：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 引用传递 (C++代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;n2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value of n2 in func(): "</span> &lt;&lt; n2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of n2 in func(): "</span> &lt;&lt; &amp;n2 &lt;&lt; endl;</span><br><span class="line">    n2++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Then the value of n2 in func(): "</span> &lt;&lt; n2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value of n1 in main(): "</span> &lt;&lt; n1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The address of n1 in main(): "</span> &lt;&lt; &amp;n1 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Then the value of n1 in main(): "</span> &lt;&lt; n1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下边是可能的输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">The value of n1 in main(): 0</span><br><span class="line">The address of n1 in main(): 0x61fe1c</span><br><span class="line">The value of n2 in func(): 0</span><br><span class="line">The address of n2 in func(): 0x61fe1c</span><br><span class="line">Then the value of n2 in func(): 1</span><br><span class="line">Then the value of n1 in main(): 1</span><br></pre></td></tr></tbody></table></figure>

<p>类似地，<code>int</code> 类型的引用类型是 <code>int&amp;</code>，<code>int*</code> 的引用类型是 <code>int*&amp;</code>。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="https://www.jianshu.com/p/2b5594b876ef">C++ 值传递、指针传递、引用传递 - 简书 (jianshu.com)</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/dingxiaoqiang/p/8012578.html">C++ 值传递、指针传递、引用传递详解 - zqlucky - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pass by pointer</tag>
        <tag>pass by value</tag>
        <tag>pass by reference</tag>
      </tags>
  </entry>
  <entry>
    <title>当形参、实参是指针变量...</title>
    <url>/posts/1ef1e20b.html</url>
    <content><![CDATA[<p>接<a href="https://blocklune.github.io/posts/50c16b14.html">《一个有关指针传参的问题》</a>，再理一理这里边的一些问题…</p>
<span id="more"></span>

<p>在单向值传递的过程中，我们知道，形参是对实参的值的拷贝。在实参的值传递给形参后，对形参的一切操作，都不会对实参产生什么影响。比如下边这串代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Before func(), main(): n = "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="string">"After func(), main(): n = "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Before n++, func(): n = "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    n++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"After n++, func(): n = "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下边是输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Before func(), main(): n = 5</span><br><span class="line">Before n++, func(): n = 5</span><br><span class="line">After n++, func(): n = 6</span><br><span class="line">After func(), main(): n = 5</span><br></pre></td></tr></tbody></table></figure>

<p>通过打印它们的地址，我们也可以认识到这一点：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"In main(): "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"n = "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"&amp;n = "</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"In func(): "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"n = "</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"&amp;n = "</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In main():</span></span><br><span class="line"><span class="comment">n = 5</span></span><br><span class="line"><span class="comment">&amp;n = 0x61fe1c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In func():</span></span><br><span class="line"><span class="comment">n = 5</span></span><br><span class="line"><span class="comment">&amp;n = 0x61fdf0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果把变量类型从普通类型变成指针类型，那么类似的，发生的其实也是一次值传递，也即，<strong>指针变量的值发生了一次拷贝</strong>，请看下边的例子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"In main(): "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"p = "</span> &lt;&lt; (<span class="type">int</span> *)p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"&amp;p = "</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"In func(): "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"p = "</span> &lt;&lt; (<span class="type">int</span> *)p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"&amp;p = "</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在我电脑上的输出结果是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">In main():</span><br><span class="line">p = 0xee61c0</span><br><span class="line">&amp;p = 0x61fe18</span><br><span class="line"></span><br><span class="line">In func():</span><br><span class="line">p = 0xee61c0</span><br><span class="line">&amp;p = 0x61fdf0</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，<code>int *</code> 类型的指针变量 <code>p</code> 的值是相同的，但地址不同，这是两个变量。</p>
<p>把上边代码 <code>main()</code> 中的 <code>p</code> 记为 <code>p1</code>，<code>func()</code> 中的记为 <code>p2</code>，那么就可以这样理解为，当调用 <code>func()</code> 时，<code>p2</code> 与 <code>p1</code> <strong>指向了相同的位置</strong>，但它们确实<strong>不是同一个指针</strong>。</p>
<p>对于<a href="https://blocklune.github.io/posts/50c16b14.html">《一个有关指针传参的问题》</a>中的那段错误代码，其实错误就是，在函数中 <code>new</code> 出来内存后，只是让形参指向了那片内存，而原来的实参并没有同步地指过去。</p>
<p>但是只要确定形参的指针和实参的指针指向的地址是相同的，那么对这同一片内存进行的操作，就是同步的，比如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Before func(), main(): (*p) = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"After func(), main(): (*p) = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Before (*p)++, func(): (*p) = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"After (*p)++, func(): (*p) = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Before func(), main(): (*p) = 5</span><br><span class="line">Before (*p)++, func(): (*p) = 5</span><br><span class="line">After (*p)++, func(): (*p) = 6</span><br><span class="line">After func(), main(): (*p) = 6</span><br></pre></td></tr></tbody></table></figure>

<p>由于数组名其实就是数组第一个元素（下标为 0 的那个元素）的地址，所以类似的，在函数中对数组形参的操作会等效到数组实参上去：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>[], <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(a, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i]++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0 1 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>补记一个用 C++ 实现的 2048 小游戏</title>
    <url>/posts/10d14c30.html</url>
    <content><![CDATA[<p>校科协的加入有条件，面试前一步是笔试。免去笔试的方法也不是没有，可以做免试题。看了各个组的免试题，发现都好难好难，只有前端组的 2048 敢去尝试尝试。但我有没怎么学过 JS，便想着先用 C++ 实现一下逻辑，再把代码改过去。</p>
<span id="more"></span>

<h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><p>引用免试题中的原话：</p>
<blockquote>
<p>在一个 4 * 4 大小共计 16 个的方格中，初始时会有随机两个方格出现 2 / 4 ，每次通过 方向键 控制所有方块向同一个方向运动，两个相同数字的方块撞在一起之后合并成为他们的和，每次操作之后会在空白的方格处随机生成一个 2 或者 4 ，当最终得到一个 2048 的方块时即获得游戏胜利。如果 16 个格子全部填满并且相邻的格子都不相同也就是无法移动的话，那么 Game Over 。</p>
</blockquote>
<p><del>写这篇博客的时候才发现原来还有” 当最终得到一个 2048 的方块时即获得游戏胜利” 这句话，我并没有实现这个就是说。</del></p>
<h2 id="C-源代码"><a href="#C-源代码" class="headerlink" title="C++ 源代码"></a>C++ 源代码</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> box_c[<span class="number">4</span>][<span class="number">4</span>]; <span class="comment">// 运算用 box_content</span></span><br><span class="line"><span class="comment">// short box_s[4][4]; // 显示用 box_show</span></span><br><span class="line"><span class="type">bool</span> map[<span class="number">4</span>][<span class="number">4</span>]; <span class="comment">// 用于表示是否发生过合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([0][0])  ([0][1])  ([0][2])  ([0][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([1][0])  ([1][1])  ([1][2])  ([1][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([2][0])  ([2][1])  ([2][2])  ([2][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([3][0])  ([3][1])  ([3][2])  ([3][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomNum</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 这里不能srand，不然就会生成出来都是同一个随机数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTwoOrFour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRandomNum</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateNewNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>;)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> possibleI = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> possibleJ = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (box_c[possibleI][possibleJ] == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            box_c[possibleI][possibleJ] = <span class="built_in">getTwoOrFour</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空map</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">map_refresh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            map[i][j] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始全部赋值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">            map[i][j] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 随机找两个位置填充2或者4</span></span><br><span class="line">    <span class="comment">/* for (int i = 0; i &lt; 2;)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        int possibleI = getRandomNum(0, 3);</span></span><br><span class="line"><span class="comment">        int possibleJ = getRandomNum(0, 3);</span></span><br><span class="line"><span class="comment">        if (box_c[possibleI][possibleJ] == 0)</span></span><br><span class="line"><span class="comment">        {</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">            box_c[possibleI][possibleJ] = getTwoOrFour();</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    } */</span></span><br><span class="line">    <span class="comment">// 直接用这个函数生成两个得了</span></span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本来想显示运算分离的，后来感觉好像没啥必要</span></span><br><span class="line"><span class="comment">/* void refreshShow()</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 4; i++)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; 4; j++)</span></span><br><span class="line"><span class="comment">        {</span></span><br><span class="line"><span class="comment">            box_s[i][j] = box_c[i][j];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">} */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; box_c[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; box_s[i][j] &lt;&lt; " ";</span></span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                {</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == box_c[i][j] &amp;&amp; map[i - <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] *= <span class="number">2</span>;</span><br><span class="line">                map[i - <span class="number">1</span>][j] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                {</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (box_c[i + <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i + <span class="number">1</span>][j] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                {</span><br><span class="line">                    box_c[k][j] = box_c[k - <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (box_c[i + <span class="number">1</span>][j] == box_c[i][j] &amp;&amp; map[i + <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i + <span class="number">1</span>][j] *= <span class="number">2</span>;</span><br><span class="line">                map[i + <span class="number">1</span>][j] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                {</span><br><span class="line">                    box_c[k][j] = box_c[k - <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveLeft</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i][j - <span class="number">1</span>] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将右边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                {</span><br><span class="line">                    box_c[i][k] = box_c[i][k + <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j - <span class="number">1</span>] == box_c[i][j] &amp;&amp; map[i][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i][j - <span class="number">1</span>] *= <span class="number">2</span>;</span><br><span class="line">                map[i][j - <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将右边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                {</span><br><span class="line">                    box_c[i][k] = box_c[i][k + <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveRight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i][j + <span class="number">1</span>] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将左边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                {</span><br><span class="line">                    box_c[i][k] = box_c[i][k - <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j + <span class="number">1</span>] == box_c[i][j] &amp;&amp; map[i][j + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i][j + <span class="number">1</span>] *= <span class="number">2</span>;</span><br><span class="line">                map[i][j + <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将右边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                {</span><br><span class="line">                    box_c[i][k] = box_c[i][k - <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// https://www.runoob.com/w3cnote/c-get-keycode.html</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (_kbhit())</span><br><span class="line">        {                      <span class="comment">//如果有按键按下，则_kbhit()函数返回真</span></span><br><span class="line">            <span class="type">int</span> ch = _getch(); <span class="comment">//使用_getch()函数获取按下的键值</span></span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">119</span>: <span class="comment">// w</span></span><br><span class="line">                <span class="built_in">moveUp</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">97</span>: <span class="comment">// a</span></span><br><span class="line">                <span class="built_in">moveLeft</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">115</span>: <span class="comment">// s</span></span><br><span class="line">                <span class="built_in">moveDown</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>: <span class="comment">// d</span></span><br><span class="line">                <span class="built_in">moveRight</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">27</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="comment">//当按下ESC时结束</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="代码阅读与分析"><a href="#代码阅读与分析" class="headerlink" title="代码阅读与分析"></a>代码阅读与分析</h2><h3 id="4-4-方格的构建"><a href="#4-4-方格的构建" class="headerlink" title="4*4 方格的构建"></a>4*4 方格的构建</h3><p>我创建了 <code>box_c</code> 这个二维数组来构建了下面这样一个棋盘来存放数据。数据值为 0 表示这个格子空着，非零则是对应数字。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([0][0])  ([0][1])  ([0][2])  ([0][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([1][0])  ([1][1])  ([1][2])  ([1][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([2][0])  ([2][1])  ([2][2])  ([2][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([3][0])  ([3][1])  ([3][2])  ([3][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外还有 <code>map</code> 这个二维数组，我放到后边说。</p>
<h3 id="生成新的数字"><a href="#生成新的数字" class="headerlink" title="生成新的数字"></a>生成新的数字</h3><p>因为要在 4*4 的方格内随机生成 2 或者 4，所以首先就先做一个随机数生成器。</p>
<p>首先引入两个库：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>

<p><code>&lt;cstdlib&gt;</code> 提供了 <code>srand()</code> 和 <code>rand()</code> 函数。</p>
<p><code>srand()</code> 接受一个用于初始化的随机数” 种子”。 一般我们就用当前时间 <code>time(0)</code> 作为种子。（这就是为什么我们需要引入 <code>&lt;ctime&gt;</code> 这个库。 ）</p>
<p><code>rand()</code> 函数会产生一个 [0,RAND_MAX] 范围内的整数。通过一些算式，我们可以人为构造一些式子来实现生成需求范围内的随机数。下表展示了一些式子。</p>
<table>
<thead>
<tr>
<th>目标类型及范围</th>
<th>表达式</th>
</tr>
</thead>
<tbody><tr>
<td> [0,n) 内的整数</td>
<td> rand() % n</td>
</tr>
<tr>
<td>[a,b) 内的整数</td>
<td> (rand() % (b-a)) + a</td>
</tr>
<tr>
<td>[a,b] 内的整数</td>
<td> (rand() % (b-a+1)) + a</td>
</tr>
<tr>
<td>(a,b] 内的整数</td>
<td> (rand() % (b-a)) + a + 1</td>
</tr>
<tr>
<td>0～1 之间的浮点数</td>
<td> rand() / double(RAND_MAX)</td>
</tr>
</tbody></table>
<p>还有一个通用公式：a + rand () % n。</p>
<p>其中的 a 是起始值，n 是整数的范围。 </p>


<article class="message is-danger">
<div class="message-body">

<p>注意！<code>srand()</code> 用于初始化，<strong>只需要初始化一次</strong>。所以，你的获取随机数函数应该长得像这样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomNum</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getRandomNum</span>(<span class="number">1</span>,<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而不是这样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomNum</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getRandomNum</span>(<span class="number">1</span>,<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>错误的写法会导致快速生成随机数时每次返回的都是随机数序列的第一个…</strong> （可能是程序运行速度很快种子都是一样的结果）。</p>

</div>
</article>


<p>接着我定义了 <code>getTwoOrFour()</code> 和 <code>generateNewNum()</code> 函数。前者用于随机生成 2/4，不必多说。后者用于在 4*4 方格内随机放上一个数字，首先生成行列坐标，如果检查到这个格子空的，可以生成在这，那就生成，结束该函数的运行，否则进行下一次尝试。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTwoOrFour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRandomNum</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateNewNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>;)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> possibleI = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> possibleJ = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (box_c[possibleI][possibleJ] == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            box_c[possibleI][possibleJ] = <span class="built_in">getTwoOrFour</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化主要就是两方面：一方面是初始化随机数种子；另一方面是清空棋盘（其实还有清空 map 标记），然后随机找两个位置放上 2 或者 4。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始全部赋值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        {</span><br><span class="line">            box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">            map[i][j] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 随机找两个位置填充2或者4</span></span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="移动与合并"><a href="#移动与合并" class="headerlink" title="移动与合并"></a>移动与合并</h3>
<article class="message is-danger">
<div class="message-body">
注意这里的移动与合并算法可能不是最优解，可能比较低效，甚至可能有错误。仅供参考。
</div>
</article>


<p>移动无非就是上下左右，彼此之间比较类似。这里以向上移动为例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                {</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == box_c[i][j] &amp;&amp; map[i - <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] *= <span class="number">2</span>;</span><br><span class="line">                map[i - <span class="number">1</span>][j] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                {</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先因为是向上移动，所以先拆分一下上边的二维数组，拆成四列。第一层 <code>j</code> 的循环就是列的循环。</p>
<p>在某一列中，我想从下往上考虑：如果上面一个格子是 0 ，那我就把现在这个格子里的数字上移；如果这个位置和上边位置的数一样，我就让上边位置的数乘二，然后下边位置赋 0。不断从下往上扫描直到能移动的全部移动，能合并的全部合并。</p>
<p>但是有个问题是，每次移动各个数字只能发生一次合并！如果这个数字合并过了，那它就不应该再合并了。比如四个 2, 移动一次应该产生两个 4 而非 1 个 8。</p>
<p>所以我创建了一个 <code>map</code> ，用于标识已经发生的合并。并且取消掉了之前的不断的从上到下的扫描，改为了如果发生了一次移动或者合并，即给当前格子进行了赋 0 操作的话，我就把下边的所有格子往上移动一次。</p>
<p>总结一下思路：如果以 0,1,2,3 从上往下标识这一列格子。我从 3 往上扫描到 1 ，如果发现当前格子是 0，也即上边格子空着，我就把这个格子开始下边的所有格子往上移动一位；类似的，如果发现上边格子和当前格子可以合并，并且查询 <code>map</code> 发现这两个格子里边的数字在这轮移动中都没有发生过合并，那就合并，并也将下边格子的内容全部往上移动。</p>
<p>当四列都结束后，便用 <code>generateNewNum()</code> 填充一个新数字，并且清空 <code>map</code> 的状态。</p>
<h3 id="结束检测"><a href="#结束检测" class="headerlink" title="结束检测"></a>结束检测</h3><p>这个 C++ 代码中这块并没有实现，不过最后的 Web 版本是实现了的。借一下那边的代码讲一下思路吧。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">ifEnd</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"正在检测游戏是否结束！"</span>);</span><br><span class="line">            <span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) {</span><br><span class="line">                    <span class="comment">// 如果有空位，说明必定可以继续</span></span><br><span class="line">                    <span class="keyword">if</span> (box_c[i][j] == <span class="number">0</span>) {</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"检测到游戏仍然有空位，游戏继续！"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 为0则说明没有空位了</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"检测到游戏没有空位了，下面检测是否有可合并方块！"</span>);</span><br><span class="line">                <span class="keyword">var</span> flag2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {</span><br><span class="line">                        <span class="keyword">if</span> ((box_c[i][j] == box_c[i][j + <span class="number">1</span>]) || (box_c[i][j] == box_c[i + <span class="number">1</span>][j])) {</span><br><span class="line">                            flag2 = <span class="number">1</span>;</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"检测到可合并方块，游戏继续！"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (flag2 == <span class="number">1</span>) {</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 最后一列单独检测</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">                    <span class="keyword">if</span> (box_c[i][<span class="number">3</span>] == box_c[i + <span class="number">1</span>][<span class="number">3</span>]) {</span><br><span class="line">                        flag2 = <span class="number">1</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"检测到可合并方块，游戏继续！"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 最后一行单独检测</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (box_c[<span class="number">3</span>][j] == box_c[<span class="number">3</span>][j + <span class="number">1</span>]) {</span><br><span class="line">                        flag2 = <span class="number">1</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"检测到可合并方块，游戏继续！"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (flag2 == <span class="number">0</span>) {</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"检测到游戏无空位且无法继续移动，游戏结束！"</span>);</span><br><span class="line">                    <span class="title function_">alert</span>(<span class="string">'游戏结束，即将重新开始！'</span>);</span><br><span class="line">                    location.<span class="title function_">reload</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>游戏结束的标志是两个：一是没有空格子了，二是任意相邻格子没有相同数字不可能发生合并了。</p>
<p>所以首先就是扫描所有格子看看有没有空格子。如果没有格子，就开始扫描相邻格子是否有相同数字。我的扫描方法是从 (0,0) 到 (2,2) 都只检测它的右方和下方是否与它相同，然后再单独检测一下最右边一列前三个元素的下一个和最下边一行前三个元素的右边一个是否与它们自己相同。如果也没有相同的了，那就 Game Over 。</p>
<h3 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h3><p>直接看参考资料《C/C++ 获取键盘事件》吧…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/xiaokang01/p/9786751.html">《C++ 产生随机数》</a><br><a href="https://www.runoob.com/w3cnote/c-get-keycode.html">《C/C++ 获取键盘事件》</a><br>… …</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>C &amp; Cpp</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Useful packages in Java</title>
    <url>/posts/a4746c9.html</url>
    <content><![CDATA[<p>A simple conclusion of some useful packages in java.</p>
<span id="more"></span>

<h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/package-summary.html">java.io</a></h2><h3 id="Classification-by-type-of-stream"><a href="#Classification-by-type-of-stream" class="headerlink" title="Classification by type of stream"></a>Classification by type of stream</h3><h4 id="Stream-of-characters"><a href="#Stream-of-characters" class="headerlink" title="Stream of characters"></a>Stream of characters</h4><h5 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedReader.html">BufferedReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/InputStreamReader.html">InputStreamReader</a><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileReader.html">FileReader</a></li>
</ul>
</li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/StringReader.html">StringReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedReader.html">PipedReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/CharArrayReader.html">CharArrayReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FilterReader.html">FilterReader</a><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PushbackReader.html">PushbackReader</a></li>
</ul>
</li>
</ul>
<h5 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedWriter.html">BufferedWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/OutputStreamWriter.html">OutputStreamWriter</a><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileWriter.html">FileWriter</a></li>
</ul>
</li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PrintWriter.html">PrinterWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/StringWriter.html">StringWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedWriter.html">PipedWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/CharArrayWriter.html">CharArrayWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FilterWriter.html">FilterWriter</a></li>
</ul>
<h4 id="Stream-of-bytes"><a href="#Stream-of-bytes" class="headerlink" title="Stream of bytes"></a>Stream of bytes</h4><h5 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileInputStream.html">FileInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FilterInputStream.html">FilterInputStream</a><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedInputStream.html">BufferedInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/DataInputStream.html">DataInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PushbackInputStream.html">PushbackInputStream</a></li>
</ul>
</li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ObjectInputStream.html">ObjectInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedInputStream.html">PipedInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/SequenceInputStream.html">SequenceInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/StringBufferInputStream.html">StringBufferInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ByteArrayInputStream.html">ByteArrayInputStream</a></li>
</ul>
<h5 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileOutputStream.html">FileOutputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FilterOutputStream.html">FilterOutputStream</a><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedOutputStream.html">BufferedOutputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/DataOutputStream.html">DataOutputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PrintStream.html">PrintStream</a></li>
</ul>
</li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ObjectOutputStream.html">ObjectOutputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedOutputStream.html">PipedOutputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ByteArrayOutputStream.html">ByteArrayOutputStream</a></li>
</ul>
<h3 id="Classification-by-operation-object"><a href="#Classification-by-operation-object" class="headerlink" title="Classification by operation object"></a>Classification by operation object</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileReader.html">FileReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileWriter.html">FileWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileInputStream.html">FileInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/FileOutputStream.html">FileOutputStream</a></li>
</ul>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><h5 id="ByteArray"><a href="#ByteArray" class="headerlink" title="ByteArray"></a>ByteArray</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ByteArrayInputStream.html">ByteArrayInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ByteArrayOutputStream.html">ByteArrayOutputStream</a></li>
</ul>
<h5 id="CharArray"><a href="#CharArray" class="headerlink" title="CharArray"></a>CharArray</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/CharArrayReader.html">CharArrayReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/CharArrayWriter.html">CharArrayWriter</a></li>
</ul>
<h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedReader.html">PipedReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedWriter.html">PipedWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedInputStream.html">PipedInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PipedOutputStream.html">PipedOutputStream</a></li>
</ul>
<h4 id="Data-basic-data-types"><a href="#Data-basic-data-types" class="headerlink" title="Data (basic data types)"></a>Data (basic data types)</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/DataInputStream.html">DataInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/DataOutputStream.html">DataOutputStream</a></li>
</ul>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedReader.html">BufferedReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedWriter.html">BufferedWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedInputStream.html">BufferedInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/BufferedOutputStream.html">BufferedOutputStream</a></li>
</ul>
<h4 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PrintWriter.html">PrinterWriter</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/PrintStream.html">PrintStream</a></li>
</ul>
<h4 id="Object-serialization"><a href="#Object-serialization" class="headerlink" title="Object serialization"></a>Object serialization</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ObjectInputStream.html">ObjectInputStream</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/ObjectOutputStream.html">ObjectOutputStream</a></li>
</ul>
<h4 id="Stream-transformation"><a href="#Stream-transformation" class="headerlink" title="Stream transformation"></a>Stream transformation</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/InputStreamReader.html">InputStreamReader</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/io/OutputStreamWriter.html">OutputStreamWriter</a></li>
</ul>
<h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/package-summary.html">java.lang</a></h2><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Process.html">Process</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ProcessBuilder.html">ProcessBuilder</a></li>
</ul>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Thread.html">Thread</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ThreadGroup.html">ThreadGroup</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ThreadDeath.html">ThreadDeath</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ThreadLocal.html">ThreadLocal</a></li>
</ul>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Runnable.html">Runnable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/runtime/package-summary.html">Runtime</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/RuntimePermission.html">RuntimePermission</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html">System</a></li>
</ul>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/StackTraceElement.html">StackTraceElement</a></li>
</ul>
<h4 id="Exception-Throwable"><a href="#Exception-Throwable" class="headerlink" title="Exception - Throwable"></a>Exception - <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Throwable.html">Throwable</a></h4><h5 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NoClassDefFoundError.html">NoClassDefFoundError</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NoSuchFieldError.html">NoSuchFieldError</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/OutOfMemoryError.html">OutOfMemoryError</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NoSuchMethodError.html">NoSuchMethodError</a></li>
</ul>
<h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html">ArrayIndexOutOfBoundsException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ClassCastException.html">ClassCastException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/ClassNotFoundException.html">ClassNotFoundException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/IllegalArgumentException.html">IllegalArgumentException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/IndexOutOfBoundsException.html">IndexOutOfBoundsException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NoSuchFieldError.html">NoSuchFieldException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NoSuchMethodError.html">NoSuchMethodException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NullPointerException.html">NullPointerException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/NumberFormatException.html">NumberFormatException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/RuntimeException.html">RuntimeException</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/InterruptedException.html">InterruptedException</a></li>
</ul>
<h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>java.lang</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Deprecated.html">Deprecated</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/FunctionalInterface.html">FunctionalInterface</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Override.html">Override</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/SafeVarargs.html">SafeVarargs</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/SuppressWarnings.html">SuppressWarnings</a></li>
</ul>
<p>java.lang.annotation</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/Documented.html">Documented</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/Inherited.html">Inherited</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/Native.html">Native</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/Repeatable.html">Repeatable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/Retention.html">Retention</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/Target.html">Target</a></li>
</ul>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>java.lang</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/AutoCloseable.html">AutoCloseable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/annotation/package-summary.html">Annotation</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/CharSequence.html">CharSequence</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Cloneable.html">Cloneable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Comparable.html">Comparable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Iterable.html">Iterable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Readable.html">Readable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Runnable.html">Runnable</a></li>
</ul>
<p>java.lang.reflect</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/InvocationHandler.html">InvocationHandler</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/GenericDeclaration.html">GenericDeclaration</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/AnnotatedElement.html">AnnotatedElement</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Member.html">Member</a></li>
</ul>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><h4 id="Basic-type"><a href="#Basic-type" class="headerlink" title="Basic type"></a>Basic type</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Boolean.html">Boolean</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Character.html">Character</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/String.html">String</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Number.html">Number</a><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Byte.html">Byte</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Short.html">Short</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Integer.html">Integer</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Long.html">Long</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Float.html">Float</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Double.html">Double</a></li>
</ul>
</li>
</ul>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Class.html">Class</a></li>
</ul>
<h4 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Package.html">Package</a></li>
</ul>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html">Object</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Enum.html">Enum</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Void.html">Void</a></li>
</ul>
<h3 id="Tool-class"><a href="#Tool-class" class="headerlink" title="Tool class"></a>Tool class</h3><h4 id="Character-serial"><a href="#Character-serial" class="headerlink" title="Character serial"></a>Character serial</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/StringBuffer.html">StringBuffer</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/StringBuilder.html">StringBuilder</a></li>
</ul>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Math.html">java.lang.Math</a></li>
</ul>
<p>NOTICE: not java.math</p>
<h3 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h3><p>java.lang.reflect</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Array.html">Array</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Constructor.html">Constructor</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Field.html">Field</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Method.html">Method</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Proxy.html">Proxy</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/Executable.html">Executable</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/reflect/AccessibleObject.html">AccessibleObject</a></li>
</ul>
<h2 id="java-math"><a href="#java-math" class="headerlink" title="java.math"></a>java.math</h2><p>NOTICE: not java.lang.Math</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigDecimal.html">BigDecimal</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html">BigInteger</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/MathContext.html">MathContext</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/RoundingMode.html">RoundingMode</a></li>
</ul>
<h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2><p>java.net</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Permutations and Combinations in Python (itertools)</title>
    <url>/posts/cf2f01b2.html</url>
    <content><![CDATA[<p>Extracted from <em><a href="https://docs.python.org/3/library/itertools.html">itertools — Functions creating iterators for efficient looping — Python 3.11.3 documentation</a></em></p>
<span id="more"></span>

<h2 id="PERMUTATIONS"><a href="#PERMUTATIONS" class="headerlink" title="PERMUTATIONS"></a>PERMUTATIONS</h2><p><code>itertools.permutations(iterable, r=None)</code> returns successive <code>r</code> length permutations of elements in the iterable.</p>
<p>If <code>r</code> is not specified or is <code>None</code>, then <code>r</code> defaults to the length of the iterable and all possible full-length permutations are generated.</p>
<p><strong>Ex.1.</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations(a):</span><br><span class="line">  <span class="built_in">print</span>(p)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">(1, 2, 3)</span><br><span class="line">(1, 3, 2)</span><br><span class="line">(2, 1, 3)</span><br><span class="line">(2, 3, 1)</span><br><span class="line">(3, 1, 2)</span><br><span class="line">(3, 2, 1)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Ex.2.</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line">a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations(a, <span class="number">2</span>):</span><br><span class="line">  <span class="built_in">print</span>(p)</span><br></pre></td></tr></tbody></table></figure>

<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">('A', 'B')</span><br><span class="line">('A', 'C')</span><br><span class="line">('A', 'D')</span><br><span class="line">('B', 'A')</span><br><span class="line">('B', 'C')</span><br><span class="line">('B', 'D')</span><br><span class="line">('C', 'A')</span><br><span class="line">('C', 'B')</span><br><span class="line">('C', 'D')</span><br><span class="line">('D', 'A')</span><br><span class="line">('D', 'B')</span><br><span class="line">('D', 'C')</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations">here</a></p>
<h2 id="COMBINATIONS"><a href="#COMBINATIONS" class="headerlink" title="COMBINATIONS"></a>COMBINATIONS</h2><p>Notice: <code>r</code> is NOT optional. (Not like <code>permutations</code>)</p>
<h3 id="WITH-NO-REPLACEMENTS"><a href="#WITH-NO-REPLACEMENTS" class="headerlink" title="WITH NO REPLACEMENTS"></a>WITH NO REPLACEMENTS</h3><p><code>itertools.combinations(iterable, r)</code> returns <code>r</code> length subsequences of elements from the input iterable.</p>
<p><strong>Ex.</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combinations(a, <span class="number">2</span>):</span><br><span class="line">  <span class="built_in">print</span>(c)</span><br></pre></td></tr></tbody></table></figure>

<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">(1, 2)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 3)</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations">here</a></p>
<h3 id="WITH-REPLACEMENTS"><a href="#WITH-REPLACEMENTS" class="headerlink" title="WITH REPLACEMENTS"></a>WITH REPLACEMENTS</h3><p><code>itertools.combinations_with_replacement(iterable, r)</code> returns <code>r</code> length subsequences of elements from the input iterable <strong>allowing individual elements to be repeated more than once</strong>.</p>
<p><strong>Ex.</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c_with_replacement <span class="keyword">in</span> combinations_with_replacement(a, <span class="number">2</span>):</span><br><span class="line">  <span class="built_in">print</span>(c_with_replacement)</span><br></pre></td></tr></tbody></table></figure>

<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">(1, 1)</span><br><span class="line">(1, 2)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 3)</span><br><span class="line">(3, 3)</span><br></pre></td></tr></tbody></table></figure>

<p>Learn more <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement">here</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Languages</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>itertools</tag>
      </tags>
  </entry>
</search>
