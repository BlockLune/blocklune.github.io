<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Simple git tutorial</title>
      <link href="/posts/9363e311.html"/>
      <url>/posts/9363e311.html</url>
      
        <content type="html"><![CDATA[<p>This is a simple tutorial of git, also including some info about GitHub.</p><span id="more"></span><p>Before we start, there are two questions we must know. What is git? &amp;&amp; What is GitHub?</p><blockquote><p>Git is a free and open-source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p></blockquote><p>This is an introduction to git on <a href="https://git-scm.com/">its official website</a>. Simply speaking, git is a version control software.<br>And what is GitHub? GitHub is a website, a platform and a community, which provides developers place to store and share their codes. Since it use git as its version control software, it got a name “GitHub”. Here is <a href="https://github.com/">GitHub</a>.</p><h2 id="creating-a-github-account"><a href="#Creating-a-GitHub-account" class="headerlink" title="Creating a GitHub account"></a>Creating a GitHub account</h2><p>The official tutorial for creating a GitHub account is here: <em><a href="https://docs.github.com/en/get-started/signing-up-for-GitHub/signing-up-for-a-new-GitHub-account">Signing up for a new GitHub account - GitHub Docs</a></em></p><h2 id="downloading-and-installing-git"><a href="#Downloading-and-installing-git" class="headerlink" title="Downloading and installing git"></a>Downloading and installing git</h2><p>You can download git from <a href="https://git-scm.com/downloads">here</a>.</p><p>For detailed installing steps in windows, this maybe helpful:<br><em><a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）</a></em></p><h2 id="configuring-git"><a href="#Configuring-git" class="headerlink" title="Configuring git"></a>Configuring git</h2><p>To configure user info for all local repositories:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;your_name&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;your_email@example.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="connecting-to-github"><a href="#Connecting-to-GitHub" class="headerlink" title="Connecting to GitHub"></a>Connecting to GitHub</h2><p>Open your git bash, and run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;&lt;your_email@example.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>For old system, you may run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;&lt;your_email@example.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>Go to <a href="https://github.com/settings/profile">Your profile on GitHub</a>. Click <code>SSH and GPG keys</code> on the left. Click <code>New SSH key</code>. Choose a title, and paste all content in <code>~/.ssh/id_ed25519.pub</code>. Then click <code>Add SSH key</code>.</p><p>Learn more from <a href="https://docs.github.com/en/authentication/connecting-to-GitHub-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">here</a>.</p><blockquote><p>Simply explaining what we’ve done. <code>ssh-keygen</code> is a tool that help us create a key(<code>~/.ssh/id_ed25519</code>) and a lock(<code>~/.ssh/id_ed25519.pub</code>). Then, we use the <code>id_ed25519.pub</code> file to lock our repos on GitHub, and leave the <code>id_ed25519</code>, the key, in our PC. We can then avoid repeating login GitHub.</p></blockquote><h2 id="simple-git-commands"><a href="#Simple-git-commands" class="headerlink" title="Simple git commands"></a>Simple git commands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating a new repo</span></span><br><span class="line">git <span class="built_in">clone</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking out a repo</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;username&gt;@&lt;host&gt;:&lt;/path/to/repo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connecting to your repo on GitHub</span></span><br><span class="line">git remote add origin &lt;server&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding</span></span><br><span class="line">git add &lt;directory&gt;/&lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Committing</span></span><br><span class="line">git commit -m <span class="string">&quot;&lt;commit_message&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pushing</span></span><br><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="learn-more"><a href="#Learn-more" class="headerlink" title="Learn more"></a>Learn more</h2><p><em><a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）</a></em></p><p><em><a href="http://rogerdudler.github.io/git-guide/index.html">git - the simple guide - no deep shit!</a></em></p><p><em><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - the simple guide - no deep shit! - zh</a></em></p><p><em><a href="https://training.github.com/">GitHub Training Kit</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 版本控制 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Package managers in Linux (To be continued)</title>
      <link href="/posts/4ee6ac78.html"/>
      <url>/posts/4ee6ac78.html</url>
      
        <content type="html"><![CDATA[<p>This post tries to simply introduce some package managers and their basic usage.</p><span id="more"></span><h2 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h2><p>The pacman package manager is the default package manager of Arch Linux. Learn more about pacman on the official wiki <a href="https://wiki.archlinux.org/title/Pacman">here</a>.</p><h3 id="pacman-changing-to-mirror"><a href="#pacman-Changing-to-mirror" class="headerlink" title="pacman - Changing to mirror"></a>pacman - Changing to mirror</h3><p>Before you start to use pacman, changing its source to mirror source in your country might be greatly helpful.</p><p>Firstly, find a mirror you need on <a href="https://archlinux.org/mirrors/">Mirror Overview of ArchLinux offical site</a>. Here I choose the mirror from my mother school, whose URL is <code>https://mirrors.njupt.edu.cn/archlinux/</code>.</p><p>Then, edit <code>/etc/pacman.d/mirrorlist</code> , and paste the string below into the file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.njupt.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>Last, save the file and run <code>sudo pacman -Syu</code> to update.</p><blockquote><p>The file <code>/etc/pacman.d/mirrorlist</code> has already provided many mirrors in it. So you can just skip the first step above, just edit the mirrorlist file. Find the server you want, and delete the <code>#</code> at the begining of that line to uncomment it.</p></blockquote><p>For an easy copy, here are some mirrors in China:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### China</span><br><span class="line">## Aliyun</span><br><span class="line"># Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br><span class="line">## Netease</span><br><span class="line"># Server = https://mirrors.163.com/archlinux/$repo/os/$arch</span><br><span class="line">## Tsinghua</span><br><span class="line"># Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">## NJU</span><br><span class="line"># Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">## NJUPT</span><br><span class="line"># Server = https://mirrors.njupt.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><h3 id="pacman-upgrading-packages"><a href="#pacman-Upgrading-packages" class="headerlink" title="pacman - Upgrading packages"></a>pacman - Upgrading packages</h3><p>Run the command below to upgrade packages.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>You are recommended to immediately run this command after changing to a mirror.</p><h3 id="pacman-querying-packages"><a href="#pacman-Querying-package-s" class="headerlink" title="pacman - Querying package(s)"></a>pacman - Querying package(s)</h3><p>To find the package you need in the sync database:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ss &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>The “s” in the small case means “search”.</p><p>To list the packages installed:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qq  // list all the packages, ignore version (-q)</span><br><span class="line">pacman -Qqe // list explicitly installed packages (-e)</span><br><span class="line">pacman -Qqd // list the packages installed as dependencies (-d)</span><br><span class="line">pacman -Qqdt // list the packages <span class="built_in">which</span> are no longer dependencies (-t), usually can be removed</span><br></pre></td></tr></table></figure><h3 id="pacman-installing-packages"><a href="#pacman-Installing-package-s" class="headerlink" title="pacman - Installing package(s)"></a>pacman - Installing package(s)</h3><p>This command helps install one or more packages.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S &lt;package_name1&gt; &lt;package_name2&gt; ...</span><br></pre></td></tr></table></figure><p>For example, to install <em>bat</em>, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S bat</span><br></pre></td></tr></table></figure><h3 id="pacman-removing-packages"><a href="#pacman-Removing-package-s" class="headerlink" title="pacman - Removing package(s)"></a>pacman - Removing package(s)</h3><p>This command helps remove a single package, leaving all of its dependencies installed:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -R &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>To remove a package and its dependencies that are not required by any other installed package:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Rs &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>Here I found a helpful article that provides more information: <a href="https://www.cnblogs.com/sztom/p/10652624.html">《Arch Linux 软件包的查询及清理》</a>.</p><h2 id="apt"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>The APT(Advanced Packaging Tools) is(Maybe “are”? Since it’s “tools”?) widely used in Debian and Ubuntu etc. It mainly includes <code>apt-get</code> ,<code>apt-cache</code> and <code>apt-file</code>.</p><h3 id="apt-changing-to-mirror"><a href="#APT-Changing-to-mirror" class="headerlink" title="APT - Changing to mirror"></a>APT - Changing to mirror</h3><p>Take Tsinghua’s mirror as an example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## Tsinghua</span><br><span class="line">## from https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu</span><br><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="apt-useful-commands"><a href="#APT-Useful-commands" class="headerlink" title="APT - Useful commands"></a>APT - Useful commands</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update // update the package info </span><br><span class="line">sudo apt upgrade // upgrade all the packages installed</span><br><span class="line">apt list --upgradeable // list all the packages that can upgrade</span><br><span class="line"></span><br><span class="line">sudo apt install &lt;package_name&gt; // install a specific package</span><br><span class="line">sudo apt install -f // fix the dependencies</span><br><span class="line"></span><br><span class="line">sudo apt remove &lt;package_name&gt; // remove a specific package</span><br><span class="line">sudo apt autoremove // auto remove the packages that no longer needed</span><br><span class="line"></span><br><span class="line">apt show &lt;package_name&gt; // show the info about a specific package</span><br></pre></td></tr></table></figure><h2 id="to-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Linux </tag>
            
            <tag> 包管理器 </tag>
            
            <tag> ArchLinux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> pacman </tag>
            
            <tag> APT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 中设置显示最大列数边界线</title>
      <link href="/posts/bb929dc9.html"/>
      <url>/posts/bb929dc9.html</url>
      
        <content type="html"><![CDATA[<p>很多时候我们会避免一行代码过长，常见的限制有 80 字符、120 个字符等。我希望能在 VS Code 中显示一条边界线来提醒我已经到达这个限制了，需要换行。下边是设置的方法。</p><span id="more"></span><p>打开设置（快捷键 <code>Ctrl+,</code>），搜索 <code>Editor: Rulers</code>，点击 “在 settings.json” 中编辑，添加如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;editor.rulers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">80</span><span class="punctuation">,</span><span class="number">120</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>当然你也可以按照自己的喜好设置字符数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> VS Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已解决 </tag>
            
            <tag> 教程 </tag>
            
            <tag> VS Code </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言文件操作</title>
      <link href="/posts/914118ff.html"/>
      <url>/posts/914118ff.html</url>
      
        <content type="html"><![CDATA[<p>简单记录一下 C 语言的文件操作的相关内容。</p><span id="more"></span><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h 提供了 C 语言中的许多 IO，当然包括文件 IO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义文件指针</span></span><br><span class="line">FILE *fp;</span><br></pre></td></tr></table></figure><h2 id="打开文件-fopen"><a href="#打开文件-fopen" class="headerlink" title="打开文件 fopen()"></a>打开文件 fopen()</h2><article class="message is-info">        <div class="message-header"><p>fopen() 函数</p></div>        <div class="message-body">            <p>函数名称：fopen<br>参数：待打开文件的名称（包含该文件名的字符串地址），打开文件的模式；<br>返回值：成功打开文件则返回一个文件指针，否则返回空指针（NULL）</p>        </div>    </article><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span> (fp = fopen(<span class="string">&quot;example.file&quot;</span>, <span class="string">&quot;r&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fail to open the file.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，该函数第二个参数是一个字符串，可能的值如下（表来自《C Primer Plus（第 6 版）中文版》P357 表 13.1）：</p><table><thead><tr><th>模式字符串</th><th>含义</th></tr></thead><tbody><tr><td>“r”</td><td>以读模式打开文件</td></tr><tr><td>“w”</td><td>以写模式打开文件，把现有文件长度截为 0，如果文件不存在，则创建一个新文件</td></tr><tr><td>“a”</td><td>以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td></tr><tr><td>“r+”</td><td>以更新模式打开文件（即可以读写文件）</td></tr><tr><td>“w+”</td><td>以更新模式打开文件，如果文件存在，则将其长度截为 0，如果文件不存在则创建一个新文件</td></tr><tr><td>“a+”</td><td>以更新模式打开文件，在现有文件的末尾添加内容，如果文件不存在则创建一个新文件，<strong>可以读整个文件，但只能从末尾添加内容</strong></td></tr><tr><td>“rb”、”wb”、”ab”、”rb+”、”r+b”、”wb+”、”w+b”、”ab+”、”a+b”</td><td>与上边的对应类似，但以二进制模式打开文件</td></tr><tr><td>“wx”、”wbx”、”w+x”、”wb+x”或”w+bx”</td><td>（C11）与上边对应类似，但如果文件已存在或以独占模式打开文件，则打开文件失败</td></tr></tbody></table><p>带字母 x 的写模式比以前的具有更多特性：</p><ol><li>如果以传统的一种写模式打开一个现有文件，fopen() 会把该文件的长度截为 0，这样就丢失了该文件的内容。但是使用带 x 字母的写模式，即使 fopen() 操作失败，原文件的内容也不会被删除；</li><li>如果环境允许，x 模式的独占特性使得其他程序或线程无法访问正在被打开的文件。</li></ol><h2 id="关闭文件-fclose"><a href="#关闭文件-fclose" class="headerlink" title="关闭文件 fclose()"></a>关闭文件 fclose()</h2><article class="message is-info">        <div class="message-header"><p>fclose() 函数</p></div>        <div class="message-body">            <p>函数名称：fclose<br>参数：待关闭文件的名称（包含该文件名的字符串地址）；<br>返回值：成功关闭返回 0，否则返回 EOF。</p>        </div>    </article><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>注意区分 fopen() 和 fclose() 的返回值！前者失败时返回 NULL（通常情况下就是 0），后者成功时返回 0。</div></article><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="fprintf-和-fscanf"><a href="#fprintf-和-fscanf" class="headerlink" title="fprintf() 和 fscanf()"></a>fprintf() 和 fscanf()</h3><p>这两个函数分别和 printf() 和 scanf() 类似，只不过 printf() 和 scanf() 分别默认了写和读的标准文件是 stdout 和 stdin，而 fprintf() 和 fscanf() 的第一个参数都需要指定文件指针。</p><h3 id="getc-和-putc"><a href="#getc-和-putc" class="headerlink" title="getc() 和 putc()"></a>getc() 和 putc()</h3><p>这两个函数分别和 getchar() 和 putchar() 类似，只是需要提供文件指针。</p><h3 id="ungetc"><a href="#ungetc" class="headerlink" title="ungetc()"></a>ungetc()</h3><article class="message is-info">        <div class="message-header"><p>ungetc() 函数</p></div>        <div class="message-body">            <p>函数名称：ungetc<br>函数原型：<code>int ungetc(int c, FILE *fp);</code><br>函数作用：把 c 指定的字符放回输入流中<br>返回值：如果成功，则返回被推入的字符，否则返回 EOF</p>        </div>    </article><h3 id="fgets-和-fputs"><a href="#fgets-和-fputs" class="headerlink" title="fgets() 和 fputs()"></a>fgets() 和 fputs()</h3><p>虽然这两个函数也分别类似于 gets() 和 puts()，但比起上边几个函数的”类似”，这个要低一点，所以详细说明一下。</p><article class="message is-info">        <div class="message-header"><p>fgets() 函数</p></div>        <div class="message-body">            <p>函数名称：fgets<br>函数原型：<code>char *fgets (char * restrict str, int n, FILE * restrict fp);</code><br>返回值：如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。</p>        </div>    </article><p>需要注意 fgets() 的第二个参数，因为 fgets() 读取输入知道第一个换行符的后边（<strong>意味着它会读入换行符</strong>），或读到文件结尾，或读取 n-1 个字符，并在结尾加上一个 <code>\0</code> 使之成为一个字符串。</p><article class="message is-info">        <div class="message-header"><p>fputs() 函数</p></div>        <div class="message-body">            <p>函数名称：fputs<br>函数原型：<code>int fputs (char * restrict str, FILE * restrict fp);</code><br>返回值：该函数返回一个非负值，如果发生错误则返回 EOF。</p>        </div>    </article><p>fputs() 与 puts() 类似，但<strong>不会在结尾自动添加换行</strong>。</p><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>注意区分 fgets() 与 gets()， fputs() 与 puts()！gets() 不保留换行符所以 puts() 自动添加换行符；fgets() 保留换行符所以 fputs() 不会添加换行符。</div></article><h3 id="fread-和-fwrite"><a href="#fread-和-fwrite" class="headerlink" title="fread() 和 fwrite()"></a>fread() 和 fwrite()</h3><p>上述的函数都是以文本形式读写文件，这两个函数用于以二进制形式读写文件。</p><article class="message is-info">        <div class="message-header"><p>fread() 函数</p></div>        <div class="message-body">            <p>函数名称：fread<br>函数原型：<code>size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);</code><br>返回值：返回成功读取项的数量。正常情况下返回值等于 nmemb，发生错误则返回值小于 nmemb。</p>        </div>    </article><article class="message is-info">        <div class="message-header"><p>fwrite() 函数</p></div>        <div class="message-body">            <p>函数名称：fwrite<br>函数原型：<code>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);</code><br>返回值：返回成功写入项的数量。正常情况下返回值等于 nmemb，发生错误则返回值小于 nmemb。</p>        </div>    </article><p>参数 size 表示待写入数据块的大小（以字节为单位），nmemb 表示待写入数据块的数量。</p><p>下边是两个使用这两个函数的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存一个大小为 256 字节的 buffer 数组</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">fwrite(buffer, <span class="number">256</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存一个内含 10 个 double 类型值的数组</span></span><br><span class="line"><span class="comment">// 或者说理解成保存 10 个 double 类型的值</span></span><br><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fwrite(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 10 个 double 类型的值到一个数组中</span></span><br><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure><h2 id="随机访问-fseek-和-ftell"><a href="#随机访问-fseek-和-ftell" class="headerlink" title="随机访问 fseek() 和 ftell()"></a>随机访问 fseek() 和 ftell()</h2><article class="message is-info">        <div class="message-header"><p>fseek() 函数</p></div>        <div class="message-body">            <p>函数名称：fseek<br>函数原型：<code>int fseek(FILE *_File,long _Offset,int _Origin);</code><br>参数：文件指针，偏移量(long 类型)，模式<br>返回值：正常则返回 0，错误则返回 -1。</p>        </div>    </article><p>第二个参数偏移量必须是一个 long 类型的值，代表偏移的<strong>字节数</strong>。这个值为正，则表示像文件末尾方向移动；为负则表示向文件开头处。<br>第三个参数可以理解成起点位置，可以使用 <code>SEEK_SET</code>、<code>SEEK_CUR</code> 或 <code>SEEK_END</code> 分别定位到文件开始、当前位置或文件末尾（老版本应分别使用 <code>0</code>、<code>1</code>、<code>2</code>）。</p><p>下边是一些例子（来自《C Primer Plus（第 6 版）中文版》P364）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);   <span class="comment">// 定位至文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET);  <span class="comment">// 定位至文件中第 10 个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR);   <span class="comment">// 从文件当前位置向结尾方向移动 2 个字节</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);   <span class="comment">// 定位至文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END); <span class="comment">// 从文件结尾处回退 10 个字节</span></span><br></pre></td></tr></table></figure><article class="message is-info">        <div class="message-header"><p>ftell() 函数</p></div>        <div class="message-body">            <p>函数名称：ftell<br>函数原型：<code>long ftell(FILE *_File);</code><br>返回值：返回当前位置距文件开始的字节数，如文件的第一个字节到文件开始处的距离为 0。</p>        </div>    </article><p>下边是书中给出的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END); <span class="comment">// 首先定位到文件结尾</span></span><br><span class="line">last = ftell(fp);        <span class="comment">// 统计字节数，并存储到 last 中</span></span><br><span class="line"><span class="comment">// 逆序打印每一个字节的字符</span></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= last; count++)</span><br><span class="line">&#123;</span><br><span class="line">    fseek(fp, -count, SEEK_END);</span><br><span class="line">    ch = getc(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="刷新缓冲区-fflush"><a href="#刷新缓冲区-fflush" class="headerlink" title="刷新缓冲区 fflush()"></a>刷新缓冲区 fflush()</h3><article class="message is-info">        <div class="message-header"><p>fflush() 函数</p></div>        <div class="message-body">            <p>函数名称：fflush<br>函数原型：<code>int fflush(FILE *fp);</code><br>函数作用：调用该函数将刷新缓冲区，即将输出缓冲区中所有的未写入数据被发送到 fp 指定的输出文件。如果 fp 为空指针，所有输出缓冲区都被刷新。<br>返回值：成功返回 0，错误返回 EOF。</p>        </div>    </article><h3 id="创建替换使用缓冲区-setvbuf"><a href="#创建替换使用缓冲区-setvbuf" class="headerlink" title="创建替换使用缓冲区 setvbuf()"></a>创建替换使用缓冲区 setvbuf()</h3><article class="message is-info">        <div class="message-header"><p>setvbuf() 函数</p></div>        <div class="message-body">            <p>函数名称：setvbuf<br>函数原型：<code>int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);</code><br>返回值：成功返回 0，否则返回非零值。</p>        </div>    </article><p>第二个参数指向待使用的缓冲区。如果是 NULL，则自动分配。<br>第三个参数为模式，有下边几种：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">_IOFBF</td><td align="left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td></tr><tr><td align="left">_IOLBF</td><td align="left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td></tr><tr><td align="left">_IONBF</td><td align="left"><strong>无缓冲</strong>：不使用缓冲。每个 I&#x2F;O 操作都被即时写入。buffer 和 size 参数被忽略。</td></tr></tbody></table><h3 id="feof-和-ferror"><a href="#feof-和-ferror" class="headerlink" title="feof() 和 ferror()"></a>feof() 和 ferror()</h3><p>当上一次输入调用检测到文件结尾时，feof() 函数返回一个非零值，否则返回 0。<br>当读写出现错误，ferror() 函数返回一个非零值，否则返回 0。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>error: summary string parsing error 错误解决方法</title>
      <link href="/posts/78dc947f.html"/>
      <url>/posts/78dc947f.html</url>
      
        <content type="html"><![CDATA[<p>直接先说解决方法：在使用 clang 工具链进行编译的时候，添加编译选项 <code>-fstandalone-debug</code>。</p><span id="more"></span><p>下边是完整的发现及解决问题的过程。</p><h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>在按照 <a href="https://www.bilibili.com/video/BV1sW411v7VZ">《使用 VS Code + Clangd + CMake 搭建 C&#x2F;C++ 开发环境》</a> 搭建我在 ArchWSL 内的 C&#x2F;C++ 开发环境时，我创建了一个用于测试的 HelloWorld 工程。这个工程的文件结构长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── .clang-format</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @file CMakeLists.txt</span></span><br><span class="line"><span class="comment"># old</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试的时候发现，int 型变量 a 是可以查看的，但 std::string 型的变量 str 却显示 <code>error: summary string parsing error</code> 错误。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>在测试中我发现，这个问题只在我使用 clang 工具链编译时产生，使用 g++ 就没有这个问题，所以猜测不是 lldb 调试器的问题，而是 clang 编译器的问题。</p><p>在网上搜索到了类似的问题：</p><ul><li><a href="https://cloud.tencent.com/developer/ask/sof/1542916">无法在 lldb 中检查 std::string 变量 - 问答 - 腾讯云开发者社区</a></li><li><a href="https://github.com/vadimcn/vscode-lldb/issues/415">Cannot inspect any strings · Issue #415 · vadimcn&#x2F;vscode-lldb</a></li></ul><p>都说要使用 <code>-fstandalone-debug</code> 重新编译。</p><p>于是修改 CMakeLists.txt 为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @file CMakeLists.txt</span></span><br><span class="line"><span class="comment"># new</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用的是 clang 工具链，那么需要添加上 -fstandalone-debug，否则 lldb 无法查看 std::string 的东东</span></span><br><span class="line"><span class="comment"># 见 https://cloud.tencent.com/developer/ask/sof/1542916</span></span><br><span class="line"><span class="comment"># 又见 https://github.com/vadimcn/vscode-lldb/issues/415</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-fstandalone-debug)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;optional: -fstandalone-debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp)</span><br></pre></td></tr></table></figure><p>至此成功解决。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 调试 </category>
          
          <category> LLDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已解决 </tag>
            
            <tag> 错误 </tag>
            
            <tag> 解决方案 </tag>
            
            <tag> 调试 </tag>
            
            <tag> LLDB </tag>
            
            <tag> LLVM </tag>
            
            <tag> Clang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 简单笔记</title>
      <link href="/posts/b5f1b38d.html"/>
      <url>/posts/b5f1b38d.html</url>
      
        <content type="html"><![CDATA[<p>这是一篇笔记，原视频是 <a href="https://space.bilibili.com/519963684">@于仕琪</a> 老师的 <a href="https://www.bilibili.com/video/BV188411L7d2">《Makefile 20 分钟入门，简简单单，展示如何使用 Makefile 管理和编译 C++ 代码》</a>。</p><span id="more"></span><h2 id="老师所给的四个版本"><a href="#老师所给的四个版本" class="headerlink" title="老师所给的四个版本"></a>老师所给的四个版本</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本一</span></span><br><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">    g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本二</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c factorial.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本三</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本四</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>首先是关于 g++ 这个 C++ 编译器的一些知识点。</p><ul><li><code>-c</code> 参数表示生成 obj 文件（<code>*.o</code>）；</li><li><code>-o</code> 用于指定生成的可执行文件的名称，比如上边 <code>-o hello</code> 就表示生成的可执行文件叫 hello；</li><li><code>-Wall</code> 表示 Warning all，也就是打开全部的警告。</li></ul><p>接着是 Makefile 文件的大致原理。</p><p>首先看最易理解的版本一。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">    g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure><p>第一行冒号前的部分表示我们需要的文件（这里是 <code>hello</code>），冒号后表示冒号前文件的依赖项（这里是三个 <code>.cpp</code> 文件），第二行表示为了生成冒号前的文件，需要执行什么命令。Make 工具通过检测冒号后文件的时间戳是否比冒号前文件更新来判断是否要执行第二行语句。</p><p>在第二个版本中，引入了变量的概念。形似 <code>XXX = YYY</code> 的东西就是在给变量赋值，使用 <code>$(XXX)</code> 来取得值 <code>YYY</code>。</p><p>第三个版本中出现了 <code>$@</code>、<code>$^</code>、<code>$&lt;</code> 等符号，他们分别表示冒号前面的内容、冒号后边的全部内容和冒号后边第一个内容。</p><p>第三个版本中的 <code>.PHONY: clean</code> 标识了 <code>clean</code> 是个命令而不是一个文件，这样结合下边的 <code>clean:</code> 的内容，就可以实现直接在终端输入 <code>make clean</code> 来执行 <code>rm -f *.o $(TARGET)</code> 的命令，清空生成出来的文件。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编译链接 </category>
          
          <category> GNU Make </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译链接 </tag>
            
            <tag> Makefile </tag>
            
            <tag> GNU Make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 标准库中 qsort 和 C++ STL 中 sort 的用法</title>
      <link href="/posts/eab95d6e.html"/>
      <url>/posts/eab95d6e.html</url>
      
        <content type="html"><![CDATA[<p>虽然到现在还是不能完全理解 <code>qsort</code> 和 <code>sort</code> 这两个函数的底层原理，但至少，先学会如何使用吧。</p><span id="more"></span><h2 id="qsort"><a href="#qsort" class="headerlink" title="qsort"></a>qsort</h2><p><strong>需要包含的库:</strong></p><p>stdlib.h (C++ 中 是 cstdlib)</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span><br></pre></td></tr></table></figure><p><strong>参数解释：</strong></p><ul><li>base: 必选，数组名（数组首元素的地址）；</li><li>nitems: 必选，数组中元素的个数；</li><li>size: 必选，数组中单个元素的大小；</li><li>compar: 必选，一个函数指针，具体这个函数要干嘛下边细说。</li></ul><p>最后一个参数是函数指针，这个指针指向的函数的原型应该类似于下边这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure><p>这是一个返回值为 <code>-1</code>、<code>0</code> 或 <code>1</code> 的函数。</p><p>如果要实现升序，那么应该是：</p><blockquote><p>a&gt;b：返回 1（或其他正数）;<br>a&#x3D;&#x3D;b：返回 0;<br>a&lt;b: 返回 -1（或其他负数）;</p></blockquote><p>如果是降序，那么就应该反过来，像下边这样：</p><blockquote><p>a&gt;b：返回 -1（或其他负数）;<br>a&#x3D;&#x3D;b：返回 0;<br>a&lt;b: 返回 1（或其他正数）;</p></blockquote><p>比如我要对 int 类型的数组升序排序，那么我的 cmp 函数应该像下边这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *x = (<span class="type">const</span> <span class="type">int</span> *)a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *y = (<span class="type">const</span> <span class="type">int</span> *)b;</span><br><span class="line">    <span class="keyword">if</span> (*x &gt; *y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*x == *y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以简化成下边这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">const</span> <span class="type">int</span> *)a - *(<span class="type">const</span> <span class="type">int</span> *)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 a&gt;b 等比较方式只是形式上我这么写，实际上有可能这两个元素我并不能直接这么比（比如如果这里的 a、b 都是 struct），那么就应该类似下边这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> score;</span><br><span class="line">&#125; STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STUDENT stu[<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    qsort(stu, <span class="number">5</span>, <span class="keyword">sizeof</span>(STUDENT), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ID: %u, Score: %u\n&quot;</span>, stu[i].ID, stu[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> STUDENT *x = (<span class="type">const</span> STUDENT *)a;</span><br><span class="line">    <span class="type">const</span> STUDENT *y = (<span class="type">const</span> STUDENT *)b;</span><br><span class="line">    <span class="comment">// 降序排序</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;score &gt; y-&gt;score)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;score == y-&gt;score)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ID: 1, Score: 5</span><br><span class="line">ID: 5, Score: 4</span><br><span class="line">ID: 2, Score: 3</span><br><span class="line">ID: 4, Score: 2</span><br><span class="line">ID: 3, Score: 1</span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><strong>需要包含的库:</strong></p><p>algorithm（C++ STL 中的算法库）</p><p><strong>函数原型：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解释：</strong></p><p>first: 必选，排序开始处（参与排序的第一个元素）；<br>last: 必选，排序结束处的<strong>后一个紧挨着的位置</strong>（参与排序的最后一个元素的<strong>后一个位置</strong>）；<br>comp: 可选，用来指定怎么排序的函数，没有的话如果可以默认升序。</p><p>下边给出一些例子：</p><p>给一个数组升序排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr, arr + <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>给一个 vector 降序排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>这里用了 <code>greater&lt;typename&gt;()</code> 这个东东直接表达我这个排序需要降序排序，类似的还有 <code>less&lt;typename&gt;()</code> 用来指定升序。</p><p>然后是自定义这第三个参数，我们就用上边 qsort 那个例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">STUDENT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(STUDENT, STUDENT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STUDENT stu[<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(stu, stu + <span class="number">5</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ID: %u, Score: %u\n&quot;</span>, stu[i].ID, stu[i].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(STUDENT a, STUDENT b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score &gt; b.score)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以把 cmp 写成下边这种更容易记住的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(STUDENT a, STUDENT b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="comment">// 表示排序完成后前一个元素比后一个元素大，即降序排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出和上边是一样的。</p><article class="message message-immersive is-danger"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i><strong>注意</strong><p>在 qsort 中，最后一个参数的函数的返回值应是一个有符号整型。在期望<strong>升序</strong>排序时，这个返回值应该指定为：<strong>第一个元素大于第二个元素，返回正数；</strong>第一个元素等于第二个元素，返回 0；第一个元素小于第二个元素，返回负数。</p><p>在 C++ STL 的 sort 中，最后一个参数的返回值应是一个布尔值。在期望<strong>升序</strong>排序时，这个返回值应该是 (第一个元素 &lt; 第二个元素) 的运算结果。</p></div></article>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 排序 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求解最大公约数的四种算法</title>
      <link href="/posts/504f038d.html"/>
      <url>/posts/504f038d.html</url>
      
        <content type="html"><![CDATA[<p>这是一次计算机导论课的作业。本来对于最大公约数的求解算法，我就只知道一个<strong>辗转相除法</strong>。原来，其实还有别的一些 …</p><span id="more"></span><h2 id="法一试除法穷举法"><a href="#法一：试除法（穷举法）" class="headerlink" title="法一：试除法（穷举法）"></a>法一：试除法（穷举法）</h2><p>也许这应该才是最先能想到的算法——两个数中取小的那个，由大到小穷举这个数的所有因数，并且看看这个数是不是另一个数的因数，如果是，那这个数就是这两个数的最大公约数了。</p><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h3><p>$O(min(a,b))$</p><h3 id="1-自然语言描述"><a href="#1-自然语言描述" class="headerlink" title="1. 自然语言描述"></a>1. 自然语言描述</h3><ol><li>定义变量 $a,b$，用于存放两个待求取最大公约数的值，确保 $a\leq b$；</li><li>定义变量 $i&#x3D;a$；</li><li>如果 $i\geq1$，执行步骤 4；</li><li>判断 $i$ 是否是 $a$ 的因数，如果是，执行步骤 5，否则，执行步骤 7；</li><li>判断 $i$ 是否是 $b$ 的因数，如果是，执行步骤 6，否则，执行步骤 7；</li><li>跳出循环，$i$ 就是 $a$ 和 $b$ 的最大公约数；</li><li>$i$ 自减 $1$，执行步骤 3；</li></ol><h3 id="1-伪代码描述"><a href="#1-伪代码描述" class="headerlink" title="1. 伪代码描述"></a>1. 伪代码描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a,b,i:integer;</span><br><span class="line">input(a);</span><br><span class="line">input(b);</span><br><span class="line">Begin</span><br><span class="line">For i&lt;-a to 1 do</span><br><span class="line">Begin</span><br><span class="line">If a%i==0 Then</span><br><span class="line">    If b%i==0 Then</span><br><span class="line">    Begin</span><br><span class="line">    print(i);</span><br><span class="line">    break;</span><br><span class="line">    End;</span><br><span class="line">End;</span><br><span class="line">End;</span><br></pre></td></tr></table></figure><h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/12/05/zy8vhn.png" alt="Powered by draw.io"></p><h3 id="1-c-代码"><a href="#1-C-代码" class="headerlink" title="1. C++ 代码"></a>1. C++ 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (b % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二辗转相除法欧几里得算法"><a href="#法二：辗转相除法（欧几里得算法）" class="headerlink" title="法二：辗转相除法（欧几里得算法）"></a>法二：辗转相除法（欧几里得算法）</h2><p>这大概是最常见的计算最大公约数的算法了吧…</p><h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2. 时间复杂度"></a>2. 时间复杂度</h3><p>可近似看作 $O(log(max(a,b)))$，但取模运算性能较差。</p><h3 id="2-自然语言描述"><a href="#2-自然语言描述" class="headerlink" title="2. 自然语言描述"></a>2. 自然语言描述</h3><ol><li>定义变量 a，b 并读入；</li><li>如果 b &#x3D;&#x3D; 0，返回 a；</li><li>否则，更新 a 的值为原来 b 的值，更新 b 的值为原来 a%b 的值，回到步骤 2。</li></ol><h3 id="2-伪代码描述"><a href="#2-伪代码描述" class="headerlink" title="2. 伪代码描述"></a>2. 伪代码描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a,b:integer;</span><br><span class="line">def gcd(a,b):</span><br><span class="line">Begin</span><br><span class="line">If b==0 Then</span><br><span class="line">    return a;</span><br><span class="line">    Else return(gcd(b, a%b));</span><br><span class="line">End;</span><br></pre></td></tr></table></figure><h3 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2. 流程图"></a>2. 流程图</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/12/05/zyNCG9.png" alt="Powered by draw.io"></p><h3 id="2-c-代码"><a href="#2-C-代码" class="headerlink" title="2. C++ 代码"></a>2. C++ 代码</h3><p>主函数及 gcd 函数的函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span>, <span class="type">uint64_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcd 函数（递归实现）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcd 函数（递归函数，写成一行的版本）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br></pre></td></tr></table></figure><p>gcd 函数（迭代实现）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint64_t</span> tmp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法三更相减损法"><a href="#法三：更相减损法" class="headerlink" title="法三：更相减损法"></a>法三：更相减损法</h2><p>更相减损法又叫<strong>更相减损术</strong>，出自《九章算术》，是咱老祖宗的智慧。这个东西本来是为了约分而设计的，但是，既然都约分了，那自然也可以用来求取最大公约数。</p><p>这个算法的原文描述是这样：</p><blockquote><p>可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。</p></blockquote><p>翻译成白话就是：</p><blockquote><p>（如果需要对分数进行约分，那么）可以折半的话，就折半（也就是用 2 来约分）。如果不可以折半的话，那么就比较分母和分子的大小，用大数减去小数，互相减来减去，一直到减数与差相等为止，用这个相等的数字来约分。</p></blockquote><p><em>这两段引用的来源是：<a href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF">更相减损术_百度百科 (baidu.com)</a></em></p><h3 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3. 时间复杂度"></a>3. 时间复杂度</h3><p>$O(max(a,b))$</p><h3 id="3-自然语言描述"><a href="#3-自然语言描述" class="headerlink" title="3. 自然语言描述"></a>3. 自然语言描述</h3><ol><li>定义变量 a、b 并读入；</li><li>如果 变量 a、b 能被 2 整除，那就都除以 2。不断重复执行这一步直到 a、b 任意一个不能被 2 整除，记录下进行这一步的次数，存入变量 cnt 中；</li><li>定义三个变量 x1、x2、x3，用于表示被减数、减数和差；</li><li>x1 赋初值为 a、b 中较大的那一个，x2 赋初值为 a、b 中较小的那一个，x3 赋初值为 x1-x2；</li><li>在 x2!&#x3D;x3 的情况下，不断更新 x1 &#x3D; max(x2, x3)，x2 &#x3D; min(x2, x3)，x3 &#x3D; x1 - x2；</li><li>返回 x2 + pow(2, cnt)。</li></ol><h3 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3. 流程图"></a>3. 流程图</h3><h3 id="3-c-代码"><a href="#3-C-代码" class="headerlink" title="3. C++ 代码"></a>3. C++ 代码</h3><p>下边给出的是基于原文描述实现的更相减损法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> cnt = <span class="number">0</span>; <span class="comment">// 统计除以二的次数</span></span><br><span class="line">    <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint64_t</span> x1, x2, x3; <span class="comment">// 分别表示被减数、减数、差</span></span><br><span class="line">    x1 = <span class="built_in">max</span>(a, b);</span><br><span class="line">    x2 = <span class="built_in">min</span>(a, b);</span><br><span class="line">    x3 = x1 - x2;</span><br><span class="line">    <span class="keyword">while</span> (x2 != x3)</span><br><span class="line">    &#123;</span><br><span class="line">        x1 = <span class="built_in">max</span>(x2, x3);</span><br><span class="line">        x2 = <span class="built_in">min</span>(x2, x3);</span><br><span class="line">        x3 = x1 - x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x2 * <span class="built_in">pow</span>(<span class="number">2</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果去掉那些“可半者半之”，直接进行后面的“<strong>辗转相减</strong>”部分，也是可以的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> x1, x2, x3; <span class="comment">// 分别表示被减数、减数、差</span></span><br><span class="line">    x1 = <span class="built_in">max</span>(a, b);</span><br><span class="line">    x2 = <span class="built_in">min</span>(a, b);</span><br><span class="line">    x3 = x1 - x2;</span><br><span class="line">    <span class="keyword">while</span> (x2 != x3)</span><br><span class="line">    &#123;</span><br><span class="line">        x1 = <span class="built_in">max</span>(x2, x3);</span><br><span class="line">        x2 = <span class="built_in">min</span>(x2, x3);</span><br><span class="line">        x3 = x1 - x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x2;  <span class="comment">// 或者 return x3;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是也可以写出递归形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        a ^= b, b ^= a, a ^= b; <span class="comment">// 确保 a&gt;=b</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * b == a)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a - b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法四stein-算法"><a href="#法四：Stein-算法" class="headerlink" title="法四：Stein 算法"></a>法四：Stein 算法</h2><p>这个算法是辗转相除法的改进版本，避免了取模运算，且算法性能稳定。</p><h3 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>$O(log(max(a,b)))$</p><h3 id="版本一"><a href="#版本一：" class="headerlink" title="版本一："></a>版本一：</h3><p>学习自<a href="https://cnblogs.com/COLIN-LIGHTNING/p/8425484.html">这篇</a>文章，正好学习一下位运算的一些“骚操作”（见下文引用处）。</p><h4 id="41-自然语言描述"><a href="#4-1-自然语言描述" class="headerlink" title="4.1. 自然语言描述"></a>4.1. 自然语言描述</h4><ol><li>定义变量 a、b 并读入，确保 a&gt;&#x3D;b（如果 a&lt;b 则交换）；</li><li>如果两个数都是偶数，那就不断除以 2 直至至少一个不是偶数；</li><li>如果一奇一偶，那就把那个偶数不断除以 2 直至它也为一个奇数；</li><li>对两个奇数进行辗转相减（或者辗转相除？上边那篇文章里这么说，但是除的话不是无法避免取模运算效率低下的问题了嘛 emm），直至求出它们的最大公约数；</li></ol><h4 id="41-流程图"><a href="#4-1-流程图" class="headerlink" title="4.1. 流程图"></a>4.1. 流程图</h4><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/12/05/zyTcJe.png" alt="Powered by draw.io"></p><h4 id="41-c-代码"><a href="#4-1-C-代码" class="headerlink" title="4.1. C++ 代码"></a>4.1. C++ 代码</h4><blockquote><p>(1) 按位与 (&amp;):</p><p>a&amp;x 为对数 a 的二进制形式的取位操作，即去 a 二进制形式的第 x 位。这里有一个重要应用就是 a&amp;1 可以用于判断数 a 的奇偶性，即 a 末位为 0 即为偶数，末位为 1 即为奇数。</p><p>(2) 异或运算 (^):</p><p>具体介绍参考之前的随笔：<a href="http://www.cnblogs.com/COLIN-LIGHTNING/p/8298554.html%EF%BC%9B">http://www.cnblogs.com/COLIN-LIGHTNING/p/8298554.html；</a><br>应用为交换两数：a^&#x3D;b,b^&#x3D;a,a^&#x3D;b 即完成了两数交换。</p><p>(3) 按位左移 (&lt;&lt;):</p><p>a&lt;&lt;&#x3D;x 即为使 a 乘以 2 的 x 次幂，原理是让 a 的二进制形式左移 x 位；应用为对与 2 的幂次方相乘使运算更快更方便；</p><p>(4) 按位右移 (&gt;&gt;):</p><p>a&gt;&gt;&#x3D;x 即为使 a 除以 2 的 x 次幂，原理是让 a 的二进制形式右移 x 位；应用为对与 2 的幂次方相除使运算更快更方便；</p></blockquote><p>大佬的代码大致是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        a ^= b, b ^= a, a ^= b; <span class="comment">// 确保 a&gt;=b，也可以 swap(a,b);</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> ((!(a &amp; <span class="number">1</span>)) &amp;&amp; (!(b &amp; <span class="number">1</span>)))        <span class="comment">// a&amp;1 若为 0 表示 a%2==0，也就是 a 能被 2 整除；</span></span><br><span class="line">                                         <span class="comment">// 若非 0 则表示 a%2!=0，也就是 a 不能被 2 整除。</span></span><br><span class="line">                                         <span class="comment">// b&amp;1 类似。所以这里判断的是 “当 a、b 都是偶数的时候”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 步骤 2：将 a、b 都除以 2。注意最后的左移，在递归返回过程中将2因子乘上。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) &amp;&amp; (!(b &amp; <span class="number">1</span>)))      <span class="comment">// “当 a 为奇数，b 为偶数时”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a, b &gt;&gt; <span class="number">1</span>);           <span class="comment">// 步骤 3：将仍为偶数的那个数不断除以 2 直至其为奇数。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((!(a &amp; <span class="number">1</span>)) &amp;&amp; (b &amp; <span class="number">1</span>))      <span class="comment">// “当 a 为偶数，b 为奇数时”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b);           <span class="comment">// 与上面类似</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a - b, b); <span class="comment">// 步骤 4：用辗转相减法处理，求取这两个奇数的最大公约数;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本二"><a href="#版本二：" class="headerlink" title="版本二："></a>版本二：</h3><p>来自<a href="https://blog.csdn.net/Brilliance_panpan/article/details/88372432">这里</a>，对均为奇数的情况做了不同的处理，其他都是一样的。</p><h4 id="42-自然语言描述"><a href="#4-2-自然语言描述" class="headerlink" title="4.2. 自然语言描述"></a>4.2. 自然语言描述</h4><ol><li>定义变量 a、b 并读入；</li><li>如果 a&#x3D;&#x3D;b，则直接返回 a 或 b，否则下一步；</li><li>如果 a&lt;b，交换 a、b 的值，确保 a&gt;b；</li><li>判断属于下边哪种情况，按对应的情况更新 a、b 的值，回到步骤 2。</li></ol><p>四种情况分别是：</p><ol><li>均为偶数: gcd(a,b) &#x3D; 2 * gcd(a&#x2F;2,b&#x2F;2);</li><li>均为奇数: gcd(a,b) &#x3D; gcd((a+b)&#x2F;2,(a-b)&#x2F;2);</li><li>a 为奇数，b 为偶数: gcd(a,b) &#x3D; gcd(a,b&#x2F;2);</li><li>a 为偶数，b 为奇数: gcd(a,b) &#x3D; gcd(a&#x2F;2,b);</li></ol><h4 id="42-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2. 流程图"></a>4.2. 流程图</h4><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/12/05/zyTgRH.png" alt="Powered by draw.io"></p><h4 id="42-c-代码"><a href="#4-2-C-代码" class="headerlink" title="4.2. C++ 代码"></a>4.2. C++ 代码</h4><p>最后代码和上边也没有太大差别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        a ^= b, b ^= a, a ^= b;</span><br><span class="line">    <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>))            <span class="comment">// 均为偶数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 别忘了要乘回来</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>))         <span class="comment">// 均为奇数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>((a + b) &gt;&gt; <span class="number">1</span>, (a - b) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) &amp;&amp; !(b &amp; <span class="number">1</span>)) <span class="comment">// a 奇 b 偶</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="comment">// a 偶 b 奇</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li><a href="https://blog.csdn.net/Brilliance_panpan/article/details/88372432">《求最大公约数的 4 种常用算法<em>AmethystFOB 的博客 - CSDN 博客</em>求最大公约数的四种算法》</a></li><li><a href="https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF">《更相减损术_百度百科 (baidu.com)》</a></li><li><a href="https://blog.csdn.net/Dan1374219106/article/details/106676043">《教你写一手漂亮的伪代码（详细规则 &amp; 简单实例）_<em>陈同学</em>的博客 - CSDN 博客_伪代码的简单例子》</a></li><li><a href="https://www.php.cn/csharp-article-415083.html">《伪代码是什么？如何写一个伪代码？-C#.Net 教程 - PHP 中文网》</a></li><li><a href="https://baike.baidu.com/item/%E6%B5%81%E7%A8%8B%E5%9B%BE/206961">《流程图_百度百科 (baidu.com)》</a></li><li><a href="https://zhuanlan.zhihu.com/p/359722998">《for、while、do while 三种循环的流程图画法总结（附案例） - 知乎 (zhihu.com)》</a></li><li><a href="https://www.liuchengtu.com/tutorial/switchlct.html">《switch 语句流程图怎么画？简单的 switch 语句流程图模板分享 (liuchengtu.com)》</a></li><li><a href="https://www.cnblogs.com/COLIN-LIGHTNING/p/8425484.html">《浅谈 Stein 算法求最大公约数 (GCD) 的原理及简单应用 - COLINGAO - 博客园 (cnblogs.com)》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> 最大公约数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 最大公约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探深度优先搜索（DFS）和广度优先搜索（BFS）</title>
      <link href="/posts/a336c1b8.html"/>
      <url>/posts/a336c1b8.html</url>
      
        <content type="html"><![CDATA[<p><strong>深度优先搜索</strong>（DFS，Depth First Search）和<strong>广度优先搜索</strong>（BFS，Breadth First Search），我从来没弄明白过。是时候努力去好好理解一下了。</p><span id="more"></span><p>B 站找了两个视频看，这篇文章是笔记。</p><p><del>所以图直观还是直接看视频吧…</del></p><ul><li><a href="https://www.bilibili.com/video/BV1cQ4y127Kd/">《不怕你学不会系列：深度优先搜索_哔哩哔哩_bilibili》</a></li><li><a href="https://www.bilibili.com/video/BV1H44y1871A/">《不怕你学不会系列：宽度优先搜索_哔哩哔哩_bilibili》</a></li></ul><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>DFS 的搜索过程要结合 <strong>栈</strong> 来理解，实际上这个过程就是在对一个 <strong>栈</strong> 在操作。比如我们有这样一张图：</p><pre class="mermaid">graph TB;1((1))===2((2))===4((3))===8((4))===5((5))2((2))===5((5))1((1))===3((8))===6((6))===8((4))3((8))===7((9))6((6))===9((7))</pre><p><del>我的博客支持 mermaid 嘛… emm 好像不支持…</del></p><p>我们建立一个栈，然后开始遍历上边这张图。我们做以下约定：</p><ul><li>已经入栈的节点要被标记为已经遍历；</li><li>起始节点为 1，将其入栈，作为最初的栈顶；</li><li>查看与当前栈顶元素相连并且未被标记的节点，将其入栈；</li><li>如果有多个满足 3 中条件的元素，节点序号较小的优先入栈；</li><li>当栈顶元素没有相连节点或所有相连节点均已经被标记后，将其出栈。</li></ul><p>所以对于上边的图，我们依次进行下面的操作：</p><ol><li>节点 1 入栈，并将其标记；</li><li>查找与当前栈顶元素节点 1 相连并且没有标记的元素，有节点 2 和节点 8，节点 2 优先入栈，将节点 2 标记；</li><li>查找与当前栈顶元素节点 2 相连并且没有标记的元素，有节点 3 和节点 5，节点 3 优先入栈，将节点 3 标记；</li><li>查找与当前栈顶元素节点 3 相连并且没有标记的元素，只有节点 4，节点 4 入栈，并将其标记；</li><li>查找与当前栈顶元素节点 4 相连并且没有标记的元素，有节点 5 和 节点 6 ，节点 5 优先入栈，将节点 5 标记；</li><li>查找与当前栈顶元素节点 5 相连的元素，有节点 2 和节点 4，但均已被标记，所以当前栈顶节点 5 出栈；</li><li>查找与当前栈顶元素节点 4 相连并且没有标记的元素，只有节点 6，节点 6 入栈，并将其标记；</li><li>查找与当前栈顶元素节点 6 相连并且没有标记的元素，有节点 7 和节点 8，节点 7 优先入栈，将节点 7 标记；</li><li>查找与当前栈顶元素节点 7 相连的元素，没有这样的元素，节点 7 出栈；</li><li>查找与当前栈顶元素节点 6 相连并且没有标记的元素，只有节点 8，节点 8 入栈，并将其标记；</li><li>查找与当前栈顶元素节点 8 相连并且没有标记的元素，只有节点 9， 节点 9 入栈，并将其标记；</li><li>查找与当前栈顶元素节点 9 相连并且没有标记的元素，没有这样的元素，节点 9 出栈；</li><li>查看当前栈顶元素节点 8，类似，节点 8 出栈；</li><li>查看当前栈顶元素节点 6，类似，节点 6 出栈；</li><li>查看当前栈顶元素节点 4，类似，节点 4 出栈；</li><li>查看当前栈顶元素节点 3，类似，节点 3 出栈；</li><li>查看当前栈顶元素节点 2，类似，节点 2 出栈；</li><li>查看当前栈顶元素节点 1，类似，节点 1 出栈。</li></ol><p>上边对这个栈的操作过程应该如下边所示：</p><ol start="0"><li><p>（栈空）</p></li><li><p>节点 1</p></li><li><p>节点 1、节点 2</p></li><li><p>节点 1、节点 2、节点 3</p></li><li><p>节点 1、节点 2、节点 3、节点 4</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 5</p></li><li><p>节点 1、节点 2、节点 3、节点 4</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 7</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 8</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 8、节点 9</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6、节点 8</p></li><li><p>节点 1、节点 2、节点 3、节点 4、节点 6</p></li><li><p>节点 1、节点 2、节点 3、节点 4</p></li><li><p>节点 1、节点 2、节点 3</p></li><li><p>节点 1、节点 2</p></li><li><p>节点 1</p></li><li><p>（栈空）</p></li></ol><h2 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h2><p>BFS 的搜索过程要联系 <strong>队列</strong> 来理解，约定如下：</p><ul><li>已经入队的节点要被标记为已经遍历；</li><li>第一个入队的是节点 1，将其作为最初的队首和队尾；</li><li>遍历与当前队首相连但未被标记的节点，按照数字大小依次入队，并且移动队尾；</li><li>队首移动到下一个元素。</li></ul><p>例如对下边这个图：</p><pre class="mermaid">graph TB;1((1))===2((2))===4((4))===8((8))2((2))===5((5))===8((8))1((1))===3((3))===6((6))===8((8))6((6))===9((9))3((3))===7((7))===9((9))</pre><p>队列维护的情况如下（加粗的表示队首、斜体表示队尾）：</p><ol><li><strong>1</strong>、2、<em>3</em></li><li>1、<strong>2</strong>、3、4、<em>5</em></li><li>1、2、<strong>3</strong>、4、5、6、<em>7</em></li><li>1、2、3、<strong>4</strong>、5、6、7、<em>8</em></li><li>1、2、3、4、<strong>5</strong>、6、7、<em>8</em></li><li>1、2、3、4、5、<strong>6</strong>、7、8、<em>9</em></li><li>1、2、3、4、5、6、<strong>7</strong>、8、<em>9</em></li><li>1、2、3、4、5、6、7、<strong>8</strong>、<em>9</em></li><li>1、2、3、4、5、6、7、8、<strong>9</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
          <category> 搜索算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 搜索算法 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 宽度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为何说三进制是效率最高的进制？以及其他一些与三进制有关的东西...</title>
      <link href="/posts/1d122915.html"/>
      <url>/posts/1d122915.html</url>
      
        <content type="html"><![CDATA[<p>这是一次计算机导论的作业。老师提供了很多课题供我们选择，我选择的是“有人说三进制是被证明理论上效率最高的进制，请广泛搜集相关资料，撰写关于三进制的科普报告，或者对其他进制进行对比和评价。</p><span id="more"></span><h2 id="为什么在理论上三进制是最高效率的进制"><a href="#为什么在理论上三进制是最高效率的进制？" class="headerlink" title="为什么在理论上三进制是最高效率的进制？"></a>为什么在理论上三进制是最高效率的进制？</h2><blockquote><p>这里的内容来自知乎大佬 <a href="https://www.zhihu.com/people/bai-yun-long-52">@白云龙</a>的<a href="https://www.zhihu.com/question/435375360">这篇</a>回答。<br>B站 up 主 <a href="https://space.bilibili.com/19319172">@差评君</a> 的<a href="https://www.bilibili.com/video/BV17b4y1U7TZ/">这个</a>视频中对这篇回答进行了动画形式的展现。</p></blockquote><p>首先，先让我们来约定一下什么叫“进制的效率”：<br>$$<br>进制的效率 &#x3D; \frac{表达的信息量}{表达这些信息所需的资源}<br>$$<br>比如我们需要表达十进制下 <code>0~999</code> 这 1000 个数字，这就是我们 $表达的信息量$，我们选择用写有数字的牌子来表示它们。</p><ul><li><p>在十进制下，<code>0~999</code> 我们至少需要三位，每位上我们都需要 0~9 十个数字的牌子，所以三位一共是 30 个数字牌子；</p></li><li><p>在二进制下，<code>0~999</code> 是 <code>0~1111100111</code>，我们至少需要十位，每位是 0 或 1，所以一共是 20 个数字牌子；</p></li><li><p>在三进制下，<code>0~999</code> 是 <code>0~1101000</code>，至少七位，每位是 0、1 或 2，所以一共是 21 个数字牌子；</p></li><li><p>在四进制下，<code>0~999</code> 是 <code>0~33213</code>，需要 20 个数字牌子；</p></li><li><p>在五进制下，<code>0~999</code> 是 <code>0~12444</code>，需要 25 个数字牌子；</p></li><li><p>…</p></li></ul><p>这些数字牌子的个数就是 $表达这些信息所需的资源$。到目前为止，似乎二进制和四进制的效率最高。</p><p>但这样理解并不完全准确。因为实际上， 对于某些进制而言，对应数量的数字牌子其实不止能表达这么多信息。比如在二进制情况下，20 个数字牌子表达的数字总量应该是 $2^{10} &#x3D; 1024 $ 个；在三进制的情况下，21个数字牌子表达的数字总量却是 $3^7 &#x3D; 2187$ 个；在四进制的情况下，20 个数字牌子表达的数字总量是 $4^5 &#x3D; 1024$ 个…</p><p>也就是说，虽然对于上边十进制而言，它那 30 个牌子表达的信息量确实就是 <code>0~999</code> 这 1000  个数字的信息，或者我们说 1000 种状态信息，但对于下边的比如二进制、三进制、四进制，对应的 20 个、21个、20个牌子其实表达了超过 1000 种状态，我们用这些牌子是有浪费的。</p><p>这么来算，我们大致可以得到，十进制的效率是 $\frac{1000}{30} \approx 33.3333$，二进制的效率是 $\frac{1024}{20} &#x3D; 51.2$，三进制的效率是 $\frac{2187}{21} \approx 104.1429$，四进制的效率是 $\frac{1024}{20} &#x3D; 51.2$…</p><p>从这个例子我们已经大概能看到三进制的效率了，那么怎么证明这件事儿呢？</p><p>回顾上边的思考过程，我们的数字牌子个数是怎么被算出来的呢？我们大概可以总结出：<br>$$<br>数字牌子的个数 &#x3D; 进制数 \times 所需的位数<br>$$<br>而为了满足上边的表达 1000 个状态的要求，所以我们要求：<br>$$<br>进制数^{所需的位数} \geq 1000<br>$$<br>也就是说：<br>$$<br>所需的位数 &#x3D; 向上取整（log_{进制数}1000）<br>$$<br>因为进制数必须是整数，所以我们必须加上 $向上取整$，但就是因为这个向上取整，我们浪费了很多的资源，所以我们先假设 $进制数$ 是个实数。</p><p>那么现在对上面 $数字牌子的个数$ 的式子改成 $表达这些信息所需的资源$，这样这个式子就成了下边这样：<br>$$<br>表达这些信息所需的资源 &#x3D; 进制数 \times log_{进制数}表达的信息量<br>$$<br>记 $表达这些所需的资源$ 为 $R$，$进制数$ 为 $N$，$表达的信息量$ 为 $I$：<br>$$<br>R &#x3D; N \times log_NI<br>$$<br>记效率为 $E$，那么：<br>$$<br>E &#x3D; \frac{I}{R} &#x3D; \frac{I}{Nlog_NI} &#x3D; \frac{I}{lnI}\times\frac{lnN}{N}<br>$$<br>求导<br>$$<br>\frac{dE}{dN} &#x3D; \frac{I}{lnI}\times\frac{1-lnN}{N^2}<br>$$<br>分析单调性，我们知道，当 $N &#x3D; e$ 时，效率 $E$ 最大。</p><p>所以也就是，<code>e 进制</code> 理论上才是效率最高的进制。</p><p>但是，e 进制是个啥呢？试试 e 附近的 2 和 3，得到 $E(2) \approx 0.3466\times\frac{I}{lnI}$，$E(3)\approx 0.3662\times\frac{I}{lnI}$，所以，三进制是理论上效率最高的进制。</p><h2 id="为什么没用三进制"><a href="#为什么没用三进制？" class="headerlink" title="为什么没用三进制？"></a>为什么没用三进制？</h2><p>在上边的两个引用里，知乎大佬 @白云龙 和 b 站 up 主 @差评君 都给出了一些答案。@白云龙 大佬的说法是，在实际的实现过程中，实现二进制的“牌子”和实现三进制的“牌子”的成本不一样，可能二进制的01牌子就便宜好用，但三进制的牌子就是又贵又难用，最后所需的资源还要乘上每个牌子的单价，加上这层因素后，二进制比三进制更经济。这其实也就是 @差评君 所言的，二进制只需高低电平来区分01，但三进制需要实现三种电流状态就比较复杂。</p><p>但其实我觉得，这样的问题并不是什么太大的问题，就像 SLC、MLC、TLC 一样。既然我们都可以在同样的电子数的情况下分别实现 2、4、8种状态的区别，那多实现一个除了01以外的第三个状态似乎也类似？(我瞎说的哦，别当真，大佬轻喷…)。主要是，二进制计算机确实已经走到了这样一个瓶颈期，我们的芯片制程来到了十几纳米甚至几纳米、我们的光刻机使用的光已经来到了极紫外光的情况下，想要进一步提升二进制计算机的一丁点性能所消耗的成本是极其庞大的。但是，三进制却是一条新的路，也许就是一条出路。</p><p>如果我们把视角从全人类缩到我们中国，在这个光刻机远远落后于欧美的情况下，或许三进制，真的就是我们中国的出路。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/435375360">《为什么计算机不用 e 进制，按道理说 e 进制难道不是最高效的吗？ - 知乎 (zhihu.com)》</a></li><li><a href="https://www.bilibili.com/video/BV17b4y1U7TZ/">苏联的三进制电脑，为什么被二进制干掉了？【差评君】哔哩哔哩</a></li><li><a href="https://www.crucial.cn/articles/about-ssd/difference-between-slc-mlc-tlc">《SLC、MLC、TLC 颗粒的区别是什么 | Crucial (英睿达) | Crucial 英睿达》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 进制 </tag>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ const 用法汇总</title>
      <link href="/posts/7ec6ba38.html"/>
      <url>/posts/7ec6ba38.html</url>
      
        <content type="html"><![CDATA[<p>最开始只是用 const 来定义常量，学到了指针传参的时候又知道了用 const 来防止一些值的修改，学到类的时候又看到非静态成员函数后边加个 const 来干嘛干嘛，然后么又听说什么顶层 const、底层 const… 真是越学越迷糊了，赶紧做一波整理。</p><span id="more"></span><h2 id="最基本的用法-定义常量"><a href="#最基本的用法-——-定义常量" class="headerlink" title="最基本的用法 —— 定义常量"></a>最基本的用法 —— 定义常量</h2><p>这个不必多说，直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 正确：a 没有 const 修饰，可以改变其值</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">// 错误：b 有 const 修饰，不能改变其值</span></span><br></pre></td></tr></table></figure><p>除了这个，还有一点是，虽然似乎我们可以通过一些“骚操作”改变 const 修饰的变量（常量?）的值，但是输出的时候，会发现结果并没有改变。看下边的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    <span class="comment">// 奇怪的骚操作</span></span><br><span class="line">    <span class="comment">// 直接 int *p = &amp;x; 是不行的</span></span><br><span class="line">    <span class="comment">// 但这样可以</span></span><br><span class="line">    <span class="comment">// 这样我们就可以通过指针 p 来直接操作那块内存</span></span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是如果加上 <code>volatile</code> 关键词，却可以发现结果也可以跟着变：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是，上边的 <code>const</code> 修饰的都不是全局变量。如果修饰的是全局变量，我们似乎就不能通过指针的小把戏来改变 <code>const</code> 的值了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误代码：</span></span><br><span class="line"><span class="comment">// 这玩意儿能通过编译，但是压根跑不起来</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)&amp;x;</span><br><span class="line">    *p1 = <span class="number">7</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果加上了 <code>volatile</code> 依然可以跑，并且也可以用指针来修改它的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)&amp;y;</span><br><span class="line">    *p2 = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p2 = &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">y = 8</span></span><br><span class="line"><span class="comment">*p2 = 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总结一下，就是——</p><ol><li>如果是局部的 <code>const</code>，那至少有两方面的保护：一是编译检查，看看我们下边的代码是否显而易见地尝试去改变它的值，如果有那就报错；二是编译器的自动优化，编译器会把这个变量的值复制一份放到寄存器里，所以即使我们用指针改变了原来内存里的值，输出的结果还是原来的值（备份到寄存器的原来的值的拷贝），所以当我们使用 <code>voliatile</code> 关键字关闭了编译器的这种优化，让程序每运行到要用到这个 <code>const</code> 修饰的变量的时候都去原来的地址读取值的时候，我们的小把戏成功了。</li><li>如果是全局的 <code>const</code>，还会有其他的机制，具体还没弄清楚，不过你可以看看<a href="https://zhuanlan.zhihu.com/p/145323002">《Linux 系统编程学习总结 （二）ELF - 知乎》</a>这篇文章，也许会有帮助？</li></ol><h2 id="顶层-const-和底层-const"><a href="#顶层-const-和底层-const" class="headerlink" title="顶层 const 和底层 const"></a>顶层 const 和底层 const</h2><p>首先，讨论顶层底层的 const，一般都是对指针变量才有意义。那么啥是顶层 const？啥是底层 const？</p><blockquote><p><strong>顶层 const</strong>（top-level const）表示指针<strong>本身</strong>是个常量;<br><strong>底层 const</strong>（low-level const）表示指针所指的<strong>对象</strong>是一个常量。</p></blockquote><p>举几个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;x;       <span class="comment">// 顶层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;x;       <span class="comment">// 底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;x; <span class="comment">// 左边是底层 const, 右边是顶层 const</span></span><br><span class="line">p1 = &amp;y;                  <span class="comment">// 错误，p1 是顶层 const 修饰的，所以 p1 指向的地址是确定的，无法更改它的指向</span></span><br><span class="line">p2 = &amp;y;                  <span class="comment">// 正确，p2 没有被顶层 const 修饰，这意味着我们可以修改它的指向</span></span><br><span class="line">p3 = &amp;y;                  <span class="comment">// 错误</span></span><br><span class="line">*p1 = y;                  <span class="comment">// 正确，p1 没有被底层 const 修饰，这意味着我们可以修改它指向的值</span></span><br><span class="line">*p2 = y;                  <span class="comment">// 错误，p2 是底层 const 修饰的，我们无法改变它指向的值</span></span><br><span class="line">*p3 = y;                  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>也就是说：</p><ul><li>仅仅被顶层 const 修饰，意味着指针变量的指向无法改变，但可以操作指向的值（指针常量? 指针（地址）是个常量）；</li><li>仅仅被底层 const 修饰，意味着指针变量的指向可以改变，但无法操作指向的值（常量指针？ 指向常量的指针）；</li><li>如果两重修饰，那么就就没办法改变指针的指向，也没办法操作指向的值。</li></ul><p>顺便一说对于引用的情况。因为引用必须初始化并且初始化完成后（起玩别名后就不能改变它引用的对象了），所以 <code>const int &amp;</code> 就是顶层的，并且没有 <code>int &amp; const</code> 这种写法。</p><h2 id="函数中的-const"><a href="#函数中的-const" class="headerlink" title="函数中的 const"></a>函数中的 const</h2><h3 id="参数列表中的-const"><a href="#参数列表中的-const" class="headerlink" title="参数列表中的 const"></a>参数列表中的 const</h3><p>其实就是希望函数运行过程中不改变这个变量的值。比如写函数原型的时候用 <code>const int &amp;</code>，其中 <code>const</code> 表示这个函数对这个变量的操作是只读的，不会改变原来的值，而 <code>&amp;</code> 的作用就是，既然这里只是要读一读这个变量的值，并不对它进行操作，那我就不创建副本了，直接用它自己。</p><h3 id="返回的-const"><a href="#返回的-const" class="headerlink" title="返回的 const"></a>返回的 const</h3><p>这边还没弄清楚，以后弄清楚了再写。</p><h2 id="类的非静态成员函数后边跟的-const"><a href="#类的非静态成员函数后边跟的-const" class="headerlink" title="类的非静态成员函数后边跟的 const"></a>类的非静态成员函数后边跟的 const</h2><p>这样可以让这个函数的 <code>this</code> 是只读的。</p><p>看这篇文章：<a href="https://blog.51cto.com/u_11495341/3040168">《C\C++ 中函数后面加 const_51CTO 博客_c++ const 函数》</a></p><blockquote><p>非静态成员函数后面加 const（加到非成员函数或静态成员后面会产生编译错误）表示成员函数隐含传入的 this 指针为 const 指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对 this 指针的 const 引用）<br>唯一的例外是对于 mutable 修饰的成员。加了 const 的成员函数，可以被非 const 对象和 const 对象调用，但不加 const 的成员函数 只能被非 const 对象调用。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/Forever-Kenlen-Ja/p/3776991.html">《C++ const 用法小结 （欢迎大家拍砖） - karllen - 博客园》</a></li><li><a href="https://zhuanlan.zhihu.com/p/145323002">《Linux 系统编程学习总结 （二）ELF - 知乎》</a></li><li><a href="https://blog.51cto.com/u_11495341/3040168">《C\C++ 中函数后面加 const_51CTO 博客_c++ const 函数》</a></li><li><a href="https://zhuanlan.zhihu.com/p/499784237">《C++ 顶层 const 和底层 const - 知乎》</a></li><li><a href="https://zhuanlan.zhihu.com/p/161560391">《C++ 干货系列 —— 顶层 const 和底层 const - 知乎》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组到底是啥啊...</title>
      <link href="/posts/57fd79a.html"/>
      <url>/posts/57fd79a.html</url>
      
        <content type="html"><![CDATA[<p>一维数组还是比较容易理解的，但是二维数组，我始终没弄清楚这玩意儿是按照什么规则从二维的样子转成一维然后存起来的，也因此常常犯下下标写反了的错误。我觉得是时候详细地理一理这玩意儿到底是个啥了…</p><span id="more"></span><h2 id="怎么转成了一维"><a href="#怎么转成了一维？" class="headerlink" title="怎么转成了一维？"></a>怎么转成了一维？</h2><p>要知道二维数组到底是怎么转成了一维存在内存里，或者说，我到底是应该从前往后（前面的一个数字先不动，先让后边的数字动）读这个数组，还是从后往前（后面的一个数字先不动，先让前面的数字动）读这个数组，其实方法很简单 —— 我们只要把数组里每个元素的地址输出来就行了。比如下边这串代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&amp;a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; &amp;a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;a[0][0] = 0x61fe00</span><br><span class="line">&amp;a[0][1] = 0x61fe04</span><br><span class="line">&amp;a[0][2] = 0x61fe08</span><br><span class="line">&amp;a[1][0] = 0x61fe0c</span><br><span class="line">&amp;a[1][1] = 0x61fe10</span><br><span class="line">&amp;a[1][2] = 0x61fe14</span><br></pre></td></tr></table></figure><p>可以看到，正确的读法应该是：<strong>从前往后，前面的保持不动，从最后一个开始变化。</strong></p><p>也就是说，对于 <code>a[2][3]</code> 这样一个数组，应该这么理解：<code>a[2][3]</code> 前面的 <code>[2]</code> 表示这是一个包含两个元素的数组，后面的 <code>[3]</code> 表示前面所说的两个元素每一个都是包含三个元素的数组。</p><h2 id="赋初值的一些问题"><a href="#赋初值的一些问题" class="headerlink" title="赋初值的一些问题"></a>赋初值的一些问题</h2><p>知道了上边的东西，所以我们知道，我们可以写一个类似 <code>int a[][3] = &#123;0,0,0,0,0,0&#125;;</code> 的玩意儿，却不能写一个 <code>int a[2][] = &#123;0,0,0,0,0,0&#125;</code> 的玩意儿 —— 相当于第二个方括号里边是告诉了编译器后边这一串数字按几个为一组，由于 <code>&#123;&#125;</code> 中元素个数不足是会往后边自动补零的，所以少了这个每组几个的参数，编译器就不知道你这到底有多少个元素了。</p><h2 id="用指向数组的指针数组指针来实现一个其中一维可以动态调整的二维数组"><a href="#用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？" class="headerlink" title="用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？"></a>用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？</h2><p>类似上边的赋初值时候的问题，这个动态的二维数组的内层，也就是按几个为一组的那一层，必须是已经确定的，例如，我们依然创建一个 2*3 的二维数组，其中前面的 2 是在运行时确定的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span>(*p)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">int</span>[n][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i][j] = now;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            cout &lt;&lt; p[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><h2 id="能不能用-int-p-来创建一个两个维度都能变化的二维数组"><a href="#能不能用-int-p-来创建一个两个维度都能变化的二维数组？" class="headerlink" title="能不能用 int** p 来创建一个两个维度都能变化的二维数组？"></a>能不能用 int** p 来创建一个两个维度都能变化的二维数组？</h2><p>不知道啊就是说…</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二维数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当形参、实参是指针变量...</title>
      <link href="/posts/1ef1e20b.html"/>
      <url>/posts/1ef1e20b.html</url>
      
        <content type="html"><![CDATA[<p>接<a href="https://blocklune.github.io/posts/50c16b14.html">《一个有关指针传参的问题》</a>，再理一理这里边的一些问题…</p><span id="more"></span><p>在单向值传递的过程中，我们知道，形参是对实参的值的拷贝。在实参的值传递给形参后，对形参的一切操作，都不会对实参产生什么影响。比如下边这串代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before func(), main(): n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After func(), main(): n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before n++, func(): n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    n++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After n++, func(): n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before func(), main(): n = 5</span><br><span class="line">Before n++, func(): n = 5</span><br><span class="line">After n++, func(): n = 6</span><br><span class="line">After func(), main(): n = 5</span><br></pre></td></tr></table></figure><p>通过打印它们的地址，我们也可以认识到这一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main(): &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;n = &quot;</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In func(): &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;n = &quot;</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In main():</span></span><br><span class="line"><span class="comment">n = 5</span></span><br><span class="line"><span class="comment">&amp;n = 0x61fe1c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In func():</span></span><br><span class="line"><span class="comment">n = 5</span></span><br><span class="line"><span class="comment">&amp;n = 0x61fdf0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果把变量类型从普通类型变成指针类型，那么类似的，发生的其实也是一次值传递，也即，<strong>指针变量的值发生了一次拷贝</strong>，请看下边的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In main(): &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; (<span class="type">int</span> *)p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;p = &quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;In func(): &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; (<span class="type">int</span> *)p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;p = &quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我电脑上的输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In main():</span><br><span class="line">p = 0xee61c0</span><br><span class="line">&amp;p = 0x61fe18</span><br><span class="line"></span><br><span class="line">In func():</span><br><span class="line">p = 0xee61c0</span><br><span class="line">&amp;p = 0x61fdf0</span><br></pre></td></tr></table></figure><p>可以看到，<code>int *</code> 类型的指针变量 <code>p</code> 的值是相同的，但地址不同，这是两个变量。</p><p>把上边代码 <code>main()</code> 中的 <code>p</code> 记为 <code>p1</code>，<code>func()</code> 中的记为 <code>p2</code>，那么就可以这样理解为，当调用 <code>func()</code> 时，<code>p2</code> 与 <code>p1</code> <strong>指向了相同的位置</strong>，但它们确实<strong>不是同一个指针</strong>。</p><p>对于<a href="https://blocklune.github.io/posts/50c16b14.html">《一个有关指针传参的问题》</a>中的那段错误代码，其实错误就是，在函数中 <code>new</code> 出来内存后，只是让形参指向了那片内存，而原来的实参并没有同步地指过去。</p><p>但是只要确定形参的指针和实参的指针指向的地址是相同的，那么对这同一片内存进行的操作，就是同步的，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before func(), main(): (*p) = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After func(), main(): (*p) = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before (*p)++, func(): (*p) = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After (*p)++, func(): (*p) = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before func(), main(): (*p) = 5</span><br><span class="line">Before (*p)++, func(): (*p) = 5</span><br><span class="line">After (*p)++, func(): (*p) = 6</span><br><span class="line">After func(), main(): (*p) = 6</span><br></pre></td></tr></table></figure><p>由于数组名其实就是数组第一个元素（下标为 0 的那个元素）的地址，所以类似的，在函数中对数组形参的操作会等效到数组实参上去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>[], <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(a, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 函数传参 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中使用变量输出小数点位数</title>
      <link href="/posts/45e2d42.html"/>
      <url>/posts/45e2d42.html</url>
      
        <content type="html"><![CDATA[<p>这事儿要从一周前讲起，有人在群里问了这么一道题，要求用 C 实现：</p><span id="more"></span><blockquote><p>习题 2-5 分数化小数（decimal）<br>输入正整数 a,b,c，输出 a&#x2F;b 的小数形式，精确到小数点后 c 位。a,b&lt;&#x3D;10^6，c&lt;&#x3D;100。输入包含多组数据，结束标记为 a&#x3D;b&#x3D;c&#x3D;0。<br>样例输入：<br>1 6 4<br>0 0 0<br>样例输出：<br>0.1667</p></blockquote><p>当时我做了个简化的版本 —— 最多处理 1000 组输入，并且 c 比较小（即不需要高精度）的情况的代码，主要是做一个字符串处理，来构造一个传给 <code>printf()</code> 的格式控制字符串，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 需要用到它的 itoa() 函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 用到strcat拼接字符数组，memset清空字符数组</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅实现了最多有 1000 个输入的情况</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a[<span class="number">1000</span>], b[<span class="number">1000</span>], c[<span class="number">1000</span>], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> ans[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%u%u%u&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (!(a[i] == <span class="number">0</span> &amp;&amp; b[i] == <span class="number">0</span> &amp;&amp; c[i] == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i] = a[i] * <span class="number">1.0</span> / b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> formatMsgP1[] = <span class="string">&quot;%.&quot;</span>;</span><br><span class="line">        <span class="type">char</span> *formatMsgP2;</span><br><span class="line">        <span class="comment">// 根据位数动态确定 char 数组的大小</span></span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; <span class="number">99</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            formatMsgP2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i] &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            formatMsgP2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            formatMsgP2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        itoa(c[i], formatMsgP2, <span class="number">10</span>);</span><br><span class="line">        <span class="type">char</span> formatMsgP3[] = <span class="string">&quot;lf\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> formatMsg[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">strcat</span>(formatMsg, formatMsgP1);</span><br><span class="line">        <span class="built_in">strcat</span>(formatMsg, formatMsgP2);</span><br><span class="line">        <span class="built_in">strcat</span>(formatMsg, formatMsgP3);</span><br><span class="line">        <span class="built_in">printf</span>(formatMsg, ans[i]);</span><br><span class="line">        <span class="built_in">memset</span>(formatMsg, <span class="number">0</span>, <span class="keyword">sizeof</span>(formatMsg)); <span class="comment">// 清空数组</span></span><br><span class="line">        <span class="built_in">free</span>(formatMsgP2);                       <span class="comment">// 释放指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码就比较麻烦，大量的代码都用在字符串拼接了。但今天看到一篇文章（<a href="https://mxte.cc/90.html">《使用变量设定小数点位数》</a>），才知道原来根本不需要那么麻烦。</p><p>本来我的目标是构造这么一个格式控制字符串 <code>%.&lt;c&gt;lf</code>，其中 <code>&lt;c&gt;</code> 需要由用户输入。上边的思路就是输入数字之后用 <code>itoa()</code> 函数把输入的数字转成字符串，然后拼一拼。</p><p>但实际上可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.*lf&quot;</span>, c[i], ans[i]);</span><br></pre></td></tr></table></figure><p>使用 <code>*</code>，<code>printf()</code> 就知道了，需要去后边找这么一个参数。</p><p>所以上边 <code>return 0;</code> 前面那个 <code>for</code> 里那么多东西都只要换成这一句就行了。</p><p>下边贴出一个用动态数组实现的任意组数数据输入的代码（依然没有高精度，我不会啊）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUMS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="type">double</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUMS</span> *<span class="title">p</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">append</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">double</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%u%u%u&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> tmp_ans = a * <span class="number">1.0</span> / b;</span><br><span class="line">            append(c, tmp_ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.*lf\n&quot;</span>, (p + i)-&gt;c, (p + i)-&gt;ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">append</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> _c, <span class="type">double</span> _ans)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS));</span><br><span class="line">        p-&gt;c = _c;</span><br><span class="line">        p-&gt;ans = _ans;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> NUMS *tmp = <span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS));</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, p, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS) * size);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="built_in">calloc</span>(size + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS));</span><br><span class="line">        <span class="built_in">memcpy</span>(p, tmp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> NUMS) * (size + <span class="number">1</span>));</span><br><span class="line">        (p + size)-&gt;c = _c;</span><br><span class="line">        (p + size)-&gt;ans = _ans;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值传递、指针传递、引用传递</title>
      <link href="/posts/c8a20144.html"/>
      <url>/posts/c8a20144.html</url>
      
        <content type="html"><![CDATA[<p>接上文<a href="https://blocklune.github.io/posts/50c16b14.html">《一个有关指针传参的问题》</a>，打算结合一些简单的例子系统地梳理一下 C&#x2F;C++ 中的值传递、指针传递和 C++ 中特有的 引用传递。</p><span id="more"></span><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p><strong>值传递</strong>传递实际上只是在执行函数的时候将实参的值赋给了形参，在此之后函数体内对形参的任何操作都与原来的实参无关了。</p><p>例如下边这个代码 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递 (C++代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of n in func(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of n in func(): &quot;</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    n++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Then the value of n in func(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of n in main(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of n in main(): &quot;</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Then the value of n in main(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递 (C代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of n in func(): %d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The address of n in func(): 0x%x\n&quot;</span>, &amp;n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then the value of n in func(): %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of n in main(): %d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The address of n in main(): 0x%x\n&quot;</span>, &amp;n);</span><br><span class="line">    func(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then the value of n in main(): %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是可能的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The value of n in main(): 0</span><br><span class="line">The address of n in main(): 0x61fe1c</span><br><span class="line">The value of n in func(): 0</span><br><span class="line">The address of n in func(): 0x61fdf0</span><br><span class="line">Then the value of n in func(): 1</span><br><span class="line">Then the value of n in main(): 0</span><br></pre></td></tr></table></figure><p>第二行第四行说明，<code>main()</code> 中的实参 n 与 <code>func()</code> 中的形参 n 存储在内存的不同位置，不是同一个变量。第五第六行说明，对形参 n 的操作，不会影响实参 n。</p><h2 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h2><p><strong>指针传递</strong>也就是传参时不直接传某个参数的值，而是传它的地址。把这个地址作为实参，而形参又是复制实参而来的，所以形参也是原来参数的地址，这样再对形参解除引用，实际上就是对同一内存的值进行操作，所以当然在自定函数中的操作会在主函数中反映出来，请看下边的代码 2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针传递 (C++代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of n(*p) in func(): &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of n(p) in func(): &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Then the value of n(*p) in func(): &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of n in main(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of n in main(): &quot;</span> &lt;&lt; &amp;n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(&amp;n); <span class="comment">// 把想要传递的参数的地址作为实参传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Then the value of n in main(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针传递 (C代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of n(*p) in func(): %d\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The address of n(p) in func(): 0x%x\n&quot;</span>, p);</span><br><span class="line">    (*p)++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then the value of n(*p) in func(): %d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of n in main(): %d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The address of n in main(): 0x%x\n&quot;</span>, &amp;n);</span><br><span class="line">    func(&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then the value of n in main(): %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是可能的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The value of n in main(): 0</span><br><span class="line">The address of n in main(): 0x61fe1c</span><br><span class="line">The value of n(*p) in func(): 0</span><br><span class="line">The address of n(p) in func(): 0x61fe1c</span><br><span class="line">Then the value of n(*p) in func(): 1</span><br><span class="line">Then the value of n in main(): 1</span><br></pre></td></tr></table></figure><p>这实际上就是 <a href="https://blocklune.github.io/posts/50c16b14.html#%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">《一个有关指针传参的问题》- 分析及解决分案</a> 中的代码 2 的思路。只不过这里我们是对 <code>int</code> 类型的普通变量操作，所以函数接受的参数类型是 <code>int*</code>，而在那篇文章中是要对 <code>int*</code>类型的变量操作，所以自定函数接受的参数类型变成了<code>int**</code>。</p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-exclamation-triangle mr-2"></i>注意引用传递是 C++ 的特性，C 没有这个特性。</div></article><p><strong>引用传递</strong>相当于给实参取了个别名，对形参的操作会同步到实参那边去，还是来看下边的代码 3 吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用传递 (C++代码)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of n2 in func(): &quot;</span> &lt;&lt; n2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of n2 in func(): &quot;</span> &lt;&lt; &amp;n2 &lt;&lt; endl;</span><br><span class="line">    n2++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Then the value of n2 in func(): &quot;</span> &lt;&lt; n2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The value of n1 in main(): &quot;</span> &lt;&lt; n1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of n1 in main(): &quot;</span> &lt;&lt; &amp;n1 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(n1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Then the value of n1 in main(): &quot;</span> &lt;&lt; n1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是可能的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The value of n1 in main(): 0</span><br><span class="line">The address of n1 in main(): 0x61fe1c</span><br><span class="line">The value of n2 in func(): 0</span><br><span class="line">The address of n2 in func(): 0x61fe1c</span><br><span class="line">Then the value of n2 in func(): 1</span><br><span class="line">Then the value of n1 in main(): 1</span><br></pre></td></tr></table></figure><p>类似地，<code>int</code> 类型的引用类型是 <code>int&amp;</code>，<code>int*</code> 的引用类型是 <code>int*&amp;</code>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://www.jianshu.com/p/2b5594b876ef">C++ 值传递、指针传递、引用传递 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/dingxiaoqiang/p/8012578.html">C++ 值传递、指针传递、引用传递详解 - zqlucky - 博客园 (cnblogs.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 函数传参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个有关指针传参的问题</title>
      <link href="/posts/50c16b14.html"/>
      <url>/posts/50c16b14.html</url>
      
        <content type="html"><![CDATA[<p>这是我学习指针过程中遇到的一个问题，问过大佬才似乎懂了点，在此记录。顺便记下一句大佬说的话：</p><blockquote><p>注意到一点就行，指针其实也就是个存了内存地址的变量，<strong>它本身同时也具有内存地址</strong>。</p></blockquote><span id="more"></span><h2 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h2><p>事情是这样，学习了一点指针，就想自己实现一个会自动变长的数组。我也不期望把它做成一个类什么的，只有一个小目标，就是实现一个函数，能往这个动态数组后边加元素。我本来的 <strong>错误</strong> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums) <span class="comment">// 如果数组指针不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂存原来的数据</span></span><br><span class="line">        <span class="type">int</span> *tmp_nums = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_nums, nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        <span class="comment">// 释放掉原指针</span></span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">        <span class="comment">// 元素数量 + 1</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(nums, tmp_nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        nums[size] = n;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp_nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp_n;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *nums = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_n = i;</span><br><span class="line">        <span class="built_in">append</span>(nums, size, tmp_n);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调试过程中发现一直会报 <code>Segmentation fault</code>，但是如果改成下边这样，却是可以的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *nums = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums) <span class="comment">// 如果数组指针不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂存原来的数据</span></span><br><span class="line">        <span class="type">int</span> *tmp_nums = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_nums, nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        <span class="comment">// 释放掉原指针</span></span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">        <span class="comment">// 元素数量 + 1</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(nums, tmp_nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        nums[size] = n;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp_nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp_n;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_n = i;</span><br><span class="line">        <span class="built_in">append</span>(size, tmp_n);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改动的内容就是把原来的数组变成了全局的。局部的不正常，全局就对了，所以猜测，类似是形参和实参的区别。大佬们帮我分析了分析，提出了下边的解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> **, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp_n;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *nums = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">51</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_n = i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        nums 是一个指针，这个指针是我们动态数组的第一个元素的地址</span></span><br><span class="line"><span class="comment">        对 nums 取地址传参，传的是 nums 这个指针的地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">append</span>(&amp;nums, size, tmp_n);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接上文的注释</span></span><br><span class="line"><span class="comment">ptr 是一个指针，这个指针是上边的 nums 的地址</span></span><br><span class="line"><span class="comment">*ptr 得到了这个地址的值，这个值是指向动态数组第一个元素的指针</span></span><br><span class="line"><span class="comment">**ptr 是第一个元素的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> **ptr, <span class="type">int</span> size, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*ptr) <span class="comment">// 如果数组指针不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂存原来的数据</span></span><br><span class="line">        <span class="type">int</span> *tmp_nums = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp_nums, *ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        <span class="comment">// 释放掉原指针</span></span><br><span class="line">        <span class="keyword">delete</span>[] * ptr;</span><br><span class="line">        <span class="comment">// 元素数量 + 1</span></span><br><span class="line">        *ptr = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(*ptr, tmp_nums, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">        (*ptr)[size] = n;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp_nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (*ptr) = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">        (*ptr)[<span class="number">0</span>] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行结果就正常了。</p><h2 id="分析及解决方案"><a href="#分析及解决方案" class="headerlink" title="分析及解决方案"></a>分析及解决方案</h2><p><strong>2022 年 11 月 16 日更新：</strong>这边写的错误原因有点乱，我重新写了一篇：<a href="https://blocklune.github.io/posts/1ef1e20b.html">《当形参、实参是指针变量…》</a></p><p>下边给出两个简化的代码来解释这个问题。</p><p>首先来看代码 1，是对上边错误代码的简化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMemory</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;The pointer in getMemory() points at:&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;The address of the pointer in getMemory():&quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">getMemory</span>(p);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;The pointer in main() points at:&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;The address of the pointer in main():&quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是代码 1 对应的程序的一个可能的输出 (具体内存地址可能不同):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The pointer in getMemory() points at: 0x10161c0</span><br><span class="line">The address of the pointer in getMemory(): 0x61fdf0</span><br><span class="line">The pointer in main() points at: 0x10</span><br><span class="line">The address of the pointer in main(): 0x61fe18</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>getMemory()</code> 中的 <code>int*</code> 类型的指针 p 与 <code>main()</code> 中的 <code>int*</code> 类型的指针 p <strong>并不是同一个指针</strong>（存储这两个指针的内存地址不一样，在 <code>getMemory()</code> 中的指针 p 存储在 0x61fdf0，而 <code>main()</code> 中的存储在 0x61fe18），所以虽然我们在 <code>getMemory()</code> 中 new 得了存储空间（<code>getMemory()</code> 中的指针 p 指向了 0x10161c0），但这实际上只是为 <code>getMemory()</code> 中的指针 p 申请了存储空间，<code>main()</code> 中的指针 p 并没有申请到空间（<code>main()</code> 中的指针 p 指向了 0x10）。</p><p>也即，我们自己的函数中的指针是一个副本，给这个指针申请空间的操作并没有实现给 <code>main()</code> 中的同名指针也申请到空间！</p><p>接着是代码 2，类似于上边的正确解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMemory2</span><span class="params">(<span class="type">int</span> **p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The pointer in getMemory() points at:&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of the pointer in getMemory():&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1;</span><br><span class="line">    <span class="built_in">getMemory2</span>(&amp;p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The pointer in main() points at:&quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of the pointer in main():&quot;</span> &lt;&lt; &amp;p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是代码 2 对应的程序的一个可能的输出 (具体内存地址可能不同):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The pointer in getMemory() points at: 0x7461c0</span><br><span class="line">The address of the pointer in getMemory(): 0x61fe18</span><br><span class="line">The pointer in main() points at: 0x7461c0</span><br><span class="line">The address of the pointer in main(): 0x61fe18</span><br></pre></td></tr></table></figure><p>从 <code>main()</code> 开始看，p1 是一个 <code>int*</code> 类型的指针。与上边代码 1 不同，现在 <code>getMemory2()</code> 这个函数接受的参数是指针的指针，也就是指针的地址，所以我们传入的是 <strong>&amp;p1</strong>，也就是指针 p1 的地址。</p><p>再看 <code>getMemory2()</code> 函数，传入参数后，相当于现在 p2 &#x3D; &amp;p1，那么 *p2 &#x3D; p1。这里的 “&#x3D;” 表示 “就是” 而非赋值，所以我们对于 *p2 进行的任何操作，与对 p1 进行的操作都是等效的。</p><p>还有一种解决方案 —— 使用引用传递，对于上边的问题也就是使用 <code>int* &amp;</code> 类型，代码 3 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMemory</span><span class="params">(<span class="type">int</span> *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The pointer in getMemory() points at: &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of the pointer in getMemory(): &quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">getMemory</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The pointer in main() points at: &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The address of the pointer in main(): &quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要将上边的代码 1 中 <code>void getMemory(int *p)</code> 改为 <code>void getMemory(int *&amp;p)</code> 就行了，下边是可能的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The pointer in getMemory() points at: 0x10261c0</span><br><span class="line">The address of the pointer in getMemory(): 0x61fe18</span><br><span class="line">The pointer in main() points at: 0x10261c0</span><br><span class="line">The address of the pointer in main(): 0x61fe18</span><br></pre></td></tr></table></figure><p>可以看到已经实现了我们想要的效果。</p><p>也可以参考参考这篇文章：<a href="https://developer.aliyun.com/article/297093">《C++ 函数的传入参数是指针的指针（**）的详解》</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 问题 </tag>
            
            <tag> 已解决 </tag>
            
            <tag> 函数传参 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 中赋值语句的返回值问题</title>
      <link href="/posts/9693ba6.html"/>
      <url>/posts/9693ba6.html</url>
      
        <content type="html"><![CDATA[<p>我曾经一直以为 C&#x2F;C++ 中赋值语句的返回值不是 0 就是 1 —— 成功执行赋值操作返回 1，没有成功执行就返回 0。直到今天课上的一个例子，才让我知道，原来<strong>赋值语句的返回值就是赋的值的大小</strong>！</p><span id="more"></span><p>起因是下边的这道题目：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 下边各个循环的执行次数是多少：</span></span><br><span class="line"><span class="comment">// 1: 死循环</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2：0 次循环</span></span><br><span class="line"><span class="keyword">for</span> (; i = <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3：0 次循环</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4：死循环</span></span><br><span class="line"><span class="keyword">while</span> (i = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个因为 for 语句的第二个参数缺失，所以该循环不会停止；第三个初值<code>i=0;</code>即不满足<code>i&lt;0;</code>，故不执行。</p><p>第四个，按照我错误的理解，赋值成功返回 1，所以说得通是<code>while(true)</code>永远执行，但四二个却无法这么解释了。去试了试写个下边两个东西输出赋值语句的返回值，才发现原来<strong>赋值语句的返回值就是赋的值</strong>。</p><p>C 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">5</span>, c = <span class="number">-5</span>, d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(d = a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(d = b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(d = c));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">5</span>, c = <span class="number">-5</span>, d;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(d = a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(d = b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">int</span>(d = c) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果均如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br><span class="line">-5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 格式化输入输出汇总</title>
      <link href="/posts/b4e7acd7.html"/>
      <url>/posts/b4e7acd7.html</url>
      
        <content type="html"><![CDATA[<p>本文汇总一下 C 语言 <code>scanf</code> 和 <code>printf</code> 的格式控制方法以及 C++ 的 <code>&lt;iomanip&gt;</code> 库。</p><span id="more"></span><h1 id="c-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h1><p>此处内容来源于 《C Primer Plus （第 6 版）中文版》。</p><h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf() 函数"></a>printf() 函数</h2><h3 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h3><p>ANSI C 中 printf() 的转换说明（P69，表 4.3：转换说明及其打印的输出结果）</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><table><thead><tr><th>转换说明</th><th>打印的结果</th></tr></thead><tbody><tr><td>%d &#x2F; %i</td><td>有符号十进制整数</td></tr><tr><td>%u</td><td>无符号十进制整数</td></tr><tr><td>%o</td><td>无符号八进制整数</td></tr><tr><td>%x</td><td>无符号十六进制整数，使用十六进制数 0f</td></tr><tr><td>%X</td><td>无符号十六进制整数，使用十六进制数 0F</td></tr><tr><td>%a &#x2F; %A</td><td>十六进制数、浮点数和 p 计数法（C99&#x2F;C11）</td></tr></tbody></table><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><table><thead><tr><th>转换说明</th><th>打印的结果</th></tr></thead><tbody><tr><td>%e &#x2F; %E</td><td>浮点数，e 计数法</td></tr><tr><td>%f</td><td>浮点数，十进制计数法</td></tr><tr><td>%g &#x2F; %G</td><td>根据值的不同，自动选择 %f 或 %e &#x2F; %E。%e &#x2F; %E 格式用于指数小于-4 或大于等于精度时。</td></tr><tr><td>%a &#x2F; %A</td><td>十六进制数、浮点数和 p 计数法（十六进制指数计数法）（C99&#x2F;C11）</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>转换说明</th><th>打印的结果</th></tr></thead><tbody><tr><td>%c</td><td>单个字符<strong>（包括空白字符）</strong></td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%p</td><td>指针</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table><h3 id="转换说明修饰符"><a href="#转换说明修饰符" class="headerlink" title="转换说明修饰符"></a>转换说明修饰符</h3><p>（P71，表 4.4：printf()的修饰符）：</p><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td><strong>标记</strong></td><td>共 5 种（-, +, 空格, # , 0）</td></tr><tr><td><strong>数字</strong></td><td>最小字段宽度（不够自动变宽）</td></tr><tr><td><strong>.数字</strong></td><td>精度（具体见下边说明）</td></tr><tr><td><strong>h</strong></td><td>和整型转换说明一起使用，表示 short int 或 unsigned short int</td></tr><tr><td>hh</td><td>和整型转换说明一起使用，表示 signed char 或 unsigned char</td></tr><tr><td>j</td><td>和整型转换说明一起使用，表示 intmax_t 或 uintmax_t （这些类型定义在 &lt;stdint.h&gt; 中）</td></tr><tr><td><strong>l</strong></td><td>和整型转换说明一起使用，表示 long int 或 unsigned long int（和浮点型转换说明构成 %lf，表示 double）</td></tr><tr><td><strong>ll</strong></td><td>和整型转换说明一起使用，表示 long long int 或 unsigned long long int（C99）</td></tr><tr><td><strong>L</strong></td><td>和浮点转换说明一起使用，表示 long double 类型的值</td></tr><tr><td>t</td><td>和整型转换说明一起使用，表示 ptrdiff_t （ptrdiff_t 是两个指针差值的类型，C99）</td></tr><tr><td>z</td><td>和整型转换说明一起使用，表示 size_t （size_t 是 sizeof 返回的类型，C99）</td></tr></tbody></table><blockquote><p>上边的 <strong>.数字</strong>：</p><p>对于 %e、%E、%f，表示小数点右边数字的位数；</p><p>对于 %g、%G，表示有效数字的最大位数；</p><p>对于 %s，表示待打印字符的最大数量；</p><p>对于整型转换，表示待打印数字的最小位数，如有必要，使用前导 0 来达到这个位数。</p><p>只是用 . 表示其后跟随了一个 0，所以 %.f 和 %.0f 相同。</p></blockquote><p>（P72，表 4.5：printf()中的标记）：</p><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>有符号值前加正负号</td></tr><tr><td>空格</td><td>有符号值正不加，负加负号</td></tr><tr><td>#</td><td>把结果转换为另一种形式，具体看下边</td></tr><tr><td>0</td><td>对于数值格式，用前导 0 代替空格填充字段宽度。对于整数格式，如果出现-标记或者指定精度，则忽略该标记</td></tr></tbody></table><blockquote><p># 的说明：</p><p>%o：以 0 开始；</p><p>%x &#x2F; %X：以 0x &#x2F; 0X 开始；</p><p>所有浮点格式：保证即使后边没有任何数字，也打印一个小数点字符；</p><p>%g &#x2F; %G：防止结果后边的 0 被删除。</p></blockquote><h2 id="scanf函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h2><p>大部分与上边相同，只讲不一样的。</p><p>（P80，表 4.7：scanf()转换说明中的修饰符）：</p><table><thead><tr><th>转换说明</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>抑制赋值</td></tr><tr><td>数字</td><td>最大字符宽度。输入达到这个宽度或者第一次遇到空白字符时停止。</td></tr></tbody></table><p>scanf() 的返回值是成功读取的项数。如果没有读取任何项，则返回 0；如果检测到“文件结尾”，返回 EOF （EOF 是定义 &lt;stdio.h&gt; 中定义的特殊值，一般用 #define 定义为 -1）。</p><p><strong>注意：</strong>输入数字的时候，在不设置分隔符号时，scanf()默认使用空白字符进行分隔；但是输入字符时，空白字符不会被忽略，而是被顺利读入。</p><p>比如下边这道题：</p><p>有如下程序段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1, a2;</span><br><span class="line"><span class="type">char</span> c1, c2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d%c&quot;</span>, &amp;a1, &amp;c1, &amp;a2, &amp;c2);</span><br></pre></td></tr></table></figure><p>若要求 a1, a2, c1, c2 的值分别为 10, 20, A, B，正确的数据输入是（ ）：</p><p>A. 10A20 B&lt;CR&gt;</p><p>B. 10 A 20 B&lt;CR&gt;</p><p>C. 10 A20B&lt;CR&gt;</p><p>D. 10A 20B&lt;CR&gt;</p><p>正确答案为 D。</p><h1 id="c"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>参考：<a href="https://blog.csdn.net/Jacky_Feng/article/details/109119782">【C++】C++标准库之 iomanip 库（格式输入输出）_Jacky_Feng 的博客-CSDN 博客</a></p><table><thead><tr><th>控制符</th><th>作用</th></tr></thead><tbody><tr><td>oct</td><td>八进制输入&#x2F;输出</td></tr><tr><td>dec</td><td>十进制输入&#x2F;输出</td></tr><tr><td>hex</td><td>十六进制输入&#x2F;输出</td></tr><tr><td>setbase(n)</td><td>设置为 n 进制 (n &#x3D; 8, 10, 16)</td></tr><tr><td>setprecision(n)</td><td>设置浮点数的有效数字为 n 位</td></tr><tr><td>setfill(c)</td><td>设置字符填充为 c</td></tr><tr><td>setw(n)</td><td>设置宽度</td></tr><tr><td>setiosflags(ios::fixed)</td><td>设置浮点数以固定的小数位数显示</td></tr><tr><td>setiosflags(ios::scientific)</td><td>设置浮点数以科学计数法表示</td></tr><tr><td>setiosflags(ios::left)</td><td>输出左对齐</td></tr><tr><td>setiosflags(ios::right)</td><td>输出右对齐</td></tr><tr><td>setiosflags(ios::skipws)</td><td>忽略前导空格</td></tr><tr><td>setiosflags(ios::uppercase)</td><td>在以科学计数法输出 E 与十六进制输出 X 以大写输出，否则小写</td></tr><tr><td>setiosflags(ios::showpos)</td><td>输出正数时显示”+”号</td></tr><tr><td>setiosflags(ios::showpoint)</td><td>强制显示小数点</td></tr><tr><td>resetiosflags()</td><td>终止已经设置的输出格式状态，在括号中应指定内容</td></tr></tbody></table><p>更多请见：<a href="https://www.w3cschool.cn/doc_cpp/cpp-header-iomanip.html">iomanip CPP 官方教程 _w3cschool</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> iomanip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖老婆矿！—— NovelAI 初试</title>
      <link href="/posts/f17b3e8b.html"/>
      <url>/posts/f17b3e8b.html</url>
      
        <content type="html"><![CDATA[<p>最近一段时间，感觉突然之间，就有很多很多将现实图片二次元化啊，按照每句歌词生成一副画作啊的 AI 绘画应用的图文视频出现。和室友聊天还说是不是最近一段时间 AI 技术突破什么瓶颈突飞猛进了。后来才知道，原来是 NovelAI 泄露了… 这样一来，本地部署方便了起来，于是整了一个玩玩。由于跑 AI 嘛，GPU 比较呼啸，跟挖矿一样，我就戏称我这是在“挖老婆矿”了。</p><span id="more"></span><p>注：这篇文章更偏向于我记录生成时使用的 tag， 不涉及基础操作。我使用的 NovelAI 下载自<a href="https://www.bilibili.com/video/BV1EV4y1L7dX">这里</a>。</p><h1 id="一个头像一堆头像"><a href="#一个头像（一堆头像）" class="headerlink" title="一个头像（一堆头像）"></a>一个头像（一堆头像）</h1><p>我最开始只是用几个 tag 生成。经历了一些粗浅的尝试后，发现生成的质量并不高。但是看到了<a href="https://www.yuque.com/longyuye/lmgcwy/goa36x">一篇文章</a>，照着里边的 tag 写，才算真正开始了探索。</p><p>首先是根据上边那篇文章最后的示例增改了点 tag 形成的 prompt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blue pen illustration, light blue background, flowers on face, growth, nature, beautiful face, pink hair,shawl hair, zoom in on eyes, apathy, red eye shadow, petite, best quality, masterpiece</span><br></pre></td></tr></table></figure><p>然后生成出了下面这些相当不错的图案：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0HgAK.jpg"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0H676.jpg"></p><p>下边分类讲讲 tag:</p><p>提高总体质量的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterpiece, best quality, by famous artist, beautiful face</span><br></pre></td></tr></table></figure><p>使整体的风格偏向更具插画感：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">illustration</span><br></pre></td></tr></table></figure><p>限定背景的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx + backgroud  (比如上边的淡蓝色背景就是 light blue background )</span><br></pre></td></tr></table></figure><p>让生成出来的 waifu 更幼的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">petite</span><br></pre></td></tr></table></figure><p>让脸上、头发上出现花朵装饰的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowers on face</span><br></pre></td></tr></table></figure><p>让眼睛更大的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zoom in one eyes</span><br></pre></td></tr></table></figure><p>尝到了甜头后，我就想换头像了。但我不想完全抛弃现在的头像，于是就试图拿它做派生。</p><p>首先描述一下原来的头像，让 AI 知道我大概是想要怎样的一个 “老婆”。<del>（虽然其实我描述的时候更感觉是在捏女儿）</del> 顺便一说，我这个原来的头像其实也是 AI 生成的，叫 <a href="https://waifulabs.com/generate">WaifuLabs</a>，是我把原来生成出来的丢进 PS 去了水印，又自己修缮了一下得到的。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0I1Z8.jpg" alt="上边是 WaifuLabs 生成出来时候的样子，下边是我自己 PS 改的"></p><p>抛却那些提高质量的，大概给了 <code>披肩发</code>、<code>深灰色头发</code>、<code>深灰色眼睛</code>、<code>红色眼影</code>、<code>白色衬衫</code>、<code>微笑</code> 这些 tag。同时模仿了上边，给了 <code>面部的花</code> 之类的 tag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;masterpiece,best quality&#125;&#125;,shawl hair,dark grey hair, dark grey eyes,red eye shadow,  white shirt,illustration,flower on face,growth, nature,beautiful face, smile, zoom in one eyes</span><br></pre></td></tr></table></figure><p>以上边的内容为 prompt，同时把我改的那张扔给 NovelAI，根据生成结果又慢慢改，添加 tag，最终的 prompt 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;masterpiece,best quality,by wlop&#125;&#125;,shawl hair,dark grey hair, dark grey eyes,red eye shadow, white shirt,&#123;&#123;&#123;illustration&#125;&#125;&#125;,flower on face, growth, nature, beautiful face, small smile, zoom in one eyes, &#123;&#123;&#123;&#123;petite&#125;&#125;&#125;&#125;, dramatic shadows, ink,eye-focus, portrait, red hairclip</span><br></pre></td></tr></table></figure><p>跑了大概 100 张，然后挑了挑，下边展示的是部分高质量的：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0IgzR.png"></p><p>又是一波奇奇怪怪的调整：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0onkF.png"></p><p>最后挑选出了这张我觉得挺有特色的：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0o161.png"></p><p>然后开始根据这张进行派生：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0jbEn.png"></p><h1 id="一张壁纸一堆壁纸"><a href="#一张壁纸（一堆壁纸）" class="headerlink" title="一张壁纸（一堆壁纸）"></a>一张壁纸（一堆壁纸）</h1><p>这事儿开始的挺搞笑的，当时我正在调上边的头像参数，坐我旁边玩 CSGO 的朋友希望我把某把枪拟人，然后发我了下边的图片：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0TGgs.jpg"></p><p>然后我加了点描述词生成了，但生成效果并不好，我就又开始研究我上边的头像了。我完全忘记了我还拿着这张图生成的某张图在做派生呢… 我只是改回了我的 prompt，就意外地得到了下边这张图：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x0TI8H.png"></p><p>似乎是把枪头画成了那条条纹？我也不知道。反正着实是惊艳到我了，扔到 bigjpg 那边提高了一下分辨率，再扔进 PS 调了一下曲线，嘿嘿，新的手机壁纸有了！</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x07eG4.png" alt="拉的曲线"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x07Prq.png" alt="新的手机壁纸！"></p><p>然后又拿这张图和基于上边改的 prompt 做了派生…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;masterpiece,best quality&#125;&#125;,shawl hair,dark grey hair, dark grey eyes,red eye shadow,red scanf,  light grey shirt,&#123;&#123;illustration&#125;&#125;,red flower on face,white flower on hair,growth, nature,beautiful face, &#123;&#123;indifferent&#125;&#125;, zoom in one eyes,1girl, red flower background, gold fence background,focus on eye</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x07XO1.jpg"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/15/x07vex.jpg"></p><p>相当不错！</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> AI </category>
          
          <category> NovelAI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> NovelAI </tag>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 中文乱码问题</title>
      <link href="/posts/ca05bed5.html"/>
      <url>/posts/ca05bed5.html</url>
      
        <content type="html"><![CDATA[<p><strong>2023 年 1 月 12 日更新：</strong> 找到了方便地改变 Windows 中终端默认编码的方法，所以原来的改变 C&#x2F;C++ 文件默认编码的方法可以淘汰了。</p><span id="more"></span><p>现在的新办法是：</p><p>打开 “控制面板 - 时钟和区域 - 区域 - 管理 - 更改系统区域设置(C)…”</p><p>勾选 “Beta 版: 使用 Unicode UTF-8 提供全球语言支持(U)”</p><p>确定，重启电脑。</p><p>打开 CMD 测试一下，输入 <code>chcp</code> 可以发现已经变成了 <code>65001</code>，说明成功了。</p><p>方法来源：<a href="https://blog.csdn.net/weixin_44285445/article/details/112325994">《Git Bash 中文显示乱码，options 修改为 zh_CN 和 utf-8 还是不行怎么办？看这里_bboy 枫亭的博客 - CSDN 博客_git +options》</a></p><p><strong>以下是原来的文章</strong></p><p>开门见山，我最后采用的解决方案是对 C&#x2F;C++ 文件单独设置默认编码。大致的操作方法是，打开 VS Code 的 <code>settings.json</code> 文件，添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;[cpp]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;files.encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gbk&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;[c]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;files.encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gbk&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>具体的操作请参见原文：<a href="https://blog.csdn.net/qq_45538473/article/details/107258234">《VSCODE C 语言终端输出中文乱码编码设置》</a></p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>复盘一下解决这个问题的过程。</p><p>首先了解到的是 VS Code 中文乱码的根本原因——VS Code 默认的编码格式是 UTF-8 （这一点可在 VS Code 右下角看到），而 VS Code 调用的终端是 CMD，默认的编码格式是 gbk。所以解决方案就是两个方向：要么是更改终端的默认编码，从默认的 gbk 转为 utf8；要么就是更改 VS Code 中的 C&#x2F;C++ 文件的编码。</p><p><strong>2022&#x2F;10&#x2F;26 更新：</strong></p><p>看到一个有意思的科普视频，贴在这里，可以看看乱码到底是如何产生的。</p><div class="bvideo"><a href="//www.bilibili.com/video/BV1cB4y177QR" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://pic1.xuehuaimg.com/proxy/http://i0.hdslb.com/bfs/archive/95d3c1239ff3a3216e2b1bad6f280a530105078d.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:15:00</span>            </div>            <div class="bvideo-info">                <p class="title">锟斤拷�⊠是怎样炼成的——中文显示“⼊”门指南【柴知道】</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>419.6万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>1.9万</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">柴知道</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h3 id="第一个方向更改终端默认编码"><a href="#第一个方向：更改终端默认编码" class="headerlink" title="第一个方向：更改终端默认编码"></a>第一个方向：更改终端默认编码</h3><p>了解到更改 CMD 编码为 utf8 的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure><p>顺便一提，查看当前编码的命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp</span><br></pre></td></tr></table></figure><p><code>chcp 65001</code> 这串命令的意思就是更改代码页为 65001，也就是用 utf8 编码。</p><p>这串命令不是永久生效的，所以每次都要输入，比较麻烦。网上也有一些解决方案，比如通过修改注册表每次都自动运行一下上边的命令（<a href="https://www.jianshu.com/p/f40e494dc01d">《修改 Windows10 命令终端 cmd 的编码为 UTF-8》</a>），或者是配置 VS Code 让其自动输入的（<a href="https://blog.csdn.net/lzyws739307453/article/details/89823900">《永久解决 VS Code 终端中文乱码问题》</a>），可以去看看。</p><h3 id="第二个方向更改-vs-code-中的-cx2fc-文件的编码"><a href="#第二个方向：更改-VS-Code-中的-C-x2F-C-文件的编码" class="headerlink" title="第二个方向：更改 VS Code 中的 C&#x2F;C++ 文件的编码"></a>第二个方向：更改 VS Code 中的 C&#x2F;C++ 文件的编码</h3><p>最初这个方法我只是想临时解决一下，就比较简单。点一下右下角的 UTF-8，选择 <code>通过编码重新打开</code>，选择 gbk 就行了。但这样只有一次，然后就想看看有没有永久的方法，便看到了上边的文章。</p><p>顺便一提，这里可能还要把 VS Code 设置中的自动猜测编码功能打开，具体操作如下：</p><ol><li>使用 <code>Ctrl + ,</code> 快捷键打开设置；</li><li>在搜索框输入 <code>encoding</code> ，找到 <code>Files:Auto Guess Encoding</code>，勾上它。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_45538473/article/details/107258234">《VSCODE C 语言终端输出中文乱码编码设置》</a></li><li><a href="https://www.jianshu.com/p/f40e494dc01d">《修改 Windows10 命令终端 cmd 的编码为 UTF-8》</a></li><li><a href="https://blog.csdn.net/lzyws739307453/article/details/89823900">《永久解决 VS Code 终端中文乱码问题》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> VS Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 问题 </tag>
            
            <tag> 已解决 </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中与(&amp;&amp;)和或(||)运算符的短路运算</title>
      <link href="/posts/13d09bbb.html"/>
      <url>/posts/13d09bbb.html</url>
      
        <content type="html"><![CDATA[<p>此篇笔记来源于下边的这个题目。<br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/10/12/xaK5c9.png"></p><span id="more"></span><p>本来以为结果为 3，但是实际跑了一下发现结果是 1。请教了一下大佬知道了这叫做或运算符（||）的短路运算。</p><p>正常来说，或运算中只要有一个为真，结果就为真。所谓或的短路运算就是说，如果已经出现了真，那么后续的运算就不会进行了。以上面的题目为例就是，因为第一个 ++x 这个运算结果肯定为真，那么后面的另外两个 ++x 就不会运行。</p><p>类似的，还有与（&amp;&amp;）的短路运算。正常来说，与运算中必须所有均为真，结果才为真。所以与的短路就是，如果前面的运算结果已经有假了，那么就可以确定这个与运算总体的结果为假，也就不会运行后边的运算了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icarus 主题自带的标签插件的使用以及官方文档中的常用消息框模板</title>
      <link href="/posts/8ffe9166.html"/>
      <url>/posts/8ffe9166.html</url>
      
        <content type="html"><![CDATA[<p>之前有写过使用 Bulma 美化博文的方法，然后才发现原来 Icarus 本身就带了很多标签插件可供直接使用。而官方文档中的横跨文章的提示框、警告框什么的我找遍了文档也没发现作者告诉我了调用的办法，直到今天才看到大佬的一篇文章讲到原来那些本身就是用原生 html 写的。所以写下此篇笔记，方便以后用。</p><span id="more"></span><h1 id="官方自带标签插件"><a href="#官方自带标签插件" class="headerlink" title="官方自带标签插件"></a>官方自带标签插件</h1><p>官方文档：<a href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/%E8%87%AA%E5%AE%9A%E4%B9%89hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/">《自定义Hexo标签插件 - Icarus》</a></p><h2 id="消息框"><a href="#消息框" class="headerlink" title="消息框"></a>消息框</h2><h3 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %&#125;</span><br><span class="line">    &lt;内容&gt;</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><h4 id="color颜色"><a href="#color-颜色" class="headerlink" title="color(颜色)"></a>color(颜色)</h4><p>可选参数，可能值、实现方法和效果见下方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message title:default %&#125;</span><br><span class="line">    一个没有设置颜色的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message">        <div class="message-header"><p>default</p></div>        <div class="message-body">            <p>一个没有设置颜色的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:dark title:dark %&#125;</span><br><span class="line">    一个深色(dark)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-dark">        <div class="message-header"><p>dark</p></div>        <div class="message-body">            <p>一个深色(dark)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:primary title:primary %&#125;</span><br><span class="line">    一个主题色(primary)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-primary">        <div class="message-header"><p>primary</p></div>        <div class="message-body">            <p>一个主题色(primary)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:info title:info %&#125;</span><br><span class="line">    一个提示色(info)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-info">        <div class="message-header"><p>info</p></div>        <div class="message-body">            <p>一个提示色(info)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:success title:success %&#125;</span><br><span class="line">    一个成功色(success)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-success">        <div class="message-header"><p>success</p></div>        <div class="message-body">            <p>一个成功色(success)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:warning title:warning %&#125;</span><br><span class="line">    一个警告色(warning)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-warning">        <div class="message-header"><p>warning</p></div>        <div class="message-body">            <p>一个警告色(warning)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:danger title:danger %&#125;</span><br><span class="line">    一个危险色(danger)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-danger">        <div class="message-header"><p>danger</p></div>        <div class="message-body">            <p>一个危险色(danger)的消息框。</p>        </div>    </article><h4 id="size尺寸"><a href="#size-尺寸" class="headerlink" title="size(尺寸)"></a>size(尺寸)</h4><p>可选参数，可能值、实现方法和效果见下方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message size:small title:small %&#125;</span><br><span class="line">    一个小(small)消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-small">        <div class="message-header"><p>small</p></div>        <div class="message-body">            <p>一个小(small)消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message title:default %&#125;</span><br><span class="line">    一个默认大小的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message">        <div class="message-header"><p>default</p></div>        <div class="message-body">            <p>一个默认大小的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message size:medium title:medium %&#125;</span><br><span class="line">    一个中(medium)消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-medium">        <div class="message-header"><p>medium</p></div>        <div class="message-body">            <p>一个中(medium)消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message size:large title:large %&#125;</span><br><span class="line">    一个大(large)消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-large">        <div class="message-header"><p>large</p></div>        <div class="message-body">            <p>一个大(large)消息框。</p>        </div>    </article><h4 id="icon图标"><a href="#icon-图标" class="headerlink" title="icon(图标)"></a>icon(图标)</h4><p>可选参数，来源 <a href="https://fontawesome.com/search">FontAwesome</a>，类名中间含空格的<strong>加引号</strong>！</p><p>一些例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:success icon:&quot;fa-solid fa-circle-check&quot; title:&quot;fa-solid fa-circle-check&quot; %&#125;</span><br><span class="line">    一个外部带圈的勾。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-success">        <div class="message-header"><p><i class="fa-solid fa-circle-check mr-2"></i>fa-solid fa-circle-check</p></div>        <div class="message-body">            <p>一个外部带圈的勾。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:warning icon:&quot;fa-solid fa-triangle-exclamation&quot; title:&quot;fa-solid fa-triangle-exclamation&quot; %&#125;</span><br><span class="line">    一个警告标志。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-warning">        <div class="message-header"><p><i class="fa-solid fa-triangle-exclamation mr-2"></i>fa-solid fa-triangle-exclamation</p></div>        <div class="message-body">            <p>一个警告标志。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:danger icon:&quot;fa-solid fa-circle-exclamation&quot; title:&quot;fa-solid fa-circle-exclamation&quot; %&#125;</span><br><span class="line">    一个错误标志。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-danger">        <div class="message-header"><p><i class="fa-solid fa-circle-exclamation mr-2"></i>fa-solid fa-circle-exclamation</p></div>        <div class="message-body">            <p>一个错误标志。</p>        </div>    </article><h4 id="title标题"><a href="#title-标题" class="headerlink" title="title(标题)"></a>title(标题)</h4><p>可选参数，中间含空格的<strong>加引号</strong>！</p><p>有标题的上面已经演示过，下面是各种没有标题的消息框。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message %&#125;</span><br><span class="line">    一个没有设置颜色的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message">                <div class="message-body">            <p>一个没有设置颜色的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:dark %&#125;</span><br><span class="line">    一个深色(dark)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-dark">                <div class="message-body">            <p>一个深色(dark)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:primary %&#125;</span><br><span class="line">    一个主题色(primary)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-primary">                <div class="message-body">            <p>一个主题色(primary)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:info %&#125;</span><br><span class="line">    一个提示色(info)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-info">                <div class="message-body">            <p>一个提示色(info)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:success %&#125;</span><br><span class="line">    一个成功色(success)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-success">                <div class="message-body">            <p>一个成功色(success)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:warning %&#125;</span><br><span class="line">    一个警告色(warning)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-warning">                <div class="message-body">            <p>一个警告色(warning)的消息框。</p>        </div>    </article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% message color:danger %&#125;</span><br><span class="line">    一个危险色(danger)的消息框。</span><br><span class="line">&#123;% endmessage %&#125;</span><br></pre></td></tr></table></figure><article class="message is-danger">                <div class="message-body">            <p>一个危险色(danger)的消息框。</p>        </div>    </article><h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><h3 id="语法定义"><a href="#语法定义-1" class="headerlink" title="语法定义"></a>语法定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %&#125;</span><br><span class="line">&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;</span><br><span class="line">&lt;标签内容&gt;</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;</span><br><span class="line">&lt;标签内容&gt;</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">...</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>上面重复的参数用法类似，不再解释，下面看上面没有出现过的参数。</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><strong>必选参数</strong>，具有唯一性，<strong>整个文档</strong>中不可重复。</p><h4 id="align对齐方法"><a href="#align-对齐方法" class="headerlink" title="align(对齐方法)"></a>align(对齐方法)</h4><p>可选参数，可能值、实现方法和效果见下方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs %&#125;</span><br><span class="line">&lt;!-- tab id:page1-1 title:第一页 active --&gt;</span><br><span class="line">(没有对齐参数)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page1-2 title:第二页 --&gt;</span><br><span class="line">(没有对齐参数)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page1-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page1-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page1-1" class="tab-content">          <p>(没有对齐参数)<br>这是标签页 1</p>      </div><div id="page1-2" class="tab-content is-hidden">          <p>(没有对齐参数)<br>这是标签页 2</p>      </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs align:centered %&#125;</span><br><span class="line">&lt;!-- tab id:page2-1 title:第一页 active --&gt;</span><br><span class="line">(对齐参数：centered)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page2-2 title:第二页 --&gt;</span><br><span class="line">(对齐参数：centered)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3 is-centered">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page2-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page2-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page2-1" class="tab-content">          <p>(对齐参数：centered)<br>这是标签页 1</p>      </div><div id="page2-2" class="tab-content is-hidden">          <p>(对齐参数：centered)<br>这是标签页 2</p>      </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs align:right %&#125;</span><br><span class="line">&lt;!-- tab id:page3-1 title:第一页 active --&gt;</span><br><span class="line">(对齐参数：right)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page3-2 title:第二页 --&gt;</span><br><span class="line">(对齐参数：right)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3 is-right">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page3-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page3-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page3-1" class="tab-content">          <p>(对齐参数：right)<br>这是标签页 1</p>      </div><div id="page3-2" class="tab-content is-hidden">          <p>(对齐参数：right)<br>这是标签页 2</p>      </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs align:fullwidth %&#125;</span><br><span class="line">&lt;!-- tab id:page4-1 title:第一页 active --&gt;</span><br><span class="line">(对齐参数：fullwidth)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page4-2 title:第二页 --&gt;</span><br><span class="line">(对齐参数：fullwidth)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3 is-fullwidth">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page4-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page4-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page4-1" class="tab-content">          <p>(对齐参数：fullwidth)<br>这是标签页 1</p>      </div><div id="page4-2" class="tab-content is-hidden">          <p>(对齐参数：fullwidth)<br>这是标签页 2</p>      </div><h4 id="style样式"><a href="#style-样式" class="headerlink" title="style(样式)"></a>style(样式)</h4><p>可选参数，可能值、实现方法和效果见下方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs %&#125;</span><br><span class="line">&lt;!-- tab id:page5-1 title:第一页 active --&gt;</span><br><span class="line">(样式：默认)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page5-2 title:第二页 --&gt;</span><br><span class="line">(样式：默认)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page5-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page5-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page5-1" class="tab-content">          <p>(样式：默认)<br>这是标签页 1</p>      </div><div id="page5-2" class="tab-content is-hidden">          <p>(样式：默认)<br>这是标签页 2</p>      </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs style:boxed %&#125;</span><br><span class="line">&lt;!-- tab id:page6-1 title:第一页 active --&gt;</span><br><span class="line">(样式：boxed)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page6-2 title:第二页 --&gt;</span><br><span class="line">(样式：boxed)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3 is-boxed">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page6-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page6-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page6-1" class="tab-content">          <p>(样式：boxed)<br>这是标签页 1</p>      </div><div id="page6-2" class="tab-content is-hidden">          <p>(样式：boxed)<br>这是标签页 2</p>      </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs style:toggle %&#125;</span><br><span class="line">&lt;!-- tab id:page7-1 title:第一页 active --&gt;</span><br><span class="line">(样式：toggle)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page7-2 title:第二页 --&gt;</span><br><span class="line">(样式：toggle)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3 is-toggle">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page7-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page7-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page7-1" class="tab-content">          <p>(样式：toggle)<br>这是标签页 1</p>      </div><div id="page7-2" class="tab-content is-hidden">          <p>(样式：toggle)<br>这是标签页 2</p>      </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs style:toggle-rounded %&#125;</span><br><span class="line">&lt;!-- tab id:page8-1 title:第一页 active --&gt;</span><br><span class="line">(样式：toggle-rounded)</span><br><span class="line">这是标签页 1</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab id:page8-2 title:第二页 --&gt;</span><br><span class="line">(样式：toggle-rounded)</span><br><span class="line">这是标签页 2</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs my-3 is-toggle is-toggle-rounded">        <ul class="mx-0 my-0">            <li class="is-active">          <a href="#page8-1">              <p>第一页</p>          </a>      </li><li>          <a href="#page8-2">              <p>第二页</p>          </a>      </li>        </ul>    </div>    <div id="page8-1" class="tab-content">          <p>(样式：toggle-rounded)<br>这是标签页 1</p>      </div><div id="page8-2" class="tab-content is-hidden">          <p>(样式：toggle-rounded)<br>这是标签页 2</p>      </div><h1 id="官方文档中的横跨文章的提示框-警告框等"><a href="#官方文档中的横跨文章的提示框、警告框等" class="headerlink" title="官方文档中的横跨文章的提示框、警告框等"></a>官方文档中的横跨文章的提示框、警告框等</h1><p><strong>摘自官网</strong>的一些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&lt;article class=&quot;message message-immersive is-primary&quot;&gt;</span><br><span class="line">&lt;div class=&quot;message-body&quot;&gt;</span><br><span class="line">&lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译：&lt;a href=&quot;/hexo-theme-icarus/uncategorized/custom-hexo-tag-helpers/&quot;&gt;English&lt;/a&gt;。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/article&gt;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-americas mr-2"></i>本文同时提供以下语言的翻译：<a href="/hexo-theme-icarus/uncategorized/custom-hexo-tag-helpers/">English</a>。</div></article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&lt;article class=&quot;message message-immersive is-primary&quot;&gt;</span><br><span class="line">&lt;div class=&quot;message-body&quot;&gt;</span><br><span class="line">&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;The following content is taken from </span><br><span class="line">&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://hexo.io/docs/tag-plugins.html&quot;&gt;Hexo documentation&lt;/a&gt;</span><br><span class="line">with minor revisions.</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/article&gt;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-lightbulb mr-2"></i>The following content is taken from <a target="_blank" rel="noopener" href="https://hexo.io/docs/tag-plugins.html">Hexo documentation</a>with minor revisions.</div></article><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&lt;article class=&quot;message message-immersive is-warning&quot;&gt;</span><br><span class="line">&lt;div class=&quot;message-body&quot;&gt;</span><br><span class="line">&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？请点击&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/zh-CN/CDN-Providers.md&quot;&gt;此处&lt;/a&gt;提交修改。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/article&gt;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><article class="message message-immersive is-warning"><div class="message-body"><i class="fas fa-question-circle mr-2"></i>文章内容有误？请点击<a target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/zh-CN/CDN-Providers.md">此处</a>提交修改。</div></article><p>还有更多参数请见：<a href="https://astrobear.top/2021/08/22/Icarus%E6%B6%88%E6%81%AF%E6%A1%86%E6%A8%A1%E6%9D%BF/">《Icarus消息框模板 - Astroblog》</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补记一个用 C++ 实现的 2048 小游戏</title>
      <link href="/posts/10d14c30.html"/>
      <url>/posts/10d14c30.html</url>
      
        <content type="html"><![CDATA[<p>校科协的加入有条件，面试前一步是笔试。免去笔试的方法也不是没有，可以做免试题。看了各个组的免试题，发现都好难好难，只有前端组的 2048 敢去尝试尝试。但我有没怎么学过 JS，便想着先用 C++ 实现一下逻辑，再把代码改过去。</p><span id="more"></span><h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><p>引用免试题中的原话：</p><blockquote><p>在一个 4 * 4 大小共计 16 个的方格中，初始时会有随机两个方格出现 2 &#x2F; 4 ，每次通过 方向键 控制所有方块向同一个方向运动，两个相同数字的方块撞在一起之后合并成为他们的和，每次操作之后会在空白的方格处随机生成一个 2 或者 4 ，当最终得到一个 2048 的方块时即获得游戏胜利。如果16个格子全部填满并且相邻的格子都不相同也就是无法移动的话，那么 Game Over 。</p></blockquote><p><del>写这篇博客的时候才发现原来还有”当最终得到一个 2048 的方块时即获得游戏胜利”这句话，我并没有实现这个就是说。</del></p><h2 id="c-源代码"><a href="#C-源代码" class="headerlink" title="C++ 源代码"></a>C++ 源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> box_c[<span class="number">4</span>][<span class="number">4</span>]; <span class="comment">// 运算用 box_content</span></span><br><span class="line"><span class="comment">// short box_s[4][4]; // 显示用 box_show</span></span><br><span class="line"><span class="type">bool</span> map[<span class="number">4</span>][<span class="number">4</span>]; <span class="comment">// 用于表示是否发生过合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([0][0])  ([0][1])  ([0][2])  ([0][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([1][0])  ([1][1])  ([1][2])  ([1][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([2][0])  ([2][1])  ([2][2])  ([2][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([3][0])  ([3][1])  ([3][2])  ([3][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomNum</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里不能srand，不然就会生成出来都是同一个随机数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTwoOrFour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRandomNum</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateNewNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> possibleI = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> possibleJ = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (box_c[possibleI][possibleJ] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            box_c[possibleI][possibleJ] = <span class="built_in">getTwoOrFour</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空map</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">map_refresh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始全部赋值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">            map[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机找两个位置填充2或者4</span></span><br><span class="line">    <span class="comment">/* for (int i = 0; i &lt; 2;)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int possibleI = getRandomNum(0, 3);</span></span><br><span class="line"><span class="comment">        int possibleJ = getRandomNum(0, 3);</span></span><br><span class="line"><span class="comment">        if (box_c[possibleI][possibleJ] == 0)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">            box_c[possibleI][possibleJ] = getTwoOrFour();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="comment">// 直接用这个函数生成两个得了</span></span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本来想显示运算分离的，后来感觉好像没啥必要</span></span><br><span class="line"><span class="comment">/* void refreshShow()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 4; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; 4; j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            box_s[i][j] = box_c[i][j];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; box_c[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; box_s[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == box_c[i][j] &amp;&amp; map[i - <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] *= <span class="number">2</span>;</span><br><span class="line">                map[i - <span class="number">1</span>][j] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i + <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i + <span class="number">1</span>][j] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[k][j] = box_c[k - <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i + <span class="number">1</span>][j] == box_c[i][j] &amp;&amp; map[i + <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i + <span class="number">1</span>][j] *= <span class="number">2</span>;</span><br><span class="line">                map[i + <span class="number">1</span>][j] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[k][j] = box_c[k - <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveLeft</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span>; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i][j - <span class="number">1</span>] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将右边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[i][k] = box_c[i][k + <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j - <span class="number">1</span>] == box_c[i][j] &amp;&amp; map[i][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i][j - <span class="number">1</span>] *= <span class="number">2</span>;</span><br><span class="line">                map[i][j - <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将右边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[i][k] = box_c[i][k + <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveRight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i][j + <span class="number">1</span>] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将左边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[i][k] = box_c[i][k - <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i][j + <span class="number">1</span>] == box_c[i][j] &amp;&amp; map[i][j + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i][j + <span class="number">1</span>] *= <span class="number">2</span>;</span><br><span class="line">                map[i][j + <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将右边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt; <span class="number">0</span>; k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[i][k] = box_c[i][k - <span class="number">1</span>];</span><br><span class="line">                    box_c[i][k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// https://www.runoob.com/w3cnote/c-get-keycode.html</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_kbhit())</span><br><span class="line">        &#123;                      <span class="comment">//如果有按键按下，则_kbhit()函数返回真</span></span><br><span class="line">            <span class="type">int</span> ch = _getch(); <span class="comment">//使用_getch()函数获取按下的键值</span></span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">119</span>: <span class="comment">// w</span></span><br><span class="line">                <span class="built_in">moveUp</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">97</span>: <span class="comment">// a</span></span><br><span class="line">                <span class="built_in">moveLeft</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">115</span>: <span class="comment">// s</span></span><br><span class="line">                <span class="built_in">moveDown</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>: <span class="comment">// d</span></span><br><span class="line">                <span class="built_in">moveRight</span>();</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">27</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">//当按下ESC时结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码阅读与分析"><a href="#代码阅读与分析" class="headerlink" title="代码阅读与分析"></a>代码阅读与分析</h2><h3 id="44-方格的构建"><a href="#4-4-方格的构建" class="headerlink" title="4*4 方格的构建"></a>4*4 方格的构建</h3><p>我创建了 <code>box_c</code> 这个二维数组来构建了下面这样一个棋盘来存放数据。数据值为 0 表示这个格子空着，非零则是对应数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([0][0])  ([0][1])  ([0][2])  ([0][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([1][0])  ([1][1])  ([1][2])  ([1][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([2][0])  ([2][1])  ([2][2])  ([2][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">([3][0])  ([3][1])  ([3][2])  ([3][3])</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>另外还有 <code>map</code> 这个二维数组，我放到后边说。</p><h3 id="生成新的数字"><a href="#生成新的数字" class="headerlink" title="生成新的数字"></a>生成新的数字</h3><p>因为要在 4*4 的方格内随机生成 2 或者 4，所以首先就先做一个随机数生成器。</p><p>首先引入两个库：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;cstdlib&gt;</code> 提供了 <code>srand()</code> 和 <code>rand()</code> 函数。</p><p><code>srand()</code> 接受一个用于初始化的随机数”种子”。 一般我们就用当前时间<code>time(0)</code>作为种子。（这就是为什么我们需要引入 <code>&lt;ctime&gt;</code> 这个库。 ）</p><p><code>rand()</code> 函数会产生一个 [0,RAND_MAX]范围内的整数。通过一些算式，我们可以人为构造一些式子来实现生成需求范围内的随机数。下表展示了一些式子。</p><table><thead><tr><th>目标类型及范围</th><th>表达式</th></tr></thead><tbody><tr><td>[0,n) 内的整数</td><td>rand() % n</td></tr><tr><td>[a,b) 内的整数</td><td>(rand() % (b-a)) + a</td></tr><tr><td>[a,b] 内的整数</td><td>(rand() % (b-a+1)) + a</td></tr><tr><td>(a,b] 内的整数</td><td>(rand() % (b-a)) + a + 1</td></tr><tr><td>0～1之间的浮点数</td><td>rand() &#x2F; double(RAND_MAX)</td></tr></tbody></table><p>还有一个通用公式：a + rand() % n。</p><p>其中的 a 是起始值，n 是整数的范围。 </p><article class="message is-danger"><div class="message-body"><p>注意！<code>srand()</code>用于初始化，<strong>只需要初始化一次</strong>。所以，你的获取随机数函数应该长得像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomNum</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getRandomNum</span>(<span class="number">1</span>,<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRandomNum</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getRandomNum</span>(<span class="number">1</span>,<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误的写法会导致快速生成随机数时每次返回的都是随机数序列的第一个…</strong> （可能是程序运行速度很快种子都是一样的结果）。</p></div></article><p>接着我定义了 <code>getTwoOrFour()</code> 和 <code>generateNewNum()</code> 函数。前者用于随机生成 2&#x2F;4，不必多说。后者用于在 4*4 方格内随机放上一个数字，首先生成行列坐标，如果检查到这个格子空的，可以生成在这，那就生成，结束该函数的运行，否则进行下一次尝试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTwoOrFour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRandomNum</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateNewNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> possibleI = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> possibleJ = <span class="built_in">getRandomNum</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (box_c[possibleI][possibleJ] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            box_c[possibleI][possibleJ] = <span class="built_in">getTwoOrFour</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化主要就是两方面：一方面是初始化随机数种子；另一方面是清空棋盘（其实还有清空 map 标记），然后随机找两个位置放上 2 或者 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始全部赋值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">            map[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机找两个位置填充2或者4</span></span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动与合并"><a href="#移动与合并" class="headerlink" title="移动与合并"></a>移动与合并</h3><article class="message is-danger"><div class="message-body">注意这里的移动与合并算法可能不是最优解，可能比较低效，甚至可能有错误。仅供参考。</div></article><p>移动无非就是上下左右，彼此之间比较类似。这里以向上移动为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] = box_c[i][j];</span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (box_c[i - <span class="number">1</span>][j] == box_c[i][j] &amp;&amp; map[i - <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; map[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                box_c[i - <span class="number">1</span>][j] *= <span class="number">2</span>;</span><br><span class="line">                map[i - <span class="number">1</span>][j] = <span class="number">1</span>; <span class="comment">//标识此次合并</span></span><br><span class="line">                box_c[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将下边的全部平移过来</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    box_c[k][j] = box_c[k + <span class="number">1</span>][j];</span><br><span class="line">                    box_c[k + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">generateNewNum</span>();</span><br><span class="line">    <span class="built_in">map_refresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先因为是向上移动，所以先拆分一下上边的二维数组，拆成四列。第一层 <code>j</code> 的循环就是列的循环。</p><p>在某一列中，我想从下往上考虑：如果上面一个格子是 0 ，那我就把现在这个格子里的数字上移；如果这个位置和上边位置的数一样，我就让上边位置的数乘二，然后下边位置赋0。不断从下往上扫描直到能移动的全部移动，能合并的全部合并。</p><p>但是有个问题是，每次移动各个数字只能发生一次合并！如果这个数字合并过了，那它就不应该再合并了。比如四个2,移动一次应该产生两个4而非1个8。</p><p>所以我创建了一个 <code>map</code> ，用于标识已经发生的合并。并且取消掉了之前的不断的从上到下的扫描，改为了如果发生了一次移动或者合并，即给当前格子进行了赋0操作的话，我就把下边的所有格子往上移动一次。</p><p>总结一下思路：如果以 0,1,2,3 从上往下标识这一列格子。我从 3 往上扫描到 1 ，如果发现当前格子是 0，也即上边格子空着，我就把这个格子开始下边的所有格子往上移动一位；类似的，如果发现上边格子和当前格子可以合并，并且查询 <code>map</code> 发现这两个格子里边的数字在这轮移动中都没有发生过合并，那就合并，并也将下边格子的内容全部往上移动。</p><p>当四列都结束后，便用 <code>generateNewNum()</code> 填充一个新数字，并且清空 <code>map</code> 的状态。</p><h3 id="结束检测"><a href="#结束检测" class="headerlink" title="结束检测"></a>结束检测</h3><p>这个 C++ 代码中这块并没有实现，不过最后的 Web 版本是实现了的。借一下那边的代码讲一下思路吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ifEnd</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在检测游戏是否结束！&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 如果有空位，说明必定可以继续</span></span><br><span class="line">                    <span class="keyword">if</span> (box_c[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;检测到游戏仍然有空位，游戏继续！&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为0则说明没有空位了</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;检测到游戏没有空位了，下面检测是否有可合并方块！&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> flag2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((box_c[i][j] == box_c[i][j + <span class="number">1</span>]) || (box_c[i][j] == box_c[i + <span class="number">1</span>][j])) &#123;</span><br><span class="line">                            flag2 = <span class="number">1</span>;</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;检测到可合并方块，游戏继续！&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag2 == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 最后一列单独检测</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (box_c[i][<span class="number">3</span>] == box_c[i + <span class="number">1</span>][<span class="number">3</span>]) &#123;</span><br><span class="line">                        flag2 = <span class="number">1</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;检测到可合并方块，游戏继续！&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 最后一行单独检测</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (box_c[<span class="number">3</span>][j] == box_c[<span class="number">3</span>][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        flag2 = <span class="number">1</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;检测到可合并方块，游戏继续！&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;检测到游戏无空位且无法继续移动，游戏结束！&quot;</span>);</span><br><span class="line">                    <span class="title function_">alert</span>(<span class="string">&#x27;游戏结束，即将重新开始！&#x27;</span>);</span><br><span class="line">                    location.<span class="title function_">reload</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>游戏结束的标志是两个：一是没有空格子了，二是任意相邻格子没有相同数字不可能发生合并了。</p><p>所以首先就是扫描所有格子看看有没有空格子。如果没有格子，就开始扫描相邻格子是否有相同数字。我的扫描方法是从(0,0)到(2,2)都只检测它的右方和下方是否与它相同，然后再单独检测一下最右边一列前三个元素的下一个和最下边一行前三个元素的右边一个是否与它们自己相同。如果也没有相同的了，那就 Game Over 。</p><h3 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h3><p>直接看参考资料《C&#x2F;C++ 获取键盘事件》吧…</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/xiaokang01/p/9786751.html">《C++产生随机数》</a><br><a href="https://www.runoob.com/w3cnote/c-get-keycode.html">《C&#x2F;C++ 获取键盘事件》</a><br>… …</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 游戏 </tag>
            
            <tag> 随机数生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中 cin 与 cout 的转进制输入输出</title>
      <link href="/posts/9e863176.html"/>
      <url>/posts/9e863176.html</url>
      
        <content type="html"><![CDATA[<p>笔者的朋友有道输入八进制输出十进制的题目，他是使用数学方法实现的。笔者隐隐约约记得好像cin和cout有控制输入输出数字进制的方法，查找了一些资料，做一下笔记。</p><span id="more"></span><table><thead><tr><th>进制</th><th>对应缩写</th></tr></thead><tbody><tr><td>二进制</td><td>bin</td></tr><tr><td>八进制</td><td>oct</td></tr><tr><td>十进制</td><td>dec</td></tr><tr><td>十六进制</td><td>hex</td></tr></tbody></table><p>接下来只要在输入&#x2F;输出的时候加上这些缩写就行了。</p><p>比如输入一个八进制数然后以十进制输出它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">    cin &gt;&gt; oct &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1750</span><br><span class="line">1000</span><br></pre></td></tr></table></figure><p>（”1750”是输入，”1000”是输出）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 的安装与配置基础 C/C++ 开发环境</title>
      <link href="/posts/a7a0ce82.html"/>
      <url>/posts/a7a0ce82.html</url>
      
        <content type="html"><![CDATA[<p>笔者以前学习 C++ 的时候，使用的是 DevCpp 。这个软件让我这个初学者比较舒服的点是，我不用太过详细地考虑编译的过程——新建一个 cpp 文件，写一点小程序，按下 F11，程序运行。我不需要管选择编译器啊、配置编译命令啊啥啥的。但是到 VS Code 这边，这都要我自己做了，只能说相当不友好。这里记录一下我配置 VS Code 的 C&#x2F;C++ 环境的完整过程，希望对你有所帮助。</p><span id="more"></span><h2 id="安装-visual-studio-code"><a href="#安装-Visual-Studio-Code" class="headerlink" title="安装 Visual Studio Code"></a>安装 Visual Studio Code</h2><p>打开 <a href="https://code.visualstudio.com/">VS Code 官网</a>，点击 <code>Download for Windows</code> 按钮（其他平台请选择对应平台的安装包，此处以 Windows 平台为例），等待下载完成。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSRlss.png"></p><article class="message is-primary is-small">        <div class="message-header"><p><i class="fa-solid fa-circle-info mr-2"></i>国内 VS Code 下载速度慢的解决方案</p></div>        <div class="message-body">            <p>此方法来自：<a href="https://zhuanlan.zhihu.com/p/112215618">https://zhuanlan.zhihu.com/p/112215618</a></p><p>在你的下载软件处（笔者这里是 IDM，你如果是浏览器下载的就去浏览器的下载管理器里找），找到下载地址。将下载地址中的 <code>az764295.vo.msecnd.net</code> 替换为 <code>vscode.cdn.azure.cn</code>，然后取消原任务，用修改过的下载链接新建一个下载。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSR8Zq.png" alt="修改前"></p>        </div>    </article><!-- <article class="message is-success"><div class="message-header">国内 VS Code 下载速度慢的解决方案</div><div><div class="message-body"><p>此方法来自：<a href="https://zhuanlan.zhihu.com/p/112215618">https://zhuanlan.zhihu.com/p/112215618</a></p><p>在你的下载软件处（笔者这里是IDM，你如果是浏览器下载的就去浏览器的下载管理器里找），找到下载地址。将下载地址中的 <code>az764295.vo.msecnd.net</code> 替换为 <code>vscode.cdn.azure.cn</code>，然后取消原任务，用修改过的下载链接新建一个下载。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSR8Zq.png" alt="修改前"></p></div></article> --><p>打开安装包，一路下一步，直到下面这个界面，按照下边的进行选择，直到安装完毕。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSWzge.png"></p><h2 id="vs-code-设置中文"><a href="#VS-Code-设置中文" class="headerlink" title="VS Code 设置中文"></a>VS Code 设置中文</h2><p>打开 VS Code，点击图示左侧第五个图标或使用快捷键 <code>Ctrl+Shift+X</code> 打开 <code>拓展</code> 页面，搜索：<code>Chinese</code>，找到 <code>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</code> 这个插件，点击 <code>Install</code> 安装，等待安装完成后按照提示点击右下角 <code>Restart</code> 按钮重启 VS Code。<br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSf1U0.png"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSfJ8U.png"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSftv4.png"></p><h2 id="安装并检查编译器"><a href="#安装并检查编译器" class="headerlink" title="安装并检查编译器"></a>安装并检查编译器</h2><p>DevCpp 安装的时候也帮我们安装好了编译器，但 VS Code 并没有。所以我们还得自己装一个编译器。这里以 Mingw-w64 为例（参考<a href="https://code.visualstudio.com/docs/languages/cpp#_example-install-mingwx64">官方教程</a>）。</p><p>参考 <a href="https://www.msys2.org/#installation">MSYS2 官网</a>下载安装和安装。</p><article class="message is-primary is-small">        <div class="message-header"><p><i class="fa-solid fa-circle-info mr-2"></i>国内 MSYS2 下载速度慢的解决方案</p></div>        <div class="message-body">            <p>在这个按钮上右键，选择<code>复制链接</code>。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xShuRO.png"></p><p>然后前往<a href="https://ghproxy.com/">https://ghproxy.com/</a>这个网站，粘贴上面复制的下载链接，点击下载。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xShGdI.png"></p>        </div>    </article><!-- <article class="message is-success"><div class="message-header">国内 MSYS2 下载速度慢的解决方案</div><div><div class="message-body"><p>在这个按钮上右键，选择<code>复制链接</code>。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xShuRO.png"></p><p>然后前往<a href="https://ghproxy.com/">https://ghproxy.com/</a>这个网站，粘贴上面复制的下载链接，点击下载。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xShGdI.png"></p></div></article> --><p>打开安装包，一路默认下一步。耐心等待（国内网络可以！只要耐心等！）直到出现下面的界面：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xShqfK.png"></p><p>输入下面的命令安装 gcc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mingw-w64-x86_64-gcc</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xS46nH.png" alt="画横线的是需要自己输入的"></p><p>接下来需要添加环境变量。直接搜索 <code>高级系统设置</code>：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xS4bHs.png"></p><p>打开后点击环境变量。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xS4x3T.png"></p><p>添加系统变量。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xS5VC6.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xS5J8f.png"></p><p>打开 CMD 检查一下是否成功：<br>输入 <code>gcc -v</code>，如果有结果，就安装成功了。</p><h2 id="cx2fc-扩展的安装"><a href="#C-x2F-C-扩展的安装" class="headerlink" title="C&#x2F;C++ 扩展的安装"></a>C&#x2F;C++ 扩展的安装</h2><p>按照上面的方法打开扩展，首先是几个 C&#x2F;C++ 基础扩展，直接搜索 <code>C++</code>。</p><p>第一个：<code>C/C++</code></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSfhVI.png"></p><p>直接点击安装（笔者这里截图的时候还没重启，如果按照上述步骤已经安装了中文语言包并重启了 Code，这里的 <code>Install</code> 按钮就会变成 <code>安装</code>）。</p><p>第二个：<code>C/C++ Extension Pack</code></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSf7RS.png"></p><p>第三个：<code>C/C++ Compile Run</code></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSfLrj.png"></p><p>这个扩展提供了极其简单的<code>F6</code>一键编译运行功能。</p><h2 id="正常运行测试"><a href="#正常运行测试" class="headerlink" title="正常运行测试"></a>正常运行测试</h2><p>新建一个文件夹，就叫 <code>HelloWorld</code> 吧。打开文件夹，右键，选择 <code>通过 Code 打开</code>。新建一个 <code>HelloWorld.cpp</code>，粘贴下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ctrl+S</code> 保存，<code>F6</code> 运行，成功输出结果。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xS5oPx.png"></p><h2 id="debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p><strong>2022 年 10 月 6 日更新：</strong></p><p>完成上边的步骤之后，你应该可以正常运行程序了。下面的教程是安装调试器以及通过 <code>C/C++ Runner</code> 让调试等工作变得简单。</p><p>首先再次打开 msys2.exe (默认位置是：C:\msys64\msys2.exe)，类似上边安装 gcc ，输入下边的命令安装 gdb。<br>类似的，还需要输入下面的命令安装 gdb:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mingw-w64-x86_64-gdb</span><br></pre></td></tr></table></figure><p>然后在 VS Code 中搜索并安装 <code>C/C++ Runner</code> 插件。</p><article class="message is-primary is-small">        <div class="message-header"><p><i class="fa-solid fa-circle-info mr-2"></i>安装 C&#x2F;C++ Runner 插件时其依赖项 CodeLLDB 无法安装的解决方案</p></div>        <div class="message-body">            <p>按照右下角的提示前往<a href="https://objects.githubusercontent.com/github-production-release-asset-2e65be/49407251/b3e44ffa-119e-40be-b3a5-55784942834b?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A/20220917/us-east-1/s3/aws4_request&X-Amz-Date=20220917T044827Z&X-Amz-Expires=300&X-Amz-Signature=d691f5f3cf95080d3764c3fe053165267db7465afac554a2a019857959631880&X-Amz-SignedHeaders=host&actor_id=39331194&key_id=0&repo_id=49407251&response-content-disposition=attachment;%20filename=codelldb-x86_64-windows.vsix&response-content-type=application/octet-stream">这里</a>下载 <code>codelldb-x86_64-windows.vsix</code>文件。</p><p>在 VS Code 中按下 <code>Ctrl + Shift + P</code>，输入 <code>install</code>，选择<code>从VSIX安装...</code>，选择上边下好的文件，等待安装完成。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSTBad.png"></p>        </div>    </article><!-- <article class="message is-success"><div class="message-header">安装 C/C++ Runner 插件时其依赖项 CodeLLDB 无法安装的解决方案</div><div><div class="message-body"><p>按照右下角的提示前往<a href="https://objects.githubusercontent.com/github-production-release-asset-2e65be/49407251/b3e44ffa-119e-40be-b3a5-55784942834b?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A/20220917/us-east-1/s3/aws4_request&X-Amz-Date=20220917T044827Z&X-Amz-Expires=300&X-Amz-Signature=d691f5f3cf95080d3764c3fe053165267db7465afac554a2a019857959631880&X-Amz-SignedHeaders=host&actor_id=39331194&key_id=0&repo_id=49407251&response-content-disposition=attachment;%20filename=codelldb-x86_64-windows.vsix&response-content-type=application/octet-stream">这里</a>下载 <code>codelldb-x86_64-windows.vsix</code>文件。</p><p>在 VS Code 中按下 <code>Ctrl + Shift + P</code>，输入 <code>install</code>，选择<code>从VSIX安装...</code>，选择上边下好的文件，等待安装完成。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSTBad.png"></p></div></article> --><p>安装完成后，左下角点击 <code>Select folder.</code>，选择当前文件夹。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xSTRsS.png"></p><p>然后按下小齿轮进行编译，按下三角形运行，设置好断点按下小虫子进行 Debug。</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/17/xST4aj.png"></p><h2 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h2><p><strong>2022 年 10 月 13 日更新：</strong></p><p>参见我的另一篇文章：<a href="https://blocklune.github.io/posts/ca05bed5.html">《【已解决】VS Code 中文乱码问题》</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/112215618">国内下载 vscode 速度慢问题解决</a></li><li>官方教程：<a href="https://code.visualstudio.com/docs/languages/cpp">C++ programming with Visual Studio Code</a></li><li><a href="https://www.cnblogs.com/zychengzhiit1/p/5776962.html">windows 10 环境下 使用 msys2 + vs code 配置 c++ 的编译环境</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 公式基础</title>
      <link href="/posts/848a7d31.html"/>
      <url>/posts/848a7d31.html</url>
      
        <content type="html"><![CDATA[<p>用 LaTeX 写数学公式的时候，总记不住一些写法，故在此记录学习笔记。</p><span id="more"></span><h2 id="常见符号"><a href="#常见符号" class="headerlink" title="常见符号"></a>常见符号</h2><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p>大小写希腊字母的写法区别就在于 LaTeX 符号的首字母大小写。</p><p>若要使用斜体只要在前面加上 <code>var</code> 前缀，例如 <code>\varGamma</code> 可以用来显示 $\varGamma$ 。</p><table><thead><tr><th>大写字母</th><th>LaTeX 写法</th><th>小写字母</th><th>LaTeX 写法</th></tr></thead><tbody><tr><td>$\Alpha$</td><td>\Alpha</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>$\Beta$</td><td>\Beta</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>$\Epsilon$</td><td>\Epsilon</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>$\Zeta$</td><td>\Zeta</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>$\Eta$</td><td>\Eta</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>$\Iota$</td><td>\Iota</td><td>$\iota$</td><td>\iota</td></tr><tr><td>$\Kappa$</td><td>\Kappa</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>$\Mu$</td><td>\Mu</td><td>$\mu$</td><td>\mu</td></tr><tr><td>$\Nu$</td><td>\Nu</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>$\Omicron$</td><td>\Omicron</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>$\Rho$</td><td>\Rho</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>$\Tau$</td><td>\Tau</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>\Upsilon</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>$\Chi$</td><td>\Chi</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>渲染结果</th><th>LaTeX 写法</th><th>记法</th></tr></thead><tbody><tr><td>$\pm$</td><td>\pm</td><td>英文：<strong>P</strong>lus + <strong>M</strong>inus</td></tr><tr><td>$\mp$</td><td>\mp</td><td>英文：<strong>M</strong>inus + <strong>P</strong>lus</td></tr><tr><td>$\times$</td><td>\times</td><td><strong>times</strong> 就有“乘”的意思</td></tr><tr><td>$\div$</td><td>\div</td><td>$6 \div 3&#x3D;2$ 表述为：Six <strong>div</strong>ided by two is three.</td></tr><tr><td>$\geq$</td><td>\geq</td><td>“大于等于”的英文：<strong>g</strong>reater than or <strong>eq</strong>ual to</td></tr><tr><td>$\leq$</td><td>\leq</td><td>“小于等于”的英文：<strong>l</strong>ess than or <strong>eq</strong>ual to</td></tr><tr><td>$\neq$</td><td>\neq</td><td>“不等于”的英文：<strong>n</strong>ot <strong>eq</strong>ual to</td></tr><tr><td>$\approx$</td><td>\approx</td><td>“约等于”的英文：<strong>approx</strong>imately equal to</td></tr><tr><td>$\propto$</td><td>\propto</td><td>“正比于”的英文：be <strong>prop</strong>ortional <strong>to</strong></td></tr></tbody></table><h3 id="圈与点"><a href="#圈与点" class="headerlink" title="圈与点"></a>圈与点</h3><table><thead><tr><th>渲染结果</th><th>LaTeX 写法</th></tr></thead><tbody><tr><td>$\degree$</td><td>\degree</td></tr><tr><td>$\circ$</td><td>\circ</td></tr><tr><td>$\cdot$</td><td>\cdot</td></tr><tr><td>$\cdotp$</td><td>\cdotp</td></tr><tr><td>$\cdots$</td><td>\cdots</td></tr><tr><td>$\ddots$</td><td>\ddots</td></tr><tr><td>$\bullet$</td><td>\bullet</td></tr><tr><td>$\dot{a}$</td><td>\dot{a}</td></tr></tbody></table><h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><table><thead><tr><th>渲染结果</th><th>LaTeX 写法</th></tr></thead><tbody><tr><td>$\in$</td><td>\in</td></tr><tr><td>$\notin$</td><td>\notin</td></tr><tr><td>$\subset$</td><td>\subset</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td></tr><tr><td>$\supset$</td><td>\supset</td></tr><tr><td>$\supseteq$</td><td>\supseteq</td></tr><tr><td>$\cap$</td><td>\cap</td></tr><tr><td>$\cup$</td><td>\cap</td></tr><tr><td>$\complement$</td><td>\complement</td></tr></tbody></table><h2 id="上下标的输入方法"><a href="#上下标的输入方法" class="headerlink" title="上下标的输入方法"></a>上下标的输入方法</h2><p>上标 <code>^</code> ，下标 <code>_</code>，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="built_in">_</span>1 = a<span class="built_in">^</span>2,X<span class="built_in">_</span>2 = b<span class="built_in">^</span>2</span><br></pre></td></tr></table></figure><p>$$<br>X_1 &#x3D; a^2,X_2 &#x3D; b^2<br>$$</p><p>同时上下标，只要连续输入 <code>_</code> 和 <code>^</code> 即可，例如:</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="built_in">_</span>3<span class="built_in">^</span>2 = 9,X<span class="built_in">_</span>4<span class="built_in">^</span>2 = 16</span><br></pre></td></tr></table></figure><p>$$<br>X_3^2 &#x3D; 9,X_4^2 &#x3D; 16<br>$$</p><p>上下标如果由多字符组成，则需要加上花括号，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="built_in">_</span>&#123;i+j&#125;<span class="built_in">^</span>&#123;k+l&#125;</span><br></pre></td></tr></table></figure><p>$$<br>X_{i+j}^{k+l}<br>$$</p><p>左边的上下标只要写在前面就行了，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">^</span>a<span class="built_in">_</span>bX<span class="built_in">^</span>c<span class="built_in">_</span>d</span><br></pre></td></tr></table></figure><p>$$<br>^a_bX^c_d<br>$$</p><p>所以除了通过 <code>\degree</code> 的方法写度数，也可以通过上标的方法达到类似效果：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45<span class="keyword">\degree</span>,90<span class="built_in">^</span>&#123;<span class="keyword">\circ</span>&#125;</span><br></pre></td></tr></table></figure><p>$$<br>45\degree,90^{\circ}<br>$$</p><p>“上升”：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="built_in">^</span>&#123;X<span class="built_in">^</span>&#123;X<span class="built_in">^</span>&#123;X<span class="built_in">^</span>&#123;X<span class="built_in">^</span>&#123;X&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>$$<br>X^{X^{X^{X^{X^{X}}}}}<br>$$</p><p>”下降“：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="built_in">_</span>&#123;X<span class="built_in">_</span>&#123;X<span class="built_in">_</span>&#123;X<span class="built_in">_</span>&#123;X<span class="built_in">_</span>&#123;X&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>$$<br>X_{X_{X_{X_{X_{X}}}}}<br>$$</p><h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\frac{a}{b}<br>$$</p><h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><table><thead><tr><th>渲染结果</th><th>LaTeX 写法</th></tr></thead><tbody><tr><td>$\sqrt{2}$</td><td>\sqrt{2}</td></tr><tr><td>$\sqrt[3]{2}$</td><td>\sqrt[3]{2}</td></tr></tbody></table><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>[b]&#123;a&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\sqrt[b]{a}<br>$$</p><h2 id="其他常用符号写法"><a href="#其他常用符号写法" class="headerlink" title="其他常用符号写法"></a>其他常用符号写法</h2><table><thead><tr><th>渲染结果</th><th>LaTeX 写法</th><th>记法</th></tr></thead><tbody><tr><td>$\to$</td><td>\to</td><td></td></tr><tr><td>$\infty$</td><td>\infty</td><td>”无穷“的英文：<strong>inf</strong>ini<strong>ty</strong></td></tr><tr><td>$\lim_{x \to 0}$</td><td>\lim_{x \to 0}</td><td></td></tr><tr><td>$\bot$</td><td>\bot</td><td></td></tr><tr><td>$\perp$</td><td>\perp</td><td>”相互垂直“的英文：<strong>perp</strong>endicular to each other</td></tr><tr><td>$\dot{a}$</td><td>\dot{a}</td><td></td></tr><tr><td>$\hat{a}$</td><td>\hat{a}</td><td></td></tr><tr><td>$\bar{a}$</td><td>\bar{a}</td><td></td></tr><tr><td>$\vec{a}$</td><td>\vec{a}</td><td>”向量“的英文：<strong>vec</strong>tor</td></tr><tr><td>$\tilde{a}$</td><td>\tilde{a}</td><td>”波浪号“的英文：<strong>tilde</strong></td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/erciyuan_/article/details/90273268">latex公式语法_ecy_uooki的博客-CSDN博客_latex公式语法</a></li><li><a href="https://blog.csdn.net/bagba/article/details/123608562">latex不等于符号_Bagba的博客-CSDN博客_latex 不等于</a></li><li><a href="https://www.codeleading.com/article/36564801982/">latex补集怎么打 - 代码先锋网 (codeleading.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/262907455">如何用latex编写上标、下标？ - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 数学 </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 在 Icarus 主题下渲染数学公式</title>
      <link href="/posts/e201bde3.html"/>
      <url>/posts/e201bde3.html</url>
      
        <content type="html"><![CDATA[<p>这个问题的起因是笔者写数学课笔记的时候发现本地使用 Typora 时正常可以渲染的数学公式无法在我的博客上显示。在查找资料的过程中发现 Hexo 默认渲染器不支持 LaTeX。正当我想着是否要换渲染器时，才发现我使用的 Icarus 主题只要稍微设置一下就可以渲染了。</p><span id="more"></span><p>官方文档地址：<a href="http://ppoffice.github.io/hexo-theme-icarus/Plugins/Other/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6/#MathJax">http://ppoffice.github.io/hexo-theme-icarus/Plugins/Other/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6/#MathJax</a></p><p>打开 <code>_config.icarus.yml</code> 文件，找到下面这行：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>修改 <code>mathjax</code> 的值为 <code>true</code>，即变成这样：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在需要渲染数学公式的文档开头添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><p><strong>待解决的问题：</strong></p><p>似乎这样的字符并不全，比如 <code>\Alpha</code> 在网站上被渲染成下面那样，而非 正确的<code>Α</code><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxbsIA.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Web </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一新生的高数预备知识学习笔记</title>
      <link href="/posts/33435544.html"/>
      <url>/posts/33435544.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要是笔者从<a href="https://space.bilibili.com/66607740?spm_id_from=333.337.0.0">宋浩老师</a>处学习高数高数知识的课堂笔记，也加入了一些笔者自己搜到的东西。具体课程你可以看这里：</p><span id="more"></span><div class="bvideo"><a href="//www.bilibili.com/video/BV1YU4y1e7Q9" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://pic1.xuehuaimg.com/proxy/http://i1.hdslb.com/bfs/archive/07b97c7a0ab6ccedf5a31e4ae592474833b17893.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:01:26</span>            </div>            <div class="bvideo-info">                <p class="title">大一新生的高数预备知识简介</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>79.0万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>292</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">宋浩老师官方</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h2 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h2><h3 id="yx3darcsinx"><a href="#y-x3D-arcsinX" class="headerlink" title="y&#x3D;arcsinX"></a>y&#x3D;arcsinX</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxa7CV.png"></p><h3 id="yx3darccosx"><a href="#y-x3D-arccosX" class="headerlink" title="y&#x3D;arccosX"></a>y&#x3D;arccosX</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxdQxS.png"></p><h3 id="yx3darctanx"><a href="#y-x3D-arctanX" class="headerlink" title="y&#x3D;arctanX"></a>y&#x3D;arctanX</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxd8bj.png"></p><h3 id="yx3darccotx"><a href="#y-x3D-arccotX" class="headerlink" title="y&#x3D;arccotX"></a>y&#x3D;arccotX</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxdYan.png"></p><h3 id="yx3dsecx"><a href="#y-x3D-secX" class="headerlink" title="y&#x3D;secX"></a>y&#x3D;secX</h3><p>正割是余弦的倒数：<br>$$<br>secX &#x3D; \frac{1}{cosX}<br>$$<br> 定义域：显然$cosX \neq 0$，所以$y&#x3D;secX$的定义域为：$X\neq k\pi +\frac{\pi}{2},k\in Z$</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxwCon.png"></p><h3 id="yx3dcscx"><a href="#y-x3D-cscX" class="headerlink" title="y&#x3D;cscX"></a>y&#x3D;cscX</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxwneJ.png"></p><h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>$$<br>sec^2x&#x3D;1+tan^2x,csc^2x&#x3D;1+cot^2x<br>$$</p><p>可以使用下面的方法进行记忆：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/16/vzBKpt.png"></p><p>六边形的中间是$1$。红色三角形的上边两个角的平方之和等于下边一个的平方，即：<br>$$<br>sin^2x+cos^2x&#x3D;1<br>$$<br>$$<br>tan^2x+1&#x3D;sec^2x<br>$$<br>$$<br>cot^2x+1&#x3D;csc^2x<br>$$</p><h2 id="多项式的除法"><a href="#多项式的除法" class="headerlink" title="多项式的除法"></a>多项式的除法</h2><ul><li>次数高的放前面，低的放后边</li><li>缺项的补出来</li></ul><h3 id="不带余数"><a href="#不带余数" class="headerlink" title="不带余数"></a>不带余数</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vx0m1f.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vx0Mng.png"></p><h3 id="带余数"><a href="#带余数" class="headerlink" title="带余数"></a>带余数</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vx0t3V.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vx0o4I.png"></p><h2 id="有理分式的拆分"><a href="#有理分式的拆分" class="headerlink" title="有理分式的拆分"></a>有理分式的拆分</h2><h3 id="何为有理分式"><a href="#何为有理分式：" class="headerlink" title="何为有理分式："></a>何为有理分式：</h3><p>有理分式就是一个多项式比一个多项式</p><h3 id="何为有理分式的拆分"><a href="#何为有理分式的拆分：" class="headerlink" title="何为有理分式的拆分："></a>何为有理分式的拆分：</h3><p>将相乘的项变成相加减</p><h3 id="过程"><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxBdRP.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxBWR0.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxBHo9.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxDpee.png"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxDUw4.png" alt="待定系数法例子之一"></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/15/vxsWRI.png" alt="待定系数法例子之二"></p><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>首先看转动角度，其次看这个点到原点的距离。</p><p>例如：直角坐标系中$(2,2)$点在极坐标系中表示为$(2\sqrt{2},\frac{\pi}{4})$；$(-2,2)$表示为$(2\sqrt{2},\frac{3\pi}{4})$。</p><p>极坐标中的原点叫<code>极点</code>，<code>极轴</code>是从极点向$X$轴正方向引入的一条射线（仅正方向有）。极坐标中的点到极点的距离叫做<code>极径</code>，记作$\rho(\rho\geq0)$（距离肯定是个非负数）；从极轴逆时针转过的角度记作$\theta(0\leq\theta&lt;2\pi)$（但实际上不一定取这个范围）。所以极坐标中一点$P$的坐标记为$P(\rho,\theta)$。</p><p>一般先考虑$\theta$再考虑$\rho$。</p><h3 id="一些常见图像的极坐标表示"><a href="#一些常见图像的极坐标表示" class="headerlink" title="一些常见图像的极坐标表示"></a>一些常见图像的极坐标表示</h3><blockquote><p>括号内范围是默认范围，可写可不写</p></blockquote><h4 id="射线"><a href="#射线" class="headerlink" title="射线"></a>射线</h4><p>例如一条以极点为端点，$\theta&#x3D;45^\circ$的射线表述为：<br>$$<br>\theta &#x3D; 45^\circ(,\rho\geq0)<br>$$</p><h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h4><p>例如一个以极点为圆心，$1$为半径的圆表述为：<br>$$<br>(0\leq\theta&lt;2\pi,)\rho&#x3D;1<br>$$</p><h4 id="半圆"><a href="#半圆" class="headerlink" title="半圆"></a>半圆</h4><p>例如一个以极点为圆心，$1$为半径的位于$X$轴上方的半圆表述为：<br>$$<br>0\leq\theta\leq\pi,\rho&#x3D;1<br>$$</p><h4 id="圆面"><a href="#圆面" class="headerlink" title="圆面"></a>圆面</h4><p>例如一个以极点为圆心，$1$为半径的圆面表述为：<br>$$<br>(0\leq\theta&lt;2\pi,)0\leq\rho\leq1<br>$$</p><h4 id="半圆面"><a href="#半圆面" class="headerlink" title="半圆面"></a>半圆面</h4><p>例如一个以极点为圆心，$1$为半径的位于$X$轴上方的半圆面表述为：<br>$$<br>0\leq\theta\leq\pi,0\leq\rho\leq1<br>$$</p><article class="message is-warning"><div class="message-body"><p>又例如这个以$(1,0)$为圆心，$1$为半径的位于$X$轴上方的半圆面表述为：<br>$$<br>0\leq\theta\leq\frac{\pi}{2},0\leq\rho\leq2cos\theta<br>$$</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/16/vzwCNR.png"></p><p>又例如这个：</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/16/vzwtbQ.png"></p></div></article><h4 id="圆环"><a href="#圆环" class="headerlink" title="圆环"></a>圆环</h4><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/09/16/vzdzB4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动挡学习笔记</title>
      <link href="/posts/66959aa9.html"/>
      <url>/posts/66959aa9.html</url>
      
        <content type="html"><![CDATA[<p>最近几天一直在忙着考驾照的事情，8月份第一次考科二挂了后就开始边练科二边练科三。最近两三天先后把科三、第二次科二、科四过了，顺利拿到了C1驾照。但是…学的是手动挡，家里的车却是自动挡。所以想着如果不记一下的话，以后估计开惯了自动挡手动挡就不会了，便想做些笔记。顺便也记录一下笔者自己的学车过程。</p><span id="more"></span><div class="notification is-danger">相关做法仅供参考，有些内容可能也只适用于笔者这边的考试。如有错误敬请各位大佬指出。</div><h2 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h2><p>就是刷题嘛。笔者本人是把2000道题的题库先完整了一遍，然后又模拟了20+次，所以相当于做了4000多道题吧，结果是98一把过的。笔者一直很担心自己过不了那些扣分&#x2F;罚款题，甚至为此还自己做了个表格把扣分项全部列在了里边。结果实际上并没有用上多少就是了，因为实际考试根本没有那么多难题。<del>可能自己用的软件为了让你冲VIP所以不冲的话给的题目就会比较难吧。</del>笔者也认识一个刷了600道直接过的，还有一个当天下午考结果上午中午刷了1200道直接过的。可能考试的时候抽题目也有点运气成分，和笔者一起去的朋友第二把的难度显然低于第一把，所以第一把80多但第二把就100了。</p><h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><p>科二始终是一档就行了，油门也是锁死的，所以只要看离合与刹车两个踏板。核心要点：<strong>速度慢一点</strong>。</p><h3 id="开始前准备"><a href="#开始前准备" class="headerlink" title="开始前准备"></a>开始前准备</h3><ol><li>系好安全带</li><li>调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜</li><li>调整内外后视镜。左后视镜下边缘差不多与后车轮下边缘重合为宜，右后视镜车身差不多占1&#x2F;3，然后地平线位于上下1&#x2F;2左右。（具体不记得了，笔者自己也有点弄不明白这里，请大佬指点）</li></ol><h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p>笔者第一次科二两把都挂在这儿了，都是“倒库不入”。正确的操作如下：</p><ol><li>首先鼻子正对从右往左数第三条虚线左边缘开，直到开到虚线与肩膀对齐。</li><li>挂倒挡，看左后视镜下边缘，差不多与虚线前边缘对齐或间隔几厘米的时候（因人而异），向左打死方向盘。</li><li>往后倒的同时观察左后视镜，三条虚线压住两条半了看车身与库边缘的距离，如果较大（30cm以上？），则保持打死状态继续倒，否则回半圈继续倒。</li><li>主要通过右后视镜观察车身是否正。这时候需要自己微调，反正就车屁股要往左就方向盘往左打，车屁股要往右就往右打。</li><li>车身正了，端平方向盘，看左后视镜，差不多等到左后视镜完全压住黄线了，停车。</li><li>挂前进档，起步。观察左后视镜看到左后轮压到前库线了，向右打死方向盘。车身正，回半圈方向盘继续开直到左侧车门框压到黄虚线。</li><li>挂倒挡，起步。待左后视镜对齐黄线了向右打半圈并开始观察右后视镜。看三条虚线类似上边第3、4点进行调整。</li><li>完全停好，挂前进档，起步。同样观察左后视镜看到左后轮压到前库线了（或者这里也可以稍微提前一点），向左打死。车身正回正。前轮过黄虚线后轮不过。结束倒车入库。</li><li>倒车入库的时间要求是：210s（3.5min）</li></ol><h3 id="坡道定点停车与起步"><a href="#坡道定点停车与起步" class="headerlink" title="坡道定点停车与起步"></a>坡道定点停车与起步</h3><ol><li>上坡前离合要稍微踩下边一点，鼻子对准从右往左数第二第三条虚线中间开（保证左右间距）。开到差不多坡顶前，看前车窗右侧商标距离杆子还有2cm左右时踩离合与刹车停车。</li><li>拉手刹，等3s，松手刹。</li><li>踩住刹车，很缓慢地松离合直到车身抖动或发动机转速表指针往下掉了一下，方向盘稍微往左打一点防止待会压右侧线。松刹车起步。</li><li>坡道定点停车与起步无时间要求。</li></ol><h3 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h3><ol><li>进入右直角转弯区域前需要先左转，所以先向左打死，然后提前做准备打好右转灯。</li><li>进入区域，车身正方向盘回正。等到右边门把手右端点位于黄线前1~2cm时往右打死。</li><li>车身正回正，稍微开两步继续向左打死。（右直角转弯只评判右直角，所以这里左转压线也没事）</li><li>直角转弯无时间要求。</li></ol><h3 id="曲线行驶"><a href="#曲线行驶" class="headerlink" title="曲线行驶"></a>曲线行驶</h3><ol><li>往前看并伸长脖子看引擎盖左边一个凹下出，当凹下处压线后向左打一圈，方向盘微调使凹下处沿着曲线右边线走。</li><li>保持左一圈的动作直到上述凹下处压到曲线左边界，回正，往前开。</li><li>看到雨刮器铆钉旁凹下处右侧2~3cm处与曲线左边界重合后，往右打一圈。然后往前开直到驶出曲线行驶路段。</li><li>曲线行驶无时间要求。</li></ol><h3 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h3><ol><li>首先调整边缘线与车身差不多30cm左右的位置。然后保持车身与右边缘线这个间距平行，注意观察右后视镜，直到右后视镜中出现一个直角（侧方的库的边缘角）。</li><li>挂倒挡，后退直到直角消失迅速向右打死。</li><li>往后的同时低头观察左后视镜，看到两条虚线方向盘迅速回正。然后伸长脖子注意左后轮，压到黄虚线位置后迅速往左打死。</li><li>观察右后视镜，到车身平行入库时踩离合刹车停车。</li><li>保持左打死状态，打左转向灯，换前进档。引擎盖左侧凹下处压左边线后迅速回正。引擎盖一半压黄线时向右打一圈，车身正回正，侧方停车完成。</li><li>侧方停车的时间要求是：从挂倒挡起90s内完成。</li></ol><h2 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h2><h3 id="起步前准备"><a href="#起步前准备" class="headerlink" title="起步前准备"></a>起步前准备</h3><ol><li>系好安全带</li><li>调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜</li><li>调整内外后视镜</li></ol><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>停车时应处于空挡、手刹拉好的状态。想要起步，首先应该踩死离合与刹车。打开左转向灯，等3秒后，观察后方情况。确认安全后挂一档，松手刹，松刹车，缓松离合。等待4s左右完全放掉离合（考试要求6s内），踩油门加速。</p><h3 id="换挡"><a href="#换挡" class="headerlink" title="换挡"></a>换挡</h3><p>首先是各挡位的速度对应：</p><table><thead><tr><th>速度</th><th>挡位</th></tr></thead><tbody><tr><td>10码以下</td><td>一档</td></tr><tr><td>10~20码</td><td>二档</td></tr><tr><td>20~35码</td><td>三档</td></tr><tr><td>35~40码</td><td>四档</td></tr><tr><td>40码以上</td><td>五档</td></tr></tbody></table><p>换档前，首先踩油门到挡位速度的分界线。然后松油门，踩死离合，换挡，松离合，完成换挡操作。考试要求换挡在6s内完成。</p><p>加档必须一档一档加上（比如停车时空挡再起步就只能从一档开始加上去），减档可以跳着减（只要速度挡位匹配）。</p><h3 id="变更车道与超车"><a href="#变更车道与超车" class="headerlink" title="变更车道与超车"></a>变更车道与超车</h3><p>先打转向灯，等待3s后观察后方情况，然后转方向盘进入另一车道。</p><h3 id="十字路口的转向"><a href="#十字路口的转向" class="headerlink" title="十字路口的转向"></a>十字路口的转向</h3><h4 id="右转"><a href="#右转" class="headerlink" title="右转"></a>右转</h4><p>看地上标线，一般是有三个右转向的箭头。从近及远，第一个之前或差不多那时候打右转向灯，第二个的地方减档，紧接着是点踩刹车和左右摇头观察情况。（考试时常规要保持三档20码左右的速度，所以这里减档就是到二档）。彻底完成转向后加速回到三档。右转即走右车道，但要注意不要开到非机动车道上去。</p><h4 id="左转"><a href="#左转" class="headerlink" title="左转"></a>左转</h4><p>类似右转，不过是“左转左车道”。</p><h3 id="掉头"><a href="#掉头" class="headerlink" title="掉头"></a>掉头</h3><p>我考试的情况是左右两车道，并且靠侧边的是非机动车道。所以掉头时要先借右侧辅道。</p><p>首先打右转向灯，然后减二档，等待3s观察右后方情况，确认安全后进入右侧辅道。接着关闭右转灯，打左转灯，等待3s观察<strong>左前方和左后方</strong>的情况，确认安全后往左打死。这中间可以稍微踩点刹车放慢点速度。</p><h3 id="靠边停车"><a href="#靠边停车" class="headerlink" title="靠边停车"></a>靠边停车</h3><p>首先右转向灯，打一档，等3s后观察右后方情况。确认安全后进入右边车道停车。</p><h3 id="减速与停车"><a href="#减速与停车" class="headerlink" title="减速与停车"></a>减速与停车</h3><p>减速就是踩刹车；</p><p>停车要离合刹车一起踩并且离合要踩得更快更早一点点。车停后记得挂空挡。</p><p>考试过程中，除了人行横道，其余地方都可以停车。所以善用它！</p><h3 id="点踩刹车与左右摇头观察"><a href="#点踩刹车与左右摇头观察" class="headerlink" title="点踩刹车与左右摇头观察"></a>点踩刹车与左右摇头观察</h3><p>这点实际开车应该都没人做吧，完全是应付考试了。需要在路口转弯、靠近人行横道、公交车站的地方做这个动作。</p><p>注意点主要是：点踩刹车不用踩太下，碰一下刹车立马抬起就行了。两次点踩刹车不要太连续，不然容易掉档。摇头的时候，幅度要大一点。</p><h3 id="夜间灯光考试"><a href="#夜间灯光考试" class="headerlink" title="夜间灯光考试"></a>夜间灯光考试</h3><h4 id="近光灯"><a href="#近光灯" class="headerlink" title="近光灯"></a>近光灯</h4><ul><li>夜间同方向近距离<strong>跟车</strong>行驶</li><li>夜间在窄桥&#x2F;窄路上与非机动车<strong>会车</strong></li><li>夜间<strong>直行通过路口</strong></li><li>夜间在照明<strong>良好</strong>的道路上行驶</li></ul><h4 id="远光灯"><a href="#远光灯" class="headerlink" title="远光灯"></a>远光灯</h4><ul><li>夜间在没有路灯、照明<strong>不良</strong>的道路上行驶</li></ul><h4 id="远近灯光交替"><a href="#远近灯光交替" class="headerlink" title="远近灯光交替"></a>远近灯光交替</h4><ul><li>夜间通过<strong>急弯&#x2F;坡路&#x2F;拱桥</strong></li><li>夜间通过<strong>没有</strong>交通信号灯的路口</li><li>夜间<strong>超越</strong>前方车辆</li></ul><h4 id="示宽灯双闪"><a href="#示宽灯-双闪" class="headerlink" title="示宽灯+双闪"></a>示宽灯+双闪</h4><ul><li><strong>路边临时停车</strong></li><li>夜间在路口发生交通事故，<strong>妨碍交通难以移动</strong></li></ul><h2 id="科目四"><a href="#科目四" class="headerlink" title="科目四"></a>科目四</h2><p>刷了300道不到去了，大部分都是常识，相对比较好过。</p><h2 id="附笔者教练讲的完整流程及注意点"><a href="#附：笔者教练讲的完整流程及注意点" class="headerlink" title="附：笔者教练讲的完整流程及注意点"></a>附：笔者教练讲的完整流程及注意点</h2><h3 id="科二"><a href="#科二" class="headerlink" title="科二"></a>科二</h3><blockquote><p>【侧方停车】(1)先调整好边缘线30公分左右，再看向右面大反光镜直角出来就停车。(2)开始挂倒挡，倒车看后右反光镜看不见直角。就向右把方向打死。(3)再看左反光镜里后面露出两条虚线把方向回正。(4)然后在看左后轮压虚线向左打死。(5)最后再看大镜车身平行刚进虚线就停。【2】出侧方位，打左转向灯。挂前进挡出库看前面左车头凹巢面挡外框黄线把方向回正。继续向前左车头当一半外面黄线时向右打一圈车身正把它回正。侧方位结束。【3】侧方位规定在挂倒挡开始90秒之内完成。【倒车入库】先看从右边数第三条虚线停在我们车中间与肩膀平行，倒车入库开始两百十秒钟完成。看左反光镜下檐 余肩膀线从合同时 向左打死方向，再看左反光镜库里面第三条虚线挡住一半时把方向回半圈。再看右面反光镜与库线平行，把方向右回正。在看左前反光镜下檐 于库角线刚从合停车。挂前档向右时看两反光镜调整出库大小。左后轮到库角向右打死，车头正回半圈。一直到肩膀停车，挂倒档看左镜子下檐于肩膀线从合向右打半圈打死。右面大反光镜库第三条虚线时一半把方向回半圈。就是等车上与地上黄线平行。把方向全部回正。就等停车看前面左反光镜檐于 库角线停车，出库调整大小左后面库角向左打死。车身正回正前轮到肩膀线。</p></blockquote><h3 id="科三"><a href="#科三" class="headerlink" title="科三"></a>科三</h3><blockquote><p> 1.继续完成考试。先打左转向灯。向左回头观望。确保安全后。踩离合。挂一挡。松手刹。又手推到一点钟的位置。右脚放油门。左脚慢慢抬起离合。车子开始走动一般数四秒。把离合器全部松掉。 (记住 左脚必须在六秒钟之内。完全离合器踏板。超过六秒扣100分，行车过程中。加减档 也必须在。六秒钟内完成)，从松手下到起步 必须十秒钟内起步走哦  2.行车过程中。加速加档。10码以上加二档20码以上加三档35码以上加四档。加档只能一个一个档往上加。不能跳跃加档，减档可以速度与档位匹配时可以越档位减档。3.还有会车动作，准备会车稍微向左一点。不要压中心线。听到电脑语音指定。与机动车会车。向右靠。沿着右边线点行驶。小心右边压线。3到4秒后，电脑语音指定。结束回车。你靠中心随便行驶。会车结束以后。直接踩油门踩35码以上加四档。四挡加上去离合器放掉5秒过后，踩离合直接推三档，四档就完成了。4.超越前方车辆。电脑发出指定，你打左转向灯。向前方数三秒后，向左回头观望。头必须左后90度以上观望。确认安全后，方向稍微向左。行驶到另一个车道。等车辆完全进入另一个车道后，关闭左转向灯。车身直驶回原车道。你打开右转向灯。向前方数三秒后向右回头观望。头必须90度以上。方向稍微向右使上另一个车道，完全进入另一个车道后把转向灯关掉。5.直线行驶。一般的我教听到指令控制好方向油门踩上去。达到40km以上中间会听到我的敲门声松掉油门。。让它自由滑行。方向微调。记住必须直线行驶100米以后。会听到结束直线行驶。滑行自由行驶了，6.遇到路口一般减速减档轻点刹车左右观望。人行横道，公交车站台轻点刹车，左右观望通过。停车放空挡。7.听到适当路口掉头时，借右侧辅道先打右转向灯。减二档。三秒以后回头观望。向右进入辅道记住小心右面压边线。完全进入辅道后启左转向灯，三秒以后。向左回头观望。一把快打死掉头。8.进入对方车道路后，准备停车。打好右转向灯，记住一定要等好电脑指令。请靠边停车。可以换一挡数三秒。右回头观望后往右向右靠。注意停不进去随时随地都可以停车放空挡等， 看前小反光镜与边线30公分以内。踩离合踩刹车。放空挡拉手刹。等电脑成绩合格。才可下车。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 插件 hexo-bilibili-card 的使用与修改</title>
      <link href="/posts/bb53ea7f.html"/>
      <url>/posts/bb53ea7f.html</url>
      
        <content type="html"><![CDATA[<p>使用 Hexo 写博文时，可能需要插入一个视频卡片。我使用的 Icarus 主题提供了 Youtube 的视频卡片，而我更需要的是 Bilibili 的。于是找到了这个插件—— <a href="https://github.com/MaxChang3/hexo-bilibili-card">hexo-bilibili-card</a> 。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-bilibili-card --save</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在你的 Markdown 文档中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bilicard av/BV %&#125;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><strong>2022&#x2F;10&#x2F;26 更新：</strong>插件更新了，以下内容行数不对了，作废。</p><p>使用过程中，我对其本身的样式不太满意，便对其 CSS 进行了一定程度的修改。</p><p>打开 <code>&lt;Blog_path&gt;\node_modules\hexo-bilibili-card\source\bilicard.css</code></p><p>注释掉第 90 行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-top</span>: <span class="number">1px</span>;</span><br></pre></td></tr></table></figure><p>注释掉第 121 行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: <span class="number">78px</span>;</span><br></pre></td></tr></table></figure><p>修改第 119 行为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bottom</span>: <span class="number">2px</span>;</span><br></pre></td></tr></table></figure><p>修改第 141~142 行为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">15px</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Web </tag>
            
            <tag> Hexo插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blender 自学日记（一）：界面与基础操作</title>
      <link href="/posts/5aa9eb29.html"/>
      <url>/posts/5aa9eb29.html</url>
      
        <content type="html"><![CDATA[<p>该系列是笔者在自学 Blender 的过程中所作的笔记。课程来源是 <a href="https://www.doyoudo.com/">doyoudo</a>。这篇笔记是第一课的学习内容。</p><span id="more"></span><div class="bvideo"><a href="//www.bilibili.com/video/BV1Ng411d7Be" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://pic1.xuehuaimg.com/proxy/http://i2.hdslb.com/bfs/archive/bc07ed55b12a6a8bdac972abda7c4fd07be764ae.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:08:45</span>            </div>            <div class="bvideo-info">                <p class="title">Blender自学日记，新手系统案例课！第一集</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>5.3万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>173</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">doyoudo</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>按住 <code>~</code> 同时<code>鼠标选择</code>：快捷切换视图</p><p><code>Ctrl + Alt + Q</code>：切换四视图显示</p><p><code>鼠标中键</code>：旋转视图</p><p><code>Shift + 鼠标中键</code>：移动视图</p><p>右侧网格按钮：切换为 2.5D 创作视图</p><p><code>X</code>：删除元素</p><p><code>Shift + A</code>：新建元素</p><p><code>N</code>：调出常用属性</p><p>锁定摄像机：进入摄像机后可以直接调整视图</p><p><code>G</code>：移动物体</p><p><code>R</code>：旋转物体</p><p><code>S</code>：放大缩小</p><p><code>G/S + X/Y/Z</code>：按照轴向去移动&#x2F;放缩</p><p><code>鼠标右键</code>：取消刚才的这些操作</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 建模 </category>
          
          <category> Blender </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 建模 </tag>
            
            <tag> Blender </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 使用 Bulma 美化文章</title>
      <link href="/posts/14706354.html"/>
      <url>/posts/14706354.html</url>
      
        <content type="html"><![CDATA[<p>虽然笔者已经在博客上安装了 <a href="https://github.com/lxl80/hexo-admonition">hexo-admonition</a> 插件来一定程度上对主体为 Markdown 的文章进行一定样式上的补充，但该插件所能提供的内容确实有限。如果能使用原生的 Html 和 CSS 技术自定义文章某些内容就好了。</p><span id="more"></span><p>搜索资料时看到了这两篇文章：</p><ul><li><a href="https://www.imaegoo.com/2020/icarus-with-bulma/">活用 Bulma 美化 Icarus 文章</a></li><li><a href="https://kuusei.moe/coding/%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/Hexo%E5%92%8CIcarus%E6%8A%98%E8%85%BE/">Hexo和Icarus折腾</a></li></ul><p>现做一些学习笔记。</p><h2 id="在-markdown-文件中插入-html-和-css-内容"><a href="#在-Markdown-文件中插入-Html-和-CSS-内容" class="headerlink" title="在 Markdown 文件中插入 Html 和 CSS 内容"></a>在 Markdown 文件中插入 Html 和 CSS 内容</h2><p>使用下面的 <code>raw</code> 标签:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">//在这里添加一些内容不希望被渲染的内容</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>可以让我们在 Markdown 文档中添加 Html 内容，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notification is-info&quot;</span>&gt;</span></span><br><span class="line">这是一段 info</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><p>显示为</p><div class="notification is-info">这是一段 info</div><p>而通过 <code>&lt;style type=&quot;text/css&quot;&gt;</code> 和 <code>&lt;/style&gt;</code> 标记，我们又可以在 Html 内容中直接添加 CSS 内容。</p><h2 id="用-bulma-实现的一些常见的玩意儿"><a href="#用-Bulma-实现的一些常见的玩意儿" class="headerlink" title="用 Bulma 实现的一些常见的玩意儿"></a>用 Bulma 实现的一些常见的玩意儿</h2><p>直接看 <a href="https://www.imaegoo.com/2020/icarus-with-bulma/">《活用 Bulma 美化 Icarus 文章》</a>这篇文章吧</p><h2 id="在-vs-code-中预览-bulma-内容"><a href="#在-VS-Code-中预览-Bulma-内容" class="headerlink" title="在 VS Code 中预览 Bulma 内容"></a>在 VS Code 中预览 Bulma 内容</h2><p>首先在 VS Code 中按下 <code>Ctrl + Shift + X</code> 打开扩展页面。安装 <code>Markdown Preview Enhanced</code>。重启你的 VS Code，然后使用 <code>Ctrl + K</code>、<code>V</code> 打开侧边预览。(具体见该插件的<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/">官方中文文档</a>)</p><p>接着添加 Bulma 的CSS：按下 <code>Ctrl + Shift + P</code>，输入 <code>Markdown Preview Enhanced: Customize CSS</code>，回车。笔者直接使用 <code>@import</code> 进行引入。</p><p>所以只要在上面命令打开的 <code>style.less</code> 开头添加:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css&quot;</span>;</span><br></pre></td></tr></table></figure><p>按下 <code>Ctrl + Shift + P</code>，输入 <code>Markdown Preview Enhanced: Extend Parser</code>，回车。编辑 <code>onWillParseMarkdown</code>。在下边的<strong>这是一个标记</strong>处：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onWillParseMarkdown</span>: <span class="keyword">function</span>(<span class="params">markdown</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//这是一个标记</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(markdown)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">markdown = markdown.<span class="title function_">replace</span>(</span><br><span class="line">  <span class="regexp">/\&#123;% raw %&#125;/g</span>,</span><br><span class="line">  <span class="function">(<span class="params">whole</span>) =&gt;</span>  (<span class="string">``</span>)</span><br><span class="line">)</span><br><span class="line">markdown = markdown.<span class="title function_">replace</span>(</span><br><span class="line">  <span class="regexp">/\&#123;% endraw %&#125;/g</span>,</span><br><span class="line">  <span class="function">(<span class="params">whole</span>) =&gt;</span>  (<span class="string">``</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在它看起来应该是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onWillParseMarkdown</span>: <span class="keyword">function</span> (<span class="params">markdown</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      markdown = markdown.<span class="title function_">replace</span>(</span><br><span class="line">        <span class="regexp">/\&#123;% raw %&#125;/g</span>,</span><br><span class="line">        <span class="function">(<span class="params">whole</span>) =&gt;</span> (<span class="string">``</span>)</span><br><span class="line">      )</span><br><span class="line">      markdown = markdown.<span class="title function_">replace</span>(</span><br><span class="line">        <span class="regexp">/\&#123;% endraw %&#125;/g</span>,</span><br><span class="line">        <span class="function">(<span class="params">whole</span>) =&gt;</span> (<span class="string">``</span>)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(markdown)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="上面的方法存在的问题以及也许可行的解决方案暂未实际解决"><a href="#上面的方法存在的问题以及也许可行的解决方案-暂未实际解决" class="headerlink" title="上面的方法存在的问题以及也许可行的解决方案(暂未实际解决)"></a>上面的方法存在的问题以及也许可行的解决方案(暂未实际解决)</h2><p><code>Markdown Preview Enhanced</code> 替换的时候会将所有的 <code>raw</code> 标签全部替换掉，以至于在渲染源代码部分时，会出现一些错误。但这些错误仅在本地的 VS Code 渲染时发生，在网页上是没有问题的。但还是… 让强迫症很难受。</p><p>现在的需求是，如果 <code>raw</code> 标签位于代码块中，那么渲染时它无需被删除，否则应该被删除。</p><p>笔者的思路是：检测 <code>raw</code> 标签的上下文，如果上文包含了标记为 Html&#x2F;js 的代码块起始标记，下文包含了代码块结束标记，则不进行替换；反之进行替换。</p><p>暂未实际实现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Web </tag>
            
            <tag> Bulma </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 在 Icarus 主题下更改字体</title>
      <link href="/posts/2527d7a7.html"/>
      <url>/posts/2527d7a7.html</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在使用Hexo搭建博客的过程中，笔者发现使用<code>hexo s</code>创建的<code>localhost:4000</code>显示的网页上的字体效果与<code>hexo d</code>到github上的网页字体效果不同。遂想统一两者字体，希望通过换字体的方式达到该目的。</p><span id="more"></span><h2 id="选择字体"><a href="#选择字体" class="headerlink" title="选择字体"></a>选择字体</h2><p>英文笔者选择的是<code>JetBrains Mono</code>，中文笔者选择的是<code>Source Han Sans CN VF Blod</code>(思源黑体)。需要注意的是我们不仅要找到某个自己喜欢的字体，还需要找到字体对应的英文名。本文以这两个开源字体为例。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>icarus的字体设置位于<code>&lt;Blog_path&gt;\node_modules\hexo-theme-icarus\include\style</code>下的<code>base.styl</code>中。第9~10行，原来为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$family</span>-sans-serif ?= Ubuntu, Roboto, <span class="string">&#x27;Open Sans&#x27;</span>, <span class="string">&#x27;Microsoft YaHei&#x27;</span>, sans-serif</span><br><span class="line"><span class="variable">$family</span>-<span class="selector-tag">code</span> ?= <span class="string">&#x27;Source Code Pro&#x27;</span>, monospace, <span class="string">&#x27;Microsoft YaHei&#x27;</span></span><br></pre></td></tr></table></figure><p>现改为（将所需字体添加在最前面）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$family</span>-sans-serif ?= <span class="string">&#x27;JetBrains Mono&#x27;</span>, <span class="string">&#x27;Source Han Sans CN VF Blod&#x27;</span>, Ubuntu, Roboto, <span class="string">&#x27;Open Sans&#x27;</span>, <span class="string">&#x27;Microsoft YaHei&#x27;</span>, sans-serif</span><br><span class="line"><span class="variable">$family</span>-<span class="selector-tag">code</span> ?= <span class="string">&#x27;JetBrains Mono&#x27;</span>, <span class="string">&#x27;Source Han Sans CN VF Blod&#x27;</span>, <span class="string">&#x27;Source Code Pro&#x27;</span>, monospace, <span class="string">&#x27;Microsoft YaHei&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>起因中的问题莫名其妙消失了… 于是笔者改回了原来的样子。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 插件 hexo-admonition 在 Icarus 主题下的使用与测试</title>
      <link href="/posts/f81be6d0.html"/>
      <url>/posts/f81be6d0.html</url>
      
        <content type="html"><![CDATA[<p>Hexo 博客中的文章是使用 Markdown 来渲染的。虽然原版 Markdown 已经提供了很多样式，但笔者仍觉得有些不够。在翻 Hexo 的官方插件列表时，笔者找到了 hexo-admonition 这个插件来为博文添加更多样式。</p><span id="more"></span><h2 id="插件官方说明"><a href="#插件官方说明" class="headerlink" title="插件官方说明"></a>插件官方说明</h2><p><a href="https://github.com/lxl80/hexo-admonition/blob/master/README.md">https://github.com/lxl80/hexo-admonition/blob/master/README.md</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先使用npm安装该插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-admonition --save</span><br></pre></td></tr></table></figure><p>接着更改你的hexo主题的css。我使用的icarus主题，所以在<code>&lt;blog_path&gt;\node_modules\hexo-theme-icarus\include\style</code>下的<code>article.styl</code>结尾添加了如下内容（因为是<code>.styl</code>而非<code>.css</code>，所以对官方提供的内容使用<a href="http://tools.jb51.net/code/css2less">这个</a>工具进行了转换）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hexo-admonition</span></span><br><span class="line"><span class="selector-class">.admonition</span> </span><br><span class="line">  <span class="attribute">margin</span> <span class="number">1.5625em</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">padding</span> .<span class="number">6rem</span></span><br><span class="line">  <span class="attribute">overflow</span> hidden</span><br><span class="line">  <span class="attribute">font-size</span> .<span class="number">64rem</span></span><br><span class="line">  <span class="attribute">page-break-inside</span> avoid</span><br><span class="line">  <span class="attribute">border-left</span> .<span class="number">3rem</span> solid <span class="number">#42b983</span></span><br><span class="line">  <span class="attribute">border-radius</span> .<span class="number">3rem</span></span><br><span class="line">  <span class="attribute">box-shadow</span> <span class="number">0</span> <span class="number">0.1rem</span> <span class="number">0.4rem</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">05</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">0.05rem</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>)</span><br><span class="line">  <span class="attribute">background-color</span> <span class="number">#fafafa</span></span><br><span class="line">  &amp; &gt; <span class="selector-pseudo">:last-child</span> </span><br><span class="line">    <span class="attribute">margin-bottom</span> <span class="number">0</span> <span class="meta">!important</span></span><br><span class="line"><span class="selector-tag">p</span> </span><br><span class="line">  &amp;<span class="selector-class">.admonition-title</span> </span><br><span class="line">    <span class="attribute">position</span> relative</span><br><span class="line">    <span class="attribute">margin</span> -.<span class="number">6rem</span> -.<span class="number">6rem</span> .<span class="number">8em</span> -.<span class="number">6rem</span> <span class="meta">!important</span></span><br><span class="line">    <span class="attribute">padding</span> .<span class="number">4rem</span> .<span class="number">6rem</span> .<span class="number">4rem</span> <span class="number">2.5rem</span></span><br><span class="line">    <span class="attribute">font-weight</span> <span class="number">700</span></span><br><span class="line">    <span class="attribute">background-color</span> <span class="built_in">rgba</span>(<span class="number">66</span>, <span class="number">185</span>, <span class="number">131</span>, .<span class="number">1</span>)</span><br><span class="line"><span class="selector-class">.admonition-title</span> </span><br><span class="line">  <span class="selector-pseudo">&amp;::before</span> </span><br><span class="line">    <span class="attribute">position</span> absolute</span><br><span class="line">    <span class="attribute">top</span> .<span class="number">9rem</span></span><br><span class="line">    <span class="attribute">left</span> <span class="number">1rem</span></span><br><span class="line">    <span class="attribute">width</span> <span class="number">12px</span></span><br><span class="line">    <span class="attribute">height</span> <span class="number">12px</span></span><br><span class="line">    <span class="attribute">background-color</span> <span class="number">#42b983</span></span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">    <span class="attribute">content</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">.info&gt;<span class="selector-class">.admonition-title</span>, .todo&gt;<span class="selector-class">.admonition-title</span> </span><br><span class="line">  <span class="attribute">background-color</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">184</span>,<span class="number">212</span>,.<span class="number">1</span>)</span><br><span class="line">.warning&gt;<span class="selector-class">.admonition-title</span>, .attention&gt;<span class="selector-class">.admonition-title</span>, .caution&gt;<span class="selector-class">.admonition-title</span> </span><br><span class="line">  <span class="attribute">background-color</span> <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">145</span>,<span class="number">0</span>,.<span class="number">1</span>)</span><br><span class="line">.failure&gt;<span class="selector-class">.admonition-title</span>, .missing&gt;<span class="selector-class">.admonition-title</span>, .fail&gt;<span class="selector-class">.admonition-title</span>, .error&gt;<span class="selector-class">.admonition-title</span> </span><br><span class="line">  <span class="attribute">background-color</span> <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">82</span>,<span class="number">82</span>,.<span class="number">1</span>)</span><br><span class="line"><span class="selector-class">.admonition</span><span class="selector-class">.info</span>, <span class="selector-class">.admonition</span><span class="selector-class">.todo</span> </span><br><span class="line">  <span class="attribute">border-color</span> <span class="number">#00b8d4</span></span><br><span class="line"><span class="selector-class">.admonition</span><span class="selector-class">.warning</span>, <span class="selector-class">.admonition</span><span class="selector-class">.attention</span>, <span class="selector-class">.admonition</span><span class="selector-class">.caution</span> </span><br><span class="line">  <span class="attribute">border-color</span> <span class="number">#ff9100</span></span><br><span class="line"><span class="selector-class">.admonition</span><span class="selector-class">.failure</span>, <span class="selector-class">.admonition</span><span class="selector-class">.missing</span>, <span class="selector-class">.admonition</span><span class="selector-class">.fail</span>, <span class="selector-class">.admonition</span><span class="selector-class">.error</span> </span><br><span class="line">  <span class="attribute">border-color</span> <span class="number">#ff5252</span></span><br><span class="line">.info&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span>, .todo&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span> </span><br><span class="line">  <span class="attribute">background-color</span> <span class="number">#00b8d4</span></span><br><span class="line">  <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">.warning&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span>, .attention&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span>, .caution&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span> </span><br><span class="line">  <span class="attribute">background-color</span> <span class="number">#ff9100</span></span><br><span class="line">  <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">.failure&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span>,.missing&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span>,.fail&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span>,.error&gt;<span class="selector-class">.admonition-title</span><span class="selector-pseudo">::before</span> </span><br><span class="line">  <span class="attribute">background-color</span> <span class="number">#ff5252</span></span><br><span class="line">  <span class="attribute">border-radius</span> <span class="number">50%</span></span><br></pre></td></tr></table></figure><p>后自己微调将第24行由</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span> .<span class="number">9rem</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span> <span class="number">0.6rem</span></span><br></pre></td></tr></table></figure><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!!! &lt;type&gt; &lt;title&gt;</span><br><span class="line">(四个空格)</span><br><span class="line">(**空行结束标记**)</span><br></pre></td></tr></table></figure><p>type支持：</p><ul><li>note</li><li>info, todo</li><li>warning, attention, caution</li><li>error, failure, missing, fail</li></ul><div class="admonition warning"><p class="admonition-title"> “活学活用” </p><p>当<code>&lt;title&gt;</code>未设置时，将会以<code>&lt;type&gt;</code>作为标题如果要设置空标题，应当使用<code>&quot;&quot;</code></p></div><div class="admonition warning"><p class="admonition-title">这非常重要！ </p><p><strong>空行结束标记</strong>不能少！</p></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><div class="admonition note"><p>这是一条note</p></div><div class="admonition info"><p>这是一条info</p></div><div class="admonition todo"><p>这是一条todo</p></div><div class="admonition warning"><p>这是一条warning</p></div><div class="admonition attention"><p>这是一条attention</p></div><div class="admonition caution"><p>这是一条caution</p></div><div class="admonition error"><p>这是一条error</p></div><div class="admonition failure"><p>这是一条failure</p></div><div class="admonition missing"><p>这是一条missing</p></div><div class="admonition fail"><p>这是一条fail</p></div><hr><p>2022年9月10日更新：</p><p>发现原来 Icarus 主题本身已经提供了类似功能：<a href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/%E8%87%AA%E5%AE%9A%E4%B9%89hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/">自定义Hexo标签插件</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Web </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 使用 Icarus 主题安装 abbrlink 插件后 toc 插件生成的目录存在错误无法跳转的问题</title>
      <link href="/posts/a55922c1.html"/>
      <url>/posts/a55922c1.html</url>
      
        <content type="html"><![CDATA[<p>配置 Heox 博客，为了优化 seo，安装了 abbrlink 插件。但突然发现原来可以正常使用的 Icarus 主题自带的 toc 目录侧边栏无法正常跳转。查看源代码发现<code>&lt;a&gt;</code>标签的<code>href</code>属性均显示为<code>&quot;#&quot;</code>而非正确地址，遂前往寻找解决方案。</p><span id="more"></span><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>来源：<a href="https://blog.csdn.net/weixin_45149481/article/details/116794535">hexo 文章目录点击不跳转，html 没有生成 href_宁理大神 1996 的博客-CSDN 博客</a></p><p>修改<code>(你的Blog目录)/node_modules/hexo-toc/lib/filter.js</code>中的<strong>29~31</strong>行</p><p>由原来的这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$title.attr(&#x27;id&#x27;, id);</span></span><br><span class="line">$title.<span class="title function_">children</span>(<span class="string">&quot;a&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line">$title.<span class="title function_">html</span>(<span class="string">&#x27;&lt;span id=&quot;&#x27;</span> + id + <span class="string">&#x27;&quot;&gt;&#x27;</span> + $title.<span class="title function_">html</span>() + <span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">$title.<span class="title function_">removeAttr</span>(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$title.<span class="title function_">attr</span>(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line"><span class="comment">// $title.children(&#x27;a&#x27;).remove();</span></span><br><span class="line"><span class="comment">// $title.html( &#x27;&lt;span id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; + $title.html() + &#x27;&lt;/span&gt;&#x27; );</span></span><br><span class="line"><span class="comment">// $title.removeAttr(&#x27;id&#x27;);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 问题 </tag>
            
            <tag> 已解决 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RLCraft 新手教程一：过渡到你的正常生存</title>
      <link href="/posts/a1ada34d.html"/>
      <url>/posts/a1ada34d.html</url>
      
        <content type="html"><![CDATA[<p>本教程是笔者自己游玩过程中写的，出发点是笔者自己想玩但又不想花费时间看很多实况去了解一些细节，又找不到比较详细的文字版中文教程，以致于无从下手，只能慢慢啃各种模组的百科和 RLCraft Wiki，便以教程形式写下自己的游玩过程，希望对后来者有所帮助。笔者不是什么资深玩家，故难免有疏漏，请大家多多包涵。</p><span id="more"></span><p>由于 NTP 模组（<a href="https://www.mcmod.cn/class/2138.html">No Tree Punching，无树可撸</a>）的存在，初入 RLCraft，你的第一件事情不再是获取原木，而是撸树叶获取木棍，然后找到沙砾获取燧石。你可以按住鼠标左键徒手破坏树叶和沙砾，然后用右键点击掉落物以拿起它（或者你也可以按下 shift 来吸取附近的掉落物）。</p><p>手拿燧石右击石头&#x2F;圆石等坚硬方块（?）上表面，你可以获取燧石碎块，然后打开背包，在 2*2 的合成栏上边放燧石碎块，下边放木棍，获取一把粗糙的小刀。</p><p>使用粗糙的小刀破坏草，可以获得植物纤维，在背包合成栏用三个植物纤维合成一个植物绳。然后再使用燧石碎块、植物绳、木棍合成粗糙的斧头。恭喜你获取了这个游戏的第一把斧头，用这把斧头你就可以开采原木了——当心，树倒下来可能会砸死你！</p><p>你不再能够直接使用背包合成栏分解原木，而是需要把原木竖直放在地上，并用斧头右击其上表面，以获取两块木板。木棍也可以用类似的方式获取——将木板放在地上，然后用斧头右击。</p><p>你可以看 jei 获取更多燧石工具的制作方法，但你更可以开始制作原版的木制工具。用木镐挖石头会掉落石子，四个石子 2*2 摆放可以获取圆石，而挖圆石则会直接掉落圆石。</p><p>恭喜你进入石器时代！现在，你可以开始下矿了！但要时刻注意的一点是照明——恐怖生物会在黑暗中生成… 别自己怎么死的都不知道。你会发现木棍加煤炭不再能合成原版火把，它们现在只能合成熄灭的火把。要点亮它们，你需要的是一颗打火石——将熄灭的火把和打火石放在合成栏里，你就可以获得点燃的火把。但这火把仍然会熄灭——比如一场雨过后，比如燃烧很久之后…</p><p>虽然还有很多路要走，但你现在基本上可以短暂地享受一回类原版的 MC 了。</p><p>To be continue…</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> Minecraft </category>
          
          <category> RLCraft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> Minecraft </tag>
            
            <tag> RLCraft </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补记一个用 Vue.js 和 ElementUI 实现的在线抽奖网页</title>
      <link href="/posts/6a8a1633.html"/>
      <url>/posts/6a8a1633.html</url>
      
        <content type="html"><![CDATA[<p>这件事儿发生在我的高中某个新学期开始，新来了一个电脑老师。有点打赌或者考验我的性质吧，ta说ta弄了随机数点名的小网页，还能用同学的照片进行抽取，问我能不能实现一个。ta的实现方法是jQuery，技术上比较老，界面也不太好看。我想去尝试一下别的方法，正好也试试略微学了一点的Vue.js，为了好看，用了Element UI。</p><span id="more"></span><p>一两个周末最终实现到现在的效果，能输入名字抽人，能随机数抽人（学号抽人？），还有一个通过图片抽的到今天也还没做。当时对着Vue.js和Element UI的开发文档勉里勉强做出来这个效果，现在早把那些基础知识忘记了，也不知道以后有没有工夫完善它了。</p><p>你可以<a href="/NoRenderPages/CatchDog/CatchDog.html">点击这里</a>来玩玩看。</p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308b57316f2c2beb1fad0f4.png"><br><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308b57316f2c2beb1fad0ec.png"><br><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308b57216f2c2beb1fad081.png"><br><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308b57216f2c2beb1fad087.png"><br><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308b57216f2c2beb1fad091.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Web </category>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 记录 </tag>
            
            <tag> Web </tag>
            
            <tag> Vue.js </tag>
            
            <tag> Element UI </tag>
            
            <tag> Html </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edge 扩展推荐</title>
      <link href="/posts/3c91f84e.html"/>
      <url>/posts/3c91f84e.html</url>
      
        <content type="html"><![CDATA[<p>2019 年 7 月写过一篇 Chrome 插件推荐的文章，那时候我还在用 Chrome 作为我的主要浏览器。一晃三年过去了，我也早已从 Google Chrome 转入全新 Chromium 内核构建的 Edge 浏览器。微软倒蛮有意思，自己从头开发的东西不咋地，在别人的平台上倒是表现得相当好。由于国内的水土不服啊，我用 Chrome 时总会遇到同步不了的情况，这点的体验在 Edge 这儿得到了很好的改善，也是我用 Edge 的主要原因吧。前些天帮很多同学做新机开荒，也推荐他们就用这款“Win11 原装”浏览器。当然一个浏览器肯定是离不开扩展的，趁着帮他们开荒这个机会，也顺便整理了我认为必备的一些浏览器扩展。</p><span id="more"></span><p><strong>本文更多的从个人角度出发，仅涵盖了笔者的主要需求，自然是粗略的，仅供参考。</strong></p><h2 id="全部用户"><a href="#全部用户" class="headerlink" title="全部用户"></a>全部用户</h2><h3 id="dark-reader"><a href="#Dark-Reader" class="headerlink" title="Dark Reader"></a>Dark Reader</h3><p>简介：强制暗黑模式的网页</p><h3 id="infinity-新标签页-pro"><a href="#Infinity-新标签页-Pro" class="headerlink" title="Infinity 新标签页 (Pro)"></a>Infinity 新标签页 (Pro)</h3><p>简介：rt，一个新标签页扩展</p><h3 id="onetab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><p>简介： 打开了太多网页的时候，按一下可以帮你全部收起来，之后可以自由恢复</p><h3 id="prevent-duplicate-tabs"><a href="#Prevent-Duplicate-Tabs" class="headerlink" title="Prevent Duplicate Tabs"></a>Prevent Duplicate Tabs</h3><p>简介： 帮你干掉那些重复的标签页</p><h3 id="ublock-origin"><a href="#uBlock-Origin" class="headerlink" title="uBlock Origin"></a>uBlock Origin</h3><p>简介：干掉广告，且是众多去广告插件中占用相对较少的</p><h3 id="捕捉网页截图-fireshot-的"><a href="#捕捉网页截图-FireShot-的" class="headerlink" title="捕捉网页截图 - FireShot 的"></a>捕捉网页截图 - FireShot 的</h3><p>简介：rt，支持长截图（名字有点怪，可能是翻译问题，搜索 FireShot 就能找到）</p><h3 id="暴力猴"><a href="#暴力猴" class="headerlink" title="暴力猴"></a>暴力猴</h3><p>简介：装脚本的插件，和大名鼎鼎的油猴一样的功能，这个可能(?)小巧一点</p><h3 id="沙拉查词-聚合词典划词翻译"><a href="#沙拉查词-聚合词典划词翻译" class="headerlink" title="沙拉查词-聚合词典划词翻译"></a>沙拉查词-聚合词典划词翻译</h3><p>简介：rt，划词翻译，可配置内容超多</p><h3 id="imagus"><a href="#Imagus" class="headerlink" title="Imagus"></a>Imagus</h3><p>简介：可以把网页图片放大了看</p><h3 id="user-agent-switcher-for-chrome"><a href="#User-Agent-Switcher-for-Chrome" class="headerlink" title="User-Agent Switcher for Chrome"></a>User-Agent Switcher for Chrome</h3><p>简介：“伪装”你自己</p><h3 id="video-speed-controller"><a href="#Video-Speed-Controller" class="headerlink" title="Video Speed Controller"></a>Video Speed Controller</h3><p>简介：rt，但是竟然也可以改视频前广告的播放速度！</p><h2 id="哔哩哔哩用户"><a href="#哔哩哔哩用户" class="headerlink" title="哔哩哔哩用户"></a>哔哩哔哩用户</h2><h3 id="pakku哔哩哔哩弹幕过滤器"><a href="#pakku：哔哩哔哩弹幕过滤器" class="headerlink" title="pakku：哔哩哔哩弹幕过滤器"></a>pakku：哔哩哔哩弹幕过滤器</h3><p>简介：简化（过滤）你的 b 站弹幕</p><h3 id="哔哩哔哩助手bilibilicom-综合辅助扩"><a href="#哔哩哔哩助手：bilibili-com-综合辅助扩" class="headerlink" title="哔哩哔哩助手：bilibili.com 综合辅助扩"></a>哔哩哔哩助手：bilibili.com 综合辅助扩</h3><p>简介：功能超多，我主要用来下载 b 站视频了</p><h2 id="steam-用户"><a href="#Steam-用户" class="headerlink" title="Steam 用户"></a>Steam 用户</h2><h3 id="augmented-steam"><a href="#Augmented-Steam" class="headerlink" title="Augmented Steam"></a>Augmented Steam</h3><p>简介：为 steam 官网提供了众多试用的玩意儿</p><h2 id="it-工作者"><a href="#IT-工作者" class="headerlink" title="IT 工作者"></a>IT 工作者</h2><h3 id="octotree-github-code-tree"><a href="#Octotree-GitHub-code-tree" class="headerlink" title="Octotree - GitHub code tree"></a>Octotree - GitHub code tree</h3><p>简介：方便地查看 github 上某个 repository 的文件结构</p><h3 id="surfingkeys"><a href="#Surfingkeys" class="headerlink" title="Surfingkeys"></a>Surfingkeys</h3><p>简介：像 vim 一样的玩意儿，让你完全用你的键盘浏览网页</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 推荐 </tag>
            
            <tag> Edge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次电脑清灰</title>
      <link href="/posts/50b3c006.html"/>
      <url>/posts/50b3c006.html</url>
      
        <content type="html"><![CDATA[<p>电脑是以前的老电脑，初一暑假时候买的y700。配置低的可怜，毫无性价比的一台机子吧，当年还是电脑小白的时候保意买的，在完全不懂的情况下被忽悠着忽悠着买了，满满的坑啊。</p><p>这电脑之前被我拆开来过，为了加一条固态，后盖螺丝因而已经不全了（拆必丢原则!），不过这次没丢!</p><span id="more"></span><p>硅脂买的是7921，网上说好用就买了，竟然还送了一些刷子垫片啥的，应该是很多人都买了清灰用的所以店家就把清灰附属需要的东西也都附赠了，这点还挺不错的。但是实际涂起来吧，这款硅脂是真的令我痛苦——真的很奇妙的质感，比较像容易断的那种橡皮泥(?)，反正结果就很尴尬（我知道我涂多了！没办法）</p><p>弄好装完发现点不亮了!吓了我一跳，结果发现是放那儿好久原来一直没接电源所以没电，接上电就能正常进系统了，太懒了，就没烤一下再看看。</p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed37f.jpg" alt="所用硅脂——信越7921"></p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed388.jpg" alt="商家还送了一些清灰用的玩意儿（这张照片是补拍的）"></p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed394.jpg" alt="清灰前的风扇"></p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed36a.jpg" alt="清灰前的...这叫啥..."></p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6316f2c2beb1fed375.jpg" alt="擦掉旧的硅脂（原来这个方方的才是gpu！）"></p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6816f2c2beb1fed7e1.jpg" alt="尽力清灰后..."></p><p><img src="/img/loading.gif" data-original="https://pic.imgdb.cn/item/6308bb6816f2c2beb1fed7e6.jpg" alt="涂多了...希望不要出事"></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次网络改造</title>
      <link href="/posts/b9a9b40d.html"/>
      <url>/posts/b9a9b40d.html</url>
      
        <content type="html"><![CDATA[<p>事情的起因是跟爸闲聊我抱怨家里为什么没有预埋到我和我妹房间的网线，结果才知道原来是有的，只不过藏在空面板里没有装接口……于是就开始兴致勃勃地想把它装起来(这样我房间里就有有线网了!)，赶紧买了面板，交换机，网线和一众工具。</p><span id="more"></span><p>接网线难在第一个，不过第一个弄会了后面也就快了，此次没有试水晶头的接法，下次有机会试试。</p><p>昨天仅仅是把面板弄完了，交换机今天才到的刚刚也弄上了，现在都做的很方便接上就能用了! 不过在等交换机的时候把家里老的路由器小米WiFi4整了出来，稀里糊涂地捣鼓了半天刷上了个openwrt，这个东西似乎是个linux发行版？! 反正似乎潜力巨大，可以装好多东西，但现在还没太研究，以前想试的adguard home似乎也可以试试去了。</p><p>现在我的房间也终于有千兆网了!</p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWrbPP.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWrTUI.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWroVA.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWr75t.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWr5bd.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWrOxS.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWrL28.jpg"><br><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/28/vWrq8f.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 插件推荐</title>
      <link href="/posts/72a59031.html"/>
      <url>/posts/72a59031.html</url>
      
        <content type="html"><![CDATA[<p>你可能常年使用着国产的一些浏览器，却也常年遭受着各种弹窗、全家桶的侵扰…</p><p>你也可能不止一次地听过”Chrome”，安装下来后却发现他空空如也，又默默地装回那些国产…</p><p>那么，让这些插件来拯救你吧</p><span id="more"></span><blockquote><p>注：文中提到的<code>鹏少</code>、<code>Joker鹏少</code>等均指 B 站 up 主<a href="https://space.bilibili.com/92678046">JOKER 鹏少</a>，版权归其所有。他也是我非常喜欢的一个 up 主，为避免误会，特此声明。介绍中的引用部分为各个插件自己的介绍。</p></blockquote><h2 id="插件安装方法"><a href="#插件安装方法" class="headerlink" title="插件安装方法"></a>插件安装方法</h2><p>问度娘~ 或者在<a href="https://www.bilibili.com/video/av29290563">这里</a>观看视频教程</p><h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><h3 id="tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>The world’s most popular userscript manager</p></blockquote><p>一个脚本管理插件，允许你自己通过编写脚本来实现某种功能，也可以下载脚本使用</p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Chrome 网上应用店</a></p></li></ul><h3 id="谷歌访问助手"><a href="#谷歌访问助手" class="headerlink" title="谷歌访问助手"></a>谷歌访问助手</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>最简单易用的谷歌访问助手,为 chrome 扩展用户量身打造。可以解决 chrome 扩展无法自动更新的问题，同时可以访问谷歌 google 搜索，Gmail 邮箱，google+等谷歌服务。</p></blockquote><p>帮助你访问所有 Google 的页面</p></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vRECiF.jpg" alt="谷歌访问助手"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/gocklaboggjfkolaknpbhddbaopcepfp?hl=zh-CN">Chrome 网上应用店</a></p><p>你也可以去<a href="https://www.jokerps.com/851.html">鹏少资源网</a>下载不用锁定主页的特别版</p></li></ul><h3 id="infinity-新标签页pro"><a href="#Infinity-新标签页-Pro" class="headerlink" title="Infinity 新标签页(Pro)"></a>Infinity 新标签页(Pro)</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>百万用户选择的新标签页和快速拨号，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录。使你的主页和开始页更加美观和易用</p></blockquote><p>在<a href="https://www.bilibili.com/video/av18789095">这里</a>可以观看鹏少更详细的介绍</p></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREmdK.jpg" alt="Infinity新标签页"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh">Chrome 网上应用店</a></p></li></ul><h3 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>本扩展支持百度、搜狗、必应、好搜、谷歌搜索结果的页面结果广告优化和显示内容优化。绕过百度和搜狗的重定向，同时优化主流搜索引擎的搜索结果的样式效果，更方便快速的得到搜索的真实内容，更符合用户习惯。同时支持双列三列甚至四列展示百度谷歌和必应的页面，还自带有护眼模式</p></blockquote></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREeZ6.jpg" alt="安装百度优化插件后的Google主页"></p></li><li><p><strong>下载地址</strong></p><p><a href="%5Bhttps://chrome.google.com/webstore/detail/%E7%99%BE%E5%BA%A6%E4%BC%98%E5%8C%96/denccnggppnbllgifimhkcehbpmlljcp%5D(https://chrome.google.com/webstore/detail/%E7%99%BE%E5%BA%A6%E4%BC%98%E5%8C%96/denccnggppnbllgifimhkcehbpmlljcp)">Chrome 网上应用店</a></p></li></ul><h3 id="划词翻译"><a href="#划词翻译" class="headerlink" title="划词翻译"></a>划词翻译</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>支持谷歌、百度、有道三大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。</p></blockquote><p>同类型的软件很多 但是自己感觉这款最轻量好用</p></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREAMR.jpg" alt="划词翻译界面"></p></li><li><p><strong>下载地址</strong></p><p><a href="%5Bhttps://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad%5D(https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad)">Chrome 网上应用店</a></p></li></ul><h3 id="fireshot"><a href="#FireShot" class="headerlink" title="FireShot"></a>FireShot</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>捕捉网页截图，编辑并将它们保存为 PDF，JPEG，GIF，PNG 或 BMP；上传，打印，在 Photoshop 中打开，复制到剪贴板或电子邮件</p></blockquote><p>在<a href="https://www.bilibili.com/video/av44274712">这里</a>可以观看鹏少更详细的介绍</p></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREiRJ.jpg" alt="一张用FireShot截取的维基百科首页"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg">Chrome 网上应用店</a></p></li></ul><h3 id="stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。</p></blockquote><p>在<a href="https://www.bilibili.com/video/av27145745">这里</a>可以观看鹏少更详细的介绍</p></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREVqx.jpg" alt="使用Stylus中“Baidu Lite 百度轻”后的百度主页"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Chrome 网上应用店</a></p><p><a href="https://add0n.com/stylus.html">官网</a></p></li></ul><h3 id="adblock-plus"><a href="#Adblock-Plus" class="headerlink" title="Adblock Plus"></a>Adblock Plus</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>Adblock Plus 是拥有超过 5 亿次下载的全球最受欢迎的广告拦截软件之一。</p></blockquote></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb">Chrome 网上应用店</a></p></li></ul><h3 id="adguard-广告拦截器"><a href="#AdGuard-广告拦截器" class="headerlink" title="AdGuard 广告拦截器"></a>AdGuard 广告拦截器</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>广告拦截扩展对抗广告和弹出窗口。拦截 Facebook，YouTube 和所有其它网站的广告。</p></blockquote></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg">Chrome 网上应用店</a></p></li></ul><h3 id="clutter-free"><a href="#Clutter-Free" class="headerlink" title="Clutter Free"></a>Clutter Free</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>Reduce tab clutter - prevent duplicate tabs, quickly search &amp; switch tabs, and more…</p></blockquote><p>自动关闭重复打开的标签页</p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/clutter-free-prevent-dupl/iipjdmnoigaobkamfhnojmglcdbnfaaf">Chrome 网上应用店</a></p></li></ul><h3 id="crxmouse-chrometm-手势"><a href="#crxMouse-Chrome™-手势" class="headerlink" title="crxMouse Chrome™ 手势"></a>crxMouse Chrome™ 手势</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>方便,快捷,充分发掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等.</p></blockquote></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREFz9.jpg" alt="crxMouse设置界面"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo">Chrome 网上应用店</a></p><p><a href="https://crxmouse.com/zh-hans/">官网</a></p></li></ul><h3 id="ie-tab"><a href="#IE-Tab" class="headerlink" title="IE Tab"></a>IE Tab</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>在标签页中以 IE 内核显示网页。快捷、强健、可靠。这个版本是最流行的一个原因。</p></blockquote></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd">Chrome 网上应用店</a></p></li></ul><h3 id="imagus"><a href="#Imagus" class="headerlink" title="Imagus"></a>Imagus</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>Enlarge thumbnails, and show images&#x2F;videos from links with a mouse hover.</p></blockquote><p>在<a href="https://www.bilibili.com/video/av44940125">这里</a>可以观看鹏少更详细的介绍</p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab">Chrome 网上应用店</a></p></li></ul><h3 id="lazy-tabs"><a href="#Lazy-Tabs" class="headerlink" title="Lazy Tabs"></a>Lazy Tabs</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>Unload all inactive tabs (except pinned) at startup or by clicking an icon</p></blockquote></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/lazy-tabs/aabgbgciohhaogajcnacpgilhmacdahc">Chrome 网上应用店</a></p></li></ul><h3 id="onetab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>节省高达 95％的内存，并减轻标签页混乱现象</p></blockquote></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREEs1.jpg" alt="将打开的三个标签页全部聚拢"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">Chrome 网上应用店</a></p></li></ul><h3 id="云盘万能钥匙"><a href="#云盘万能钥匙" class="headerlink" title="云盘万能钥匙"></a>云盘万能钥匙</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>您的云盘智能助手</p></blockquote><p>在<a href="https://www.bilibili.com/video/av55835350">这里</a>可以观看鹏少更详细的介绍</p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/%E4%BA%91%E7%9B%98%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99/anlllmnpjodopgbkbpnghnjlelnogfjc">Chrome 网上应用店</a></p><p><a href="https://extension.yunpanjingling.com/">官网</a></p></li></ul><h2 id="适用于-b-站朋友们的插件"><a href="#适用于-B-站朋友们的插件" class="headerlink" title="适用于 B 站朋友们的插件"></a>适用于 B 站朋友们的插件</h2><h3 id="哔哩哔哩助手"><a href="#哔哩哔哩助手" class="headerlink" title="哔哩哔哩助手"></a>哔哩哔哩助手</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>哔哩哔哩弹幕网辅助扩展，拥有视频区和直播区的人性化功能</p></blockquote></li><li><p><strong>截图预览</strong></p><p><img src="/img/loading.gif" data-original="https://s1.ax1x.com/2022/08/26/vREPG4.jpg" alt="bilibili助手设置页面"></p></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A9%E6%89%8B%EF%BC%9Abilibilicom-%E7%BB%BC%E5%90%88%E8%BE%85%E5%8A%A9%E6%89%A9%E5%B1%95/kpbnombpnpcffllnianjibmpadjolanh">Chrome 网上应用店</a></p><p><a href="https://bilibili-helper.github.io/">官网</a></p></li></ul><h3 id="获取哔哩哔哩-bilibili-视频的封面图片"><a href="#获取哔哩哔哩-bilibili-视频的封面图片" class="headerlink" title="获取哔哩哔哩 bilibili 视频的封面图片"></a>获取哔哩哔哩 bilibili 视频的封面图片</h3><ul><li><p><strong>介绍</strong></p><blockquote><p>获取哔哩哔哩 bilibili 视频的封面图片</p></blockquote></li><li><p><strong>下载地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/%E8%8E%B7%E5%8F%96%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9bilibili%E8%A7%86%E9%A2%91%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87/egodkcidolldembjebmiepoibpahmllh">Chrome 网上应用店</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
