{"posts":[{"title":"记一次网络改造","text":"事情的起因是跟爸闲聊我抱怨家里为什么没有预埋到我和我妹房间的网线，结果才知道原来是有的，只不过藏在空面板里没有装接口……于是就开始兴致勃勃地想把它装起来(这样我房间里就有有线网了!)，赶紧买了面板，交换机，网线和一众工具。 接网线难在第一个，不过第一个弄会了后面也就快了，此次没有试水晶头的接法，下次有机会试试。 昨天仅仅是把面板弄完了，交换机今天才到的刚刚也弄上了，现在都做的很方便接上就能用了! 不过在等交换机的时候把家里老的路由器小米WiFi4整了出来，稀里糊涂地捣鼓了半天刷上了个openwrt，这个东西似乎是个linux发行版？! 反正似乎潜力巨大，可以装好多东西，但现在还没太研究，以前想试的adguard home似乎也可以试试去了。 现在我的房间也终于有千兆网了!","link":"/posts/b9a9b40d.html"},{"title":"记一次电脑清灰","text":"电脑是以前的老电脑，初一暑假时候买的y700。配置低的可怜，毫无性价比的一台机子吧，当年还是电脑小白的时候保意买的，在完全不懂的情况下被忽悠着忽悠着买了，满满的坑啊。 这电脑之前被我拆开来过，为了加一条固态，后盖螺丝因而已经不全了（拆必丢原则!），不过这次没丢! 硅脂买的是7921，网上说好用就买了，竟然还送了一些刷子垫片啥的，应该是很多人都买了清灰用的所以店家就把清灰附属需要的东西也都附赠了，这点还挺不错的。但是实际涂起来吧，这款硅脂是真的令我痛苦——真的很奇妙的质感，比较像容易断的那种橡皮泥(?)，反正结果就很尴尬（我知道我涂多了！没办法） 弄好装完发现点不亮了!吓了我一跳，结果发现是放那儿好久原来一直没接电源所以没电，接上电就能正常进系统了，太懒了，就没烤一下再看看。","link":"/posts/50b3c006.html"},{"title":"Edge 扩展推荐","text":"2019年7月写过一篇Chrome插件推荐的文章，那时候我还在用Chrome作为我的主要浏览器。一晃三年过去了，我也早已从Google Chrome转入全新Chromium内核构建的Edge浏览器。微软倒蛮有意思，自己从头开发的东西不咋地，在别人的平台上倒是表现得相当好。由于国内的水土不服啊，我用Chrome时总会遇到同步不了的情况，这点的体验在Edge这儿得到了很好的改善，也是我用Edge的主要原因吧。前些天帮很多同学做新机开荒，也推荐他们就用这款“Win11原装”浏览器。当然一个浏览器肯定是离不开扩展的，趁着帮他们开荒这个机会，也顺便整理了我认为必备的一些浏览器扩展。 本文更多的从个人角度出发，仅涵盖了笔者的主要需求，自然是粗略的，仅供参考。 全部用户Dark Reader简介：强制暗黑模式的网页 Infinity 新标签页 (Pro)简介：rt，一个新标签页扩展 OneTab简介： 打开了太多网页的时候，按一下可以帮你全部收起来，之后可以自由恢复 Prevent Duplicate Tabs简介： 帮你干掉那些重复的标签页 uBlock Origin简介：干掉广告，且是众多去广告插件中占用相对较少的 捕捉网页截图 - FireShot的简介：rt，支持长截图（名字有点怪，可能是翻译问题，搜索FireShot就能找到） 暴力猴简介：装脚本的插件，和大名鼎鼎的油猴一样的功能，这个可能(?)小巧一点 沙拉查词-聚合词典划词翻译简介：rt，划词翻译，可配置内容超多 Imagus简介：可以把网页图片放大了看 User-Agent Switcher for Chrome简介：“伪装”你自己 Video Speed Controller简介：rt，但是竟然也可以改视频前广告的播放速度！ 哔哩哔哩用户pakku：哔哩哔哩弹幕过滤器简介：简化（过滤）你的b站弹幕 哔哩哔哩助手：bilibili.com 综合辅助扩简介：功能超多，我主要用来下载b站视频了 Steam用户Augmented Steam简介：为steam官网提供了众多试用的玩意儿 IT工作者Octotree - GitHub code tree简介：方便地查看github上某个repository的文件结构 Surfingkeys简介：像vim一样的玩意儿，让你完全用你的键盘浏览网页","link":"/posts/3c91f84e.html"},{"title":"Chrome 插件推荐","text":"注：文中提到的鹏少、Joker鹏少等均指B站up主JOKER鹏少，版权归其所有。他也是我非常喜欢的一个up主，为避免误会，特此声明。介绍中的引用部分为各个插件自己的介绍。 引言你可能常年使用着国产的一些浏览器，却也常年遭受着各种弹窗、全家桶的侵扰… 你也可能不止一次地听过”Chrome”，安装下来后却发现他空空如也，又默默地装回那些国产… 那么，让这些插件来拯救你吧 插件安装方法问度娘~ 或者在这里观看视频教程 必备插件Tampermonkey 介绍 The world’s most popular userscript manager 一个脚本管理插件，允许你自己通过编写脚本来实现某种功能，也可以下载脚本使用 下载地址 Chrome网上应用店 谷歌访问助手 介绍 最简单易用的谷歌访问助手,为chrome扩展用户量身打造。可以解决chrome扩展无法自动更新的问题，同时可以访问谷歌google搜索，Gmail邮箱，google+等谷歌服务。 帮助你访问所有Google的页面 截图预览 下载地址 Chrome网上应用店 你也可以去鹏少资源网下载不用锁定主页的特别版 Infinity 新标签页(Pro) 介绍 百万用户选择的新标签页和快速拨号，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录。使你的主页和开始页更加美观和易用 在这里可以观看鹏少更详细的介绍 截图预览 下载地址 Chrome网上应用店 百度优化 介绍 本扩展支持百度、搜狗、必应、好搜、谷歌搜索结果的页面结果广告优化和显示内容优化。绕过百度和搜狗的重定向，同时优化主流搜索引擎的搜索结果的样式效果，更方便快速的得到搜索的真实内容，更符合用户习惯。同时支持双列三列甚至四列展示百度谷歌和必应的页面，还自带有护眼模式 截图预览 下载地址 Chrome网上应用店 划词翻译 介绍 支持谷歌、百度、有道三大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。 同类型的软件很多 但是自己感觉这款最轻量好用 截图预览 下载地址 Chrome网上应用店 FireShot 介绍 捕捉网页截图，编辑并将它们保存为PDF，JPEG，GIF，PNG或BMP；上传，打印，在Photoshop中打开，复制到剪贴板或电子邮件 在这里可以观看鹏少更详细的介绍 截图预览 下载地址 Chrome网上应用店 Stylus 介绍 Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。 在这里可以观看鹏少更详细的介绍 截图预览 下载地址 Chrome网上应用店 官网 Adblock Plus 介绍 Adblock Plus 是拥有超过 5 亿次下载的全球最受欢迎的广告拦截软件之一。 下载地址 Chrome网上应用店 AdGuard 广告拦截器 介绍 广告拦截扩展对抗广告和弹出窗口。拦截 Facebook，YouTube 和所有其它网站的广告。 下载地址 Chrome网上应用店 Clutter Free 介绍 Reduce tab clutter - prevent duplicate tabs, quickly search &amp; switch tabs, and more… 自动关闭重复打开的标签页 下载地址 Chrome网上应用店 crxMouse Chrome™ 手势 介绍 方便,快捷,充分发掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等. 截图预览 下载地址 Chrome网上应用店 官网 IE Tab 介绍 在标签页中以IE内核显示网页。快捷、强健、可靠。这个版本是最流行的一个原因。 下载地址 Chrome网上应用店 Imagus 介绍 Enlarge thumbnails, and show images/videos from links with a mouse hover. 在这里可以观看鹏少更详细的介绍 下载地址 Chrome网上应用店 Lazy Tabs 介绍 Unload all inactive tabs (except pinned) at startup or by clicking an icon 下载地址 Chrome网上应用店 OneTab 介绍 节省高达95％的内存，并减轻标签页混乱现象 截图预览 下载地址 Chrome网上应用店 云盘万能钥匙 介绍 您的云盘智能助手 在这里可以观看鹏少更详细的介绍 下载地址 Chrome网上应用店 官网 适用于B站朋友们的插件哔哩哔哩助手 介绍 哔哩哔哩弹幕网辅助扩展，拥有视频区和直播区的人性化功能 截图预览 下载地址 Chrome网上应用店 官网 获取哔哩哔哩bilibili视频的封面图片 介绍 获取哔哩哔哩bilibili视频的封面图片 下载地址 Chrome网上应用店","link":"/posts/72a59031.html"},{"title":"补记一个用 Vue.js 和 ElementUI 实现的在线抽奖网页","text":"这件事儿发生在我的高中某个新学期开始，新来了一个电脑老师。有点打赌或者考验我的性质吧，ta说ta弄了随机数点名的小网页，还能用同学的照片进行抽取，问我能不能实现一个。ta的实现方法是jQuery，技术上比较老，界面也不太好看。我想去尝试一下别的方法，正好也试试略微学了一点的Vue.js，为了好看，用了Element UI。 一两个周末最终实现到现在的效果，能输入名字抽人，能随机数抽人（学号抽人？），还有一个通过图片抽的到今天也还没做。当时对着Vue.js和Element UI的开发文档勉里勉强做出来这个效果，现在早把那些基础知识忘记了，也不知道以后有没有工夫完善它了。 你可以点击这里来玩玩看。","link":"/posts/6a8a1633.html"},{"title":"【已解决】Hexo 使用 Icarus 主题安装 abbrlink 插件后 toc 插件生成的目录存在错误无法跳转的问题","text":"问题再现配置Heox博客，为了优化seo，安装了abbrlink插件。但突然发现原来可以正常使用的Icarus主题自带的toc目录侧边栏无法正常跳转。查看源代码发现&lt;a&gt;标签的href属性均显示为&quot;#&quot;而非正确地址，遂前往寻找解决方案。 问题解决来源：hexo文章目录点击不跳转，html没有生成href_宁理大神1996的博客-CSDN博客 修改(你的Blog目录)/node_modules/hexo-toc/lib/filter.js中的29~31行 由原来的这样 1234//$title.attr('id', id);$title.children('a').remove();$title.html( '&lt;span id=&quot;' + id + '&quot;&gt;' + $title.html() + '&lt;/span&gt;' );$title.removeAttr('id'); 改为这样 1234$title.attr('id', id);// $title.children('a').remove();// $title.html( '&lt;span id=&quot;' + id + '&quot;&gt;' + $title.html() + '&lt;/span&gt;' );// $title.removeAttr('id');","link":"/posts/a55922c1.html"},{"title":"RLCraft 新手教程一：过渡到你的正常生存","text":"本教程是笔者自己游玩过程中写的，出发点是笔者自己想玩但又不想花费时间看很多实况去了解一些细节，又找不到比较详细的文字版中文教程，以致于无从下手，只能慢慢啃各种模组的百科和RLCraft Wiki，便以教程形式写下自己的游玩过程，希望对后来者有所帮助。笔者不是什么资深玩家，故难免有疏漏，请大家多多包涵。 由于NTP模组（No Tree Punching，无树可撸）的存在，初入RLCraft，你的第一件事情不再是获取原木，而是撸树叶获取木棍，然后找到沙砾获取燧石。你可以按住鼠标左键徒手破坏树叶和沙砾，然后用右键点击掉落物以拿起它（或者你也可以按下shift来吸取附近的掉落物）。 手拿燧石右击石头/圆石等坚硬方块（?）上表面，你可以获取燧石碎块，然后打开背包，在2*2的合成栏上边放燧石碎块，下边放木棍，获取一把粗糙的小刀。 使用粗糙的小刀破坏草，可以获得植物纤维，在背包合成栏用三个植物纤维合成一个植物绳。然后再使用燧石碎块、植物绳、木棍合成粗糙的斧头。恭喜你获取了这个游戏的第一把斧头，用这把斧头你就可以开采原木了——当心，树倒下来可能会砸死你！ 你不再能够直接使用背包合成栏分解原木，而是需要把原木竖直放在地上，并用斧头右击其上表面，以获取两块木板。木棍也可以用类似的方式获取——将木板放在地上，然后用斧头右击。 你可以看jei获取更多燧石工具的制作方法，但你更可以开始制作原版的木制工具。用木镐挖石头会掉落石子，四个石子2*2摆放可以获取圆石，而挖圆石则会直接掉落圆石。 恭喜你进入石器时代！现在，你可以开始下矿了！但要时刻注意的一点是照明——恐怖生物会在黑暗中生成… 别自己怎么死的都不知道。你会发现木棍加煤炭不再能合成原版火把，它们现在只能合成熄灭的火把。要点亮它们，你需要的是一颗打火石——将熄灭的火把和打火石放在合成栏里，你就可以获得点燃的火把。但这火把仍然会熄灭——比如一场雨过后，比如燃烧很久之后… 虽然还有很多路要走，但你现在基本上可以短暂地享受一回类原版的MC了。 To be continue…","link":"/posts/a1ada34d.html"},{"title":"Hexo 在 Icarus 主题下更改字体","text":"起因在使用Hexo搭建博客的过程中，笔者发现使用hexo s创建的localhost:4000显示的网页上的字体效果与hexo d到github上的网页字体效果不同。遂想统一两者字体，希望通过换字体的方式达到该目的。 选择字体英文笔者选择的是JetBrains Mono，中文笔者选择的是Source Han Sans CN VF Blod(思源黑体)。需要注意的是我们不仅要找到某个自己喜欢的字体，还需要找到字体对应的英文名。本文以这两个开源字体为例。 过程icarus的字体设置位于&lt;Blog_path&gt;\\node_modules\\hexo-theme-icarus\\include\\style下的base.styl中。第9~10行，原来为： 12$family-sans-serif ?= Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif$family-code ?= 'Source Code Pro', monospace, 'Microsoft YaHei' 现改为（将所需字体添加在最前面）: 12$family-sans-serif ?= 'JetBrains Mono', 'Source Han Sans CN VF Blod', Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif$family-code ?= 'JetBrains Mono', 'Source Han Sans CN VF Blod', 'Source Code Pro', monospace, 'Microsoft YaHei' 后记起因中的问题莫名其妙消失了… 于是笔者改回了原来的样子。","link":"/posts/2527d7a7.html"},{"title":"Hexo 插件 hexo-admonition 在 Icarus 主题下的使用与测试","text":"Hexo 博客中的文章是使用 Markdown 来渲染的。虽然原版 Markdown 已经提供了很多样式，但笔者仍觉得有些不够。在翻 Hexo 的官方插件列表时，笔者找到了 hexo-admonition 这个插件来为博文添加更多样式。 插件官方说明https://github.com/lxl80/hexo-admonition/blob/master/README.md 安装首先使用npm安装该插件。 1npm install hexo-admonition --save 接着更改你的hexo主题的css。我使用的icarus主题，所以在&lt;blog_path&gt;\\node_modules\\hexo-theme-icarus\\include\\style下的article.styl结尾添加了如下内容（因为是.styl而非.css，所以对官方提供的内容使用这个工具进行了转换）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// hexo-admonition.admonition margin 1.5625em 0 padding .6rem overflow hidden font-size .64rem page-break-inside avoid border-left .3rem solid #42b983 border-radius .3rem box-shadow 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1) background-color #fafafa &amp; &gt; :last-child margin-bottom 0 !importantp &amp;.admonition-title position relative margin -.6rem -.6rem .8em -.6rem !important padding .4rem .6rem .4rem 2.5rem font-weight 700 background-color rgba(66, 185, 131, .1).admonition-title &amp;::before position absolute top .9rem left 1rem width 12px height 12px background-color #42b983 border-radius 50% content ' '.info&gt;.admonition-title, .todo&gt;.admonition-title background-color rgba(0,184,212,.1).warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title background-color rgba(255,145,0,.1).failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title background-color rgba(255,82,82,.1).admonition.info, .admonition.todo border-color #00b8d4.admonition.warning, .admonition.attention, .admonition.caution border-color #ff9100.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error border-color #ff5252.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before background-color #00b8d4 border-radius 50%.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before background-color #ff9100 border-radius 50%.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before background-color #ff5252 border-radius 50% 后自己微调将第24行由 1top .9rem 改为 1top 0.6rem 语法说明123!!! &lt;type&gt; &lt;title&gt;(四个空格)(**空行结束标记**) type支持： note info, todo warning, attention, caution error, failure, missing, fail “活学活用” 当&lt;title&gt;未设置时，将会以&lt;type&gt;作为标题 如果要设置空标题，应当使用&quot;&quot; 这非常重要！ 空行结束标记不能少！ 测试这是一条note 这是一条info 这是一条todo 这是一条warning 这是一条attention 这是一条caution 这是一条error 这是一条failure 这是一条missing 这是一条fail 2022年9月10日更新： 发现原来 Icarus 主题本身已经提供了类似功能：自定义Hexo标签插件","link":"/posts/f81be6d0.html"},{"title":"Hexo 使用 Bulma 美化文章","text":"虽然笔者已经在博客上安装了 hexo-admonition 插件来一定程度上对主体为 Markdown 的文章进行一定样式上的补充，但该插件所能提供的内容确实有限。如果能使用原生的 Html 和 CSS 技术自定义文章某些内容就好了。 搜索资料时看到了这两篇文章： 活用 Bulma 美化 Icarus 文章 Hexo和Icarus折腾 现做一些学习笔记。 在 Markdown 文件中插入 Html 和 CSS 内容使用下面的 raw 标签: 123{% raw %}//在这里添加一些内容不希望被渲染的内容{% endraw %} 可以让我们在 Markdown 文档中添加 Html 内容，例如： 12345{% raw %}&lt;div class=&quot;notification is-info&quot;&gt;这是一段 info&lt;/div&gt;{% endraw %} 显示为 这是一段 info 而通过 &lt;style type=&quot;text/css&quot;&gt; 和 &lt;/style&gt; 标记，我们又可以在 Html 内容中直接添加 CSS 内容。 用 Bulma 实现的一些常见的玩意儿直接看 《活用 Bulma 美化 Icarus 文章》这篇文章吧 在 VS Code 中预览 Bulma 内容首先在 VS Code 中按下 Ctrl + Shift + X 打开扩展页面。安装 Markdown Preview Enhanced。重启你的 VS Code，然后使用 Ctrl + K、V 打开侧边预览。(具体见该插件的官方中文文档) 接着添加 Bulma 的CSS：按下 Ctrl + Shift + P，输入 Markdown Preview Enhanced: Customize CSS，回车。笔者直接使用 @import 进行引入。 所以只要在上面命令打开的 style.less 开头添加: 1@import &quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css&quot;; 按下 Ctrl + Shift + P，输入 Markdown Preview Enhanced: Extend Parser，回车。编辑 onWillParseMarkdown。在下边的这是一个标记处： 123456onWillParseMarkdown: function(markdown) { return new Promise((resolve, reject)=&gt; { //这是一个标记 return resolve(markdown) }) } 添加： 12345678markdown = markdown.replace( /\\{% raw %}/g, (whole) =&gt; (``))markdown = markdown.replace( /\\{% endraw %}/g, (whole) =&gt; (``)) 现在它看起来应该是这样： 12345678910111213onWillParseMarkdown: function (markdown) { return new Promise((resolve, reject) =&gt; { markdown = markdown.replace( /\\{% raw %}/g, (whole) =&gt; (``) ) markdown = markdown.replace( /\\{% endraw %}/g, (whole) =&gt; (``) ) return resolve(markdown) }) } 上面的方法存在的问题以及也许可行的解决方案(暂未实际解决)Markdown Preview Enhanced 替换的时候会将所有的 raw 标签全部替换掉，以至于在渲染源代码部分时，会出现一些错误。但这些错误仅在本地的 VS Code 渲染时发生，在网页上是没有问题的。但还是… 让强迫症很难受。 现在的需求是，如果 raw 标签位于代码块中，那么渲染时它无需被删除，否则应该被删除。 笔者的思路是：检测 raw 标签的上下文，如果上文包含了标记为 Html/js 的代码块起始标记，下文包含了代码块结束标记，则不进行替换；反之进行替换。 暂未实际实现。","link":"/posts/14706354.html"},{"title":"Blender 自学日记（一）：界面与基础操作","text":"该系列是笔者在自学 Blender 的过程中所作的笔记。课程来源是 doyoudo。这篇笔记是第一课的学习内容。 00:08:45 Blender自学日记，新手系统案例课！第一集 4.4万 84 视频 doyoudo 基础操作按住 ~ 同时鼠标选择：快捷切换视图 Ctrl + Alt + Q：切换四视图显示 鼠标中键：旋转视图 Shift + 鼠标中键：移动视图 右侧网格按钮：切换为 2.5D 创作视图 X：删除元素 Shift + A：新建元素 N：调出常用属性 锁定摄像机：进入摄像机后可以直接调整视图 G：移动物体 R：旋转物体 S：放大缩小 G/S + X/Y/Z：按照轴向去移动/放缩 鼠标右键：取消刚才的这些操作","link":"/posts/5aa9eb29.html"},{"title":"Hexo 插件 hexo-bilibili-card 的使用与修改","text":"使用 Hexo 写博文时，可能需要插入一个视频卡片。我使用的 Icarus 主题提供了 Youtube 的视频卡片，而我更需要的是 Bilibili 的。于是找到了这个插件—— hexo-bilibili-card 。 安装1npm install hexo-bilibili-card --save 使用在你的 Markdown 文档中添加： 1{% bilicard av/BV %} 修改2022/10/26 更新：插件更新了，以下内容行数不对了，作废。 使用过程中，我对其本身的样式不太满意，便对其 CSS 进行了一定程度的修改。 打开 &lt;Blog_path&gt;\\node_modules\\hexo-bilibili-card\\source\\bilicard.css 注释掉第 90 行： 1margin-top: 1px; 注释掉第 121 行： 1top: 78px; 修改第 119 行为： 1bottom: 2px; 修改第 141~142 行为： 12width: 30px;height: 15px;","link":"/posts/bb53ea7f.html"},{"title":"手动挡学习笔记","text":"最近几天一直在忙着考驾照的事情，8月份第一次考科二挂了后就开始边练科二边练科三。最近两三天先后把科三、第二次科二、科四过了，顺利拿到了C1驾照。但是…学的是手动挡，家里的车却是自动挡。所以想着如果不记一下的话，以后估计开惯了自动挡手动挡就不会了，便想做些笔记。顺便也记录一下笔者自己的学车过程。 相关做法仅供参考，有些内容可能也只适用于笔者这边的考试。如有错误敬请各位大佬指出。 科目一就是刷题嘛。笔者本人是把2000道题的题库先完整了一遍，然后又模拟了20+次，所以相当于做了4000多道题吧，结果是98一把过的。笔者一直很担心自己过不了那些扣分/罚款题，甚至为此还自己做了个表格把扣分项全部列在了里边。结果实际上并没有用上多少就是了，因为实际考试根本没有那么多难题。可能自己用的软件为了让你冲VIP所以不冲的话给的题目就会比较难吧。笔者也认识一个刷了600道直接过的，还有一个当天下午考结果上午中午刷了1200道直接过的。可能考试的时候抽题目也有点运气成分，和笔者一起去的朋友第二把的难度显然低于第一把，所以第一把80多但第二把就100了。 科目二科二始终是一档就行了，油门也是锁死的，所以只要看离合与刹车两个踏板。核心要点：速度慢一点。 开始前准备 系好安全带 调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜 调整内外后视镜。左后视镜下边缘差不多与后车轮下边缘重合为宜，右后视镜车身差不多占1/3，然后地平线位于上下1/2左右。（具体不记得了，笔者自己也有点弄不明白这里，请大佬指点） 倒车入库笔者第一次科二两把都挂在这儿了，都是“倒库不入”。正确的操作如下： 首先鼻子正对从右往左数第三条虚线左边缘开，直到开到虚线与肩膀对齐。 挂倒挡，看左后视镜下边缘，差不多与虚线前边缘对齐或间隔几厘米的时候（因人而异），向左打死方向盘。 往后倒的同时观察左后视镜，三条虚线压住两条半了看车身与库边缘的距离，如果较大（30cm以上？），则保持打死状态继续倒，否则回半圈继续倒。 主要通过右后视镜观察车身是否正。这时候需要自己微调，反正就车屁股要往左就方向盘往左打，车屁股要往右就往右打。 车身正了，端平方向盘，看左后视镜，差不多等到左后视镜完全压住黄线了，停车。 挂前进档，起步。观察左后视镜看到左后轮压到前库线了，向右打死方向盘。车身正，回半圈方向盘继续开直到左侧车门框压到黄虚线。 挂倒挡，起步。待左后视镜对齐黄线了向右打半圈并开始观察右后视镜。看三条虚线类似上边第3、4点进行调整。 完全停好，挂前进档，起步。同样观察左后视镜看到左后轮压到前库线了（或者这里也可以稍微提前一点），向左打死。车身正回正。前轮过黄虚线后轮不过。结束倒车入库。 倒车入库的时间要求是：210s（3.5min） 坡道定点停车与起步 上坡前离合要稍微踩下边一点，鼻子对准从右往左数第二第三条虚线中间开（保证左右间距）。开到差不多坡顶前，看前车窗右侧商标距离杆子还有2cm左右时踩离合与刹车停车。 拉手刹，等3s，松手刹。 踩住刹车，很缓慢地松离合直到车身抖动或发动机转速表指针往下掉了一下，方向盘稍微往左打一点防止待会压右侧线。松刹车起步。 坡道定点停车与起步无时间要求。 直角转弯 进入右直角转弯区域前需要先左转，所以先向左打死，然后提前做准备打好右转灯。 进入区域，车身正方向盘回正。等到右边门把手右端点位于黄线前1~2cm时往右打死。 车身正回正，稍微开两步继续向左打死。（右直角转弯只评判右直角，所以这里左转压线也没事） 直角转弯无时间要求。 曲线行驶 往前看并伸长脖子看引擎盖左边一个凹下出，当凹下处压线后向左打一圈，方向盘微调使凹下处沿着曲线右边线走。 保持左一圈的动作直到上述凹下处压到曲线左边界，回正，往前开。 看到雨刮器铆钉旁凹下处右侧2~3cm处与曲线左边界重合后，往右打一圈。然后往前开直到驶出曲线行驶路段。 曲线行驶无时间要求。 侧方停车 首先调整边缘线与车身差不多30cm左右的位置。然后保持车身与右边缘线这个间距平行，注意观察右后视镜，直到右后视镜中出现一个直角（侧方的库的边缘角）。 挂倒挡，后退直到直角消失迅速向右打死。 往后的同时低头观察左后视镜，看到两条虚线方向盘迅速回正。然后伸长脖子注意左后轮，压到黄虚线位置后迅速往左打死。 观察右后视镜，到车身平行入库时踩离合刹车停车。 保持左打死状态，打左转向灯，换前进档。引擎盖左侧凹下处压左边线后迅速回正。引擎盖一半压黄线时向右打一圈，车身正回正，侧方停车完成。 侧方停车的时间要求是：从挂倒挡起90s内完成。 科目三起步前准备 系好安全带 调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜 调整内外后视镜 起步停车时应处于空挡、手刹拉好的状态。想要起步，首先应该踩死离合与刹车。打开左转向灯，等3秒后，观察后方情况。确认安全后挂一档，松手刹，松刹车，缓松离合。等待4s左右完全放掉离合（考试要求6s内），踩油门加速。 换挡首先是各挡位的速度对应： 速度 挡位 10码以下 一档 10~20码 二档 20~35码 三档 35~40码 四档 40码以上 五档 换档前，首先踩油门到挡位速度的分界线。然后松油门，踩死离合，换挡，松离合，完成换挡操作。考试要求换挡在6s内完成。 加档必须一档一档加上（比如停车时空挡再起步就只能从一档开始加上去），减档可以跳着减（只要速度挡位匹配）。 变更车道与超车先打转向灯，等待3s后观察后方情况，然后转方向盘进入另一车道。 十字路口的转向右转看地上标线，一般是有三个右转向的箭头。从近及远，第一个之前或差不多那时候打右转向灯，第二个的地方减档，紧接着是点踩刹车和左右摇头观察情况。（考试时常规要保持三档20码左右的速度，所以这里减档就是到二档）。彻底完成转向后加速回到三档。右转即走右车道，但要注意不要开到非机动车道上去。 左转类似右转，不过是“左转左车道”。 掉头我考试的情况是左右两车道，并且靠侧边的是非机动车道。所以掉头时要先借右侧辅道。 首先打右转向灯，然后减二档，等待3s观察右后方情况，确认安全后进入右侧辅道。接着关闭右转灯，打左转灯，等待3s观察左前方和左后方的情况，确认安全后往左打死。这中间可以稍微踩点刹车放慢点速度。 靠边停车首先右转向灯，打一档，等3s后观察右后方情况。确认安全后进入右边车道停车。 减速与停车减速就是踩刹车； 停车要离合刹车一起踩并且离合要踩得更快更早一点点。车停后记得挂空挡。 考试过程中，除了人行横道，其余地方都可以停车。所以善用它！ 点踩刹车与左右摇头观察这点实际开车应该都没人做吧，完全是应付考试了。需要在路口转弯、靠近人行横道、公交车站的地方做这个动作。 注意点主要是：点踩刹车不用踩太下，碰一下刹车立马抬起就行了。两次点踩刹车不要太连续，不然容易掉档。摇头的时候，幅度要大一点。 夜间灯光考试近光灯 夜间同方向近距离跟车行驶 夜间在窄桥/窄路上与非机动车会车 夜间直行通过路口 夜间在照明良好的道路上行驶 远光灯 夜间在没有路灯、照明不良的道路上行驶 远近灯光交替 夜间通过急弯/坡路/拱桥 夜间通过没有交通信号灯的路口 夜间超越前方车辆 示宽灯+双闪 路边临时停车 夜间在路口发生交通事故，妨碍交通难以移动 科目四刷了300道不到去了，大部分都是常识，相对比较好过。 附：笔者教练讲的完整流程及注意点科二 【侧方停车】(1)先调整好边缘线30公分左右，再看向右面大反光镜直角出来就停车。(2)开始挂倒挡，倒车看后右反光镜看不见直角。就向右把方向打死。(3)再看左反光镜里后面露出两条虚线把方向回正。(4)然后在看左后轮压虚线向左打死。(5)最后再看大镜车身平行刚进虚线就停。【2】出侧方位，打左转向灯。挂前进挡出库看前面左车头凹巢面挡外框黄线把方向回正。继续向前左车头当一半外面黄线时向右打一圈车身正把它回正。侧方位结束。【3】侧方位规定在挂倒挡开始90秒之内完成。【倒车入库】先看从右边数第三条虚线停在我们车中间与肩膀平行，倒车入库开始两百十秒钟完成。看左反光镜下檐 余肩膀线从合同时 向左打死方向，再看左反光镜库里面第三条虚线挡住一半时把方向回半圈。再看右面反光镜与库线平行，把方向右回正。在看左前反光镜下檐 于库角线刚从合停车。挂前档向右时看两反光镜调整出库大小。左后轮到库角向右打死，车头正回半圈。一直到肩膀停车，挂倒档看左镜子下檐于肩膀线从合向右打半圈打死。右面大反光镜库第三条虚线时一半把方向回半圈。就是等车上与地上黄线平行。把方向全部回正。就等停车看前面左反光镜檐于 库角线停车，出库调整大小左后面库角向左打死。车身正回正前轮到肩膀线。 科三 1.继续完成考试。先打左转向灯。向左回头观望。确保安全后。踩离合。挂一挡。松手刹。又手推到一点钟的位置。右脚放油门。左脚慢慢抬起离合。车子开始走动一般数四秒。把离合器全部松掉。 (记住 左脚必须在六秒钟之内。完全离合器踏板。超过六秒扣100分，行车过程中。加减档 也必须在。六秒钟内完成)，从松手下到起步 必须十秒钟内起步走哦 2.行车过程中。加速加档。10码以上加二档20码以上加三档35码以上加四档。加档只能一个一个档往上加。不能跳跃加档，减档可以速度与档位匹配时可以越档位减档。3.还有会车动作，准备会车稍微向左一点。不要压中心线。听到电脑语音指定。与机动车会车。向右靠。沿着右边线点行驶。小心右边压线。3到4秒后，电脑语音指定。结束回车。你靠中心随便行驶。会车结束以后。直接踩油门踩35码以上加四档。四挡加上去离合器放掉5秒过后，踩离合直接推三档，四档就完成了。4.超越前方车辆。电脑发出指定，你打左转向灯。向前方数三秒后，向左回头观望。头必须左后90度以上观望。确认安全后，方向稍微向左。行驶到另一个车道。等车辆完全进入另一个车道后，关闭左转向灯。车身直驶回原车道。你打开右转向灯。向前方数三秒后向右回头观望。头必须90度以上。方向稍微向右使上另一个车道，完全进入另一个车道后把转向灯关掉。5.直线行驶。一般的我教听到指令控制好方向油门踩上去。达到40km以上中间会听到我的敲门声松掉油门。。让它自由滑行。方向微调。记住必须直线行驶100米以后。会听到结束直线行驶。滑行自由行驶了，6.遇到路口一般减速减档轻点刹车左右观望。人行横道，公交车站台轻点刹车，左右观望通过。停车放空挡。7.听到适当路口掉头时，借右侧辅道先打右转向灯。减二档。三秒以后回头观望。向右进入辅道记住小心右面压边线。完全进入辅道后启左转向灯，三秒以后。向左回头观望。一把快打死掉头。8.进入对方车道路后，准备停车。打好右转向灯，记住一定要等好电脑指令。请靠边停车。可以换一挡数三秒。右回头观望后往右向右靠。注意停不进去随时随地都可以停车放空挡等， 看前小反光镜与边线30公分以内。踩离合踩刹车。放空挡拉手刹。等电脑成绩合格。才可下车。","link":"/posts/66959aa9.html"},{"title":"Hexo 在 Icarus 主题下渲染数学公式","text":"这个问题的起因是笔者写数学课笔记的时候发现本地使用 Typora 时正常可以渲染的数学公式无法在我的博客上显示。在查找资料的过程中发现 Hexo 默认渲染器不支持 LaTeX。正当我想着是否要换渲染器时，才发现我使用的 Icarus 主题只要稍微设置一下就可以渲染了。 官方文档地址：http://ppoffice.github.io/hexo-theme-icarus/Plugins/Other/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6/#MathJax 打开 _config.icarus.yml 文件，找到下面这行： 1mathjax: false 修改 mathjax 的值为 true，即变成这样： 1mathjax: true 然后在需要渲染数学公式的文档开头添加： 1mathjax: true 待解决的问题： 似乎这样的字符并不全，比如 \\Alpha 在网站上被渲染成下面那样，而非 正确的Α","link":"/posts/e201bde3.html"},{"title":"LaTeX 公式基础","text":"用 LaTeX 写数学公式的时候，总记不住一些写法，故在此记录学习笔记。 常见符号希腊字母大小写希腊字母的写法区别就在于 LaTeX 符号的首字母大小写。 若要使用斜体只要在前面加上 var 前缀，例如 \\varGamma 可以用来显示 $\\varGamma$ 。 大写字母 LaTeX 写法 小写字母 LaTeX 写法 $\\Alpha$ \\Alpha $\\alpha$ \\alpha $\\Beta$ \\Beta $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\Epsilon$ \\Epsilon $\\epsilon$ \\epsilon $\\Zeta$ \\Zeta $\\zeta$ \\zeta $\\Eta$ \\Eta $\\eta$ \\eta $\\Theta$ \\Theta $\\theta$ \\theta $\\Iota$ \\Iota $\\iota$ \\iota $\\Kappa$ \\Kappa $\\kappa$ \\kappa $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\Mu$ \\Mu $\\mu$ \\mu $\\Nu$ \\Nu $\\nu$ \\nu $\\Xi$ \\Xi $\\xi$ \\xi $\\Omicron$ \\Omicron $\\omicron$ \\omicron $\\Pi$ \\Pi $\\pi$ \\pi $\\Rho$ \\Rho $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Tau$ \\Tau $\\tau$ \\tau $\\Upsilon$ \\Upsilon $\\upsilon$ \\upsilon $\\Phi$ \\Phi $\\phi$ \\phi $\\Chi$ \\Chi $\\chi$ \\chi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega 运算符 渲染结果 LaTeX 写法 记法 $\\pm$ \\pm 英文：Plus + Minus $\\mp$ \\mp 英文：Minus + Plus $\\times$ \\times times 就有“乘”的意思 $\\div$ \\div $6 \\div 3=2$ 表述为：Six divided by two is three. $\\geq$ \\geq “大于等于”的英文：greater than or equal to $\\leq$ \\leq “小于等于”的英文：less than or equal to $\\neq$ \\neq “不等于”的英文：not equal to $\\approx$ \\approx “约等于”的英文：approximately equal to $\\propto$ \\propto “正比于”的英文：be proportional to 圈与点 渲染结果 LaTeX 写法 $\\degree$ \\degree $\\circ$ \\circ $\\cdot$ \\cdot $\\cdotp$ \\cdotp $\\cdots$ \\cdots $\\ddots$ \\ddots $\\bullet$ \\bullet $\\dot{a}$ \\dot{a} 集合相关 渲染结果 LaTeX 写法 $\\in$ \\in $\\notin$ \\notin $\\subset$ \\subset $\\subseteq$ \\subseteq $\\supset$ \\supset $\\supseteq$ \\supseteq $\\cap$ \\cap $\\cup$ \\cap $\\complement$ \\complement 上下标的输入方法上标 ^ ，下标 _，例如： 1X_1 = a^2,X_2 = b^2 $$X_1 = a^2,X_2 = b^2$$ 同时上下标，只要连续输入 _ 和 ^ 即可，例如: 1X_3^2 = 9,X_4^2 = 16 $$X_3^2 = 9,X_4^2 = 16$$ 上下标如果由多字符组成，则需要加上花括号，例如： 1X_{i+j}^{k+l} $$X_{i+j}^{k+l}$$ 左边的上下标只要写在前面就行了，例如： 1^a_bX^c_d $$^a_bX^c_d$$ 所以除了通过 \\degree 的方法写度数，也可以通过上标的方法达到类似效果： 145\\degree,90^{\\circ} $$45\\degree,90^{\\circ}$$ “上升”： 1X^{X^{X^{X^{X^{X}}}}} $$X^{X^{X^{X^{X^{X}}}}}$$ ”下降“： 1X_{X_{X_{X_{X_{X}}}}} $$X_{X_{X_{X_{X_{X}}}}}$$ 分式1\\frac{a}{b} $$\\frac{a}{b}$$ 根式 渲染结果 LaTeX 写法 $\\sqrt{2}$ \\sqrt{2} $\\sqrt[3]{2}$ \\sqrt[3]{2} 1\\sqrt[b]{a} $$\\sqrt[b]{a}$$ 其他常用符号写法 渲染结果 LaTeX 写法 记法 $\\to$ \\to $\\infty$ \\infty ”无穷“的英文：infinity $\\lim_{x \\to 0}$ \\lim_{x \\to 0} $\\bot$ \\bot $\\perp$ \\perp ”相互垂直“的英文：perpendicular to each other $\\dot{a}$ \\dot{a} $\\hat{a}$ \\hat{a} $\\bar{a}$ \\bar{a} $\\vec{a}$ \\vec{a} ”向量“的英文：vector $\\tilde{a}$ \\tilde{a} ”波浪号“的英文：tilde 参考资料 latex公式语法_ecy_uooki的博客-CSDN博客_latex公式语法 latex不等于符号_Bagba的博客-CSDN博客_latex 不等于 latex补集怎么打 - 代码先锋网 (codeleading.com) 如何用latex编写上标、下标？ - 知乎 (zhihu.com)","link":"/posts/848a7d31.html"},{"title":"大一新生的高数预备知识学习笔记","text":"这篇文章主要是笔者从宋浩老师处学习高数高数知识的课堂笔记，也加入了一些笔者自己搜到的东西。具体课程你可以看这里： 00:01:26 大一新生的高数预备知识简介 63.1万 269 视频 宋浩老师官方 反三角函数y=arcsinX y=arccosX y=arctanX y=arccotX y=secX正割是余弦的倒数：$$secX = \\frac{1}{cosX}$$ 定义域：显然$cosX \\neq 0$，所以$y=secX$的定义域为：$X\\neq k\\pi +\\frac{\\pi}{2},k\\in Z$ y=cscX 一些补充$$sec^2x=1+tan^2x,csc^2x=1+cot^2x$$ 可以使用下面的方法进行记忆： 六边形的中间是$1$。红色三角形的上边两个角的平方之和等于下边一个的平方，即：$$sin^2x+cos^2x=1$$$$tan^2x+1=sec^2x$$$$cot^2x+1=csc^2x$$ 多项式的除法 次数高的放前面，低的放后边 缺项的补出来 不带余数 带余数 有理分式的拆分何为有理分式：有理分式就是一个多项式比一个多项式 何为有理分式的拆分：将相乘的项变成相加减 过程： 极坐标基础概念首先看转动角度，其次看这个点到原点的距离。 例如：直角坐标系中$(2,2)$点在极坐标系中表示为$(2\\sqrt{2},\\frac{\\pi}{4})$；$(-2,2)$表示为$(2\\sqrt{2},\\frac{3\\pi}{4})$。 极坐标中的原点叫极点，极轴是从极点向$X$轴正方向引入的一条射线（仅正方向有）。极坐标中的点到极点的距离叫做极径，记作$\\rho(\\rho\\geq0)$（距离肯定是个非负数）；从极轴逆时针转过的角度记作$\\theta(0\\leq\\theta&lt;2\\pi)$（但实际上不一定取这个范围）。所以极坐标中一点$P$的坐标记为$P(\\rho,\\theta)$。 一般先考虑$\\theta$再考虑$\\rho$。 一些常见图像的极坐标表示 括号内范围是默认范围，可写可不写 射线例如一条以极点为端点，$\\theta=45^\\circ$的射线表述为：$$\\theta = 45^\\circ(,\\rho\\geq0)$$ 圆例如一个以极点为圆心，$1$为半径的圆表述为：$$(0\\leq\\theta&lt;2\\pi,)\\rho=1$$ 半圆例如一个以极点为圆心，$1$为半径的位于$X$轴上方的半圆表述为：$$0\\leq\\theta\\leq\\pi,\\rho=1$$ 圆面例如一个以极点为圆心，$1$为半径的圆面表述为：$$(0\\leq\\theta&lt;2\\pi,)0\\leq\\rho\\leq1$$ 半圆面例如一个以极点为圆心，$1$为半径的位于$X$轴上方的半圆面表述为：$$0\\leq\\theta\\leq\\pi,0\\leq\\rho\\leq1$$ 又例如这个以$(1,0)$为圆心，$1$为半径的位于$X$轴上方的半圆面表述为：$$0\\leq\\theta\\leq\\frac{\\pi}{2},0\\leq\\rho\\leq2cos\\theta$$ 又例如这个： 圆环","link":"/posts/33435544.html"},{"title":"VS Code 的安装与配置基础 C&#x2F;C++ 开发环境","text":"笔者以前学习 C++ 的时候，使用的是 DevCpp 。这个软件让我这个初学者比较舒服的点是，我不用太过详细地考虑编译的过程——新建一个 cpp 文件，写一点小程序，按下 F11，程序运行。我不需要管选择编译器啊、配置编译命令啊啥啥的。但是到 VS Code 这边，这都要我自己做了，只能说相当不友好。这里记录一下我配置 VS Code 的 C/C++ 环境的完整过程，希望对你有所帮助。 安装 Visual Studio Code打开 VS Code 官网，点击 Download for Windows 按钮（其他平台请选择对应平台的安装包，此处以 Windows 平台为例），等待下载完成。 国内 VS Code 下载速度慢的解决方案 此方法来自：https://zhuanlan.zhihu.com/p/112215618 在你的下载软件处（笔者这里是 IDM，你如果是浏览器下载的就去浏览器的下载管理器里找），找到下载地址。将下载地址中的 az764295.vo.msecnd.net 替换为 vscode.cdn.azure.cn，然后取消原任务，用修改过的下载链接新建一个下载。 打开安装包，一路下一步，直到下面这个界面，按照下边的进行选择，直到安装完毕。 VS Code 设置中文打开 VS Code，点击图示左侧第五个图标或使用快捷键 Ctrl+Shift+X 打开 拓展 页面，搜索：Chinese，找到 Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code 这个插件，点击 Install 安装，等待安装完成后按照提示点击右下角 Restart 按钮重启 VS Code。 安装并检查编译器DevCpp 安装的时候也帮我们安装好了编译器，但 VS Code 并没有。所以我们还得自己装一个编译器。这里以 Mingw-w64 为例（参考官方教程）。 参考 MSYS2 官网下载安装和安装。 国内 MSYS2 下载速度慢的解决方案 在这个按钮上右键，选择复制链接。 然后前往https://ghproxy.com/这个网站，粘贴上面复制的下载链接，点击下载。 打开安装包，一路默认下一步。耐心等待（国内网络可以！只要耐心等！）直到出现下面的界面： 输入下面的命令安装 gcc： 1pacman -S mingw-w64-x86_64-gcc 接下来需要添加环境变量。直接搜索 高级系统设置： 打开后点击环境变量。 添加系统变量。 打开 CMD 检查一下是否成功：输入 gcc -v，如果有结果，就安装成功了。 C/C++ 扩展的安装按照上面的方法打开扩展，首先是几个 C/C++ 基础扩展，直接搜索 C++。 第一个：C/C++ 直接点击安装（笔者这里截图的时候还没重启，如果按照上述步骤已经安装了中文语言包并重启了 Code，这里的 Install 按钮就会变成 安装）。 第二个：C/C++ Extension Pack 第三个：C/C++ Compile Run 这个扩展提供了极其简单的F6一键编译运行功能。 正常运行测试新建一个文件夹，就叫 HelloWorld 吧。打开文件夹，右键，选择 通过 Code 打开。新建一个 HelloWorld.cpp，粘贴下面的代码： 123456789#include &lt;iostream&gt;using namespace std;int main(){ cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; return 0;} Ctrl+S 保存，F6 运行，成功输出结果。 Debug2022 年 10 月 6 日更新： 完成上边的步骤之后，你应该可以正常运行程序了。下面的教程是安装调试器以及通过 C/C++ Runner 让调试等工作变得简单。 首先再次打开 msys2.exe (默认位置是：C:\\msys64\\msys2.exe)，类似上边安装 gcc ，输入下边的命令安装 gdb。类似的，还需要输入下面的命令安装 gdb: 1pacman -S mingw-w64-x86_64-gdb 然后在 VS Code 中搜索并安装 C/C++ Runner 插件。 安装 C/C++ Runner 插件时其依赖项 CodeLLDB 无法安装的解决方案 按照右下角的提示前往这里下载 codelldb-x86_64-windows.vsix文件。 在 VS Code 中按下 Ctrl + Shift + P，输入 install，选择从VSIX安装...，选择上边下好的文件，等待安装完成。 安装完成后，左下角点击 Select folder.，选择当前文件夹。 然后按下小齿轮进行编译，按下三角形运行，设置好断点按下小虫子进行 Debug。 解决中文乱码问题2022 年 10 月 13 日更新： 参见我的另一篇文章：《【已解决】VS Code 中文乱码问题》 参考资料 国内下载 vscode 速度慢问题解决 官方教程：C++ programming with Visual Studio Code windows 10 环境下 使用 msys2 + vs code 配置 c++ 的编译环境","link":"/posts/a7a0ce82.html"},{"title":"一个用 C++ 实现高精度加法","text":"很早以前就知道大致的实现高精度加法的思路，也就是模拟列竖式，但是从未自己实现过。前几天在洛谷做题的时候看到了 [NOIP1998 普及组] 阶乘之和这道题，用了 unsigned long long 都无法满足结果的要求，便开始想尝试实现。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string betterPlus(string a, string b){ string c = &quot;&quot;; unsigned long long mx_size = a.length() &gt;= b.length() ? a.length() : b.length(); c.resize(mx_size + 1, '0'); //倒转 a，b，方便后续操作 reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); //填充上0 a.resize(mx_size, '0'); b.resize(mx_size, '0'); bool flag = 0; // flag为真表示需要进位 for (int i = 0; i &lt; mx_size; ++i) { int w = 0; // w为当前位两数之和 if (flag) //第一次一定为假，这里是第二次往后，如果为真，说明前面一位两数和大于10，需要进位 { w = a[i] - '0' + b[i] - '0' + 1; // ascii中0为'null',48为字符'0',直接出来的是ascii码，所以要减去'0'的ascii } else { w = a[i] - '0' + b[i] - '0'; } if (w &gt;= 10) { flag = 1; c[i] = char(w - 10 + '0'); } else { flag = 0; c[i] = char(w + '0'); } } //别忘了处理最后一位 if (flag) { c[c.length() - 1] = '1'; } reverse(c.begin(), c.end()); /* //去掉前面多余的0，但最后一位不需要去掉 for (int i = 0; i &lt; c.length() - 1; i++) { if (c[i] == '0') { c[i] = 0; continue; } if (c[i] != '0') { break; } }*/ return c;}int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; betterPlus(a, b) &lt;&lt; endl; return 0;} 分析输入要求是两个需要求和的数，默认它们是合规的数字。betterPlus(string a, string b)的两个参数a、b代表了想要求和的数，c表示结果。 笔者采用了倒序的方法，以“个是百千万”的顺序来对应数组下标由小到大。所以开头便用了&lt;algorithm&gt;库中的reverse()函数来将字符串倒序，最后也同样用这个方法将结果弄回正序。这是模拟列竖式思路的主要体现。 为了动态适应输入数字的位数，首先第10行用了一个a&gt;+b?a:b来找出输入数字中更大位数的那个的位数，又使用了resize()函数来动态调整string的大小。这个函数有两个参数，第一个是目标大小，为必选参数；第二个是如果要变大，那么补位的字符是什么，为可选参数。因为是加法，所以结果最多只会比原来输入的两个数中大的一个的位数多一位，所以第11行就直接+1了。 接下来的这个flag用来标识是否要进位，for循环里边就是一位一位处理的过程，19~45行完成所有位上数字的处理。 41~59行，本来是用于去掉多余的零的，不过那是在笔者实现之前一版最多支持50位数字时用的，现在动态调整位数之后，这些代码应该也不需要了。现在的支持的最大位数是无符号长整型unsigned long long的最大大小，也就是18446744073709551615。","link":"/posts/ea914ffe.html"},{"title":"C++ 中 cin 与 cout 的转进制输入输出","text":"笔者的朋友有道输入八进制输出十进制的题目，他是使用数学方法实现的。笔者隐隐约约记得好像cin和cout有控制输入输出数字进制的方法，查找了一些资料，做一下笔记。 进制 对应缩写 二进制 bin 八进制 oct 十进制 dec 十六进制 hex 接下来只要在输入/输出的时候加上这些缩写就行了。 比如输入一个八进制数然后以十进制输出它： 1234567891011#include &lt;iostream&gt;using namespace std;int main(){ unsigned long long num; cin &gt;&gt; oct &gt;&gt; num; cout &lt;&lt; dec &lt;&lt; num &lt;&lt; endl; return 0;} 程序运行结果： 1217501000 （”1750”是输入，”1000”是输出）","link":"/posts/9e863176.html"},{"title":"补记一个用 C++ 实现的 2048 小游戏","text":"校科协的加入有条件，面试前一步是笔试。免去笔试的方法也不是没有，可以做免试题。看了各个组的免试题，发现都好难好难，只有前端组的 2048 敢去尝试尝试。但我有没怎么学过 JS，便想着先用 C++ 实现一下逻辑，再把代码改过去。 游戏规则引用免试题中的原话： 在一个 4 * 4 大小共计 16 个的方格中，初始时会有随机两个方格出现 2 / 4 ，每次通过 方向键 控制所有方块向同一个方向运动，两个相同数字的方块撞在一起之后合并成为他们的和，每次操作之后会在空白的方格处随机生成一个 2 或者 4 ，当最终得到一个 2048 的方块时即获得游戏胜利。如果16个格子全部填满并且相邻的格子都不相同也就是无法移动的话，那么 Game Over 。 写这篇博客的时候才发现原来还有”当最终得到一个 2048 的方块时即获得游戏胜利”这句话，我并没有实现这个就是说。 C++ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;conio.h&gt;using namespace std;short box_c[4][4]; // 运算用 box_content// short box_s[4][4]; // 显示用 box_showbool map[4][4]; // 用于表示是否发生过合并/*([0][0]) ([0][1]) ([0][2]) ([0][3])([1][0]) ([1][1]) ([1][2]) ([1][3])([2][0]) ([2][1]) ([2][2]) ([2][3])([3][0]) ([3][1]) ([3][2]) ([3][3])*/int getRandomNum(int min, int max){ // 这里不能srand，不然就会生成出来都是同一个随机数 return (rand() % (max - min + 1)) + min;}int getTwoOrFour(){ if (getRandomNum(1, 2) == 1) { return 2; } return 4;}void generateNewNum(){ for (int i = 0; i &lt; 1;) { int possibleI = getRandomNum(0, 3); int possibleJ = getRandomNum(0, 3); if (box_c[possibleI][possibleJ] == 0) { i++; box_c[possibleI][possibleJ] = getTwoOrFour(); } }}// 清空mapvoid map_refresh(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { map[i][j] = 0; } }}void init() // 初始化{ // 初始化随机数种子 srand(time(0)); // 初始全部赋值为0 for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { box_c[i][j] = 0; map[i][j] = 0; } } // 随机找两个位置填充2或者4 /* for (int i = 0; i &lt; 2;) { int possibleI = getRandomNum(0, 3); int possibleJ = getRandomNum(0, 3); if (box_c[possibleI][possibleJ] == 0) { i++; box_c[possibleI][possibleJ] = getTwoOrFour(); } } */ // 直接用这个函数生成两个得了 generateNewNum(); generateNewNum();}// 本来想显示运算分离的，后来感觉好像没啥必要/* void refreshShow(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { box_s[i][j] = box_c[i][j]; } }} */void show(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { cout &lt;&lt; box_c[i][j] &lt;&lt; &quot; &quot;; // cout &lt;&lt; box_s[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl;}void moveUp(){ for (int j = 0; j &lt; 4; j++) { for (int i = 3; i &gt; 0; i--) { if (box_c[i - 1][j] == 0) { box_c[i - 1][j] = box_c[i][j]; box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } if (box_c[i - 1][j] == box_c[i][j] &amp;&amp; map[i - 1][j] == 0 &amp;&amp; map[i][j] == 0) { box_c[i - 1][j] *= 2; map[i - 1][j] = 1; //标识此次合并 box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } } } generateNewNum(); map_refresh();}void moveDown(){ for (int j = 0; j &lt; 4; j++) { for (int i = 0; i &lt; 3; i++) { if (box_c[i + 1][j] == 0) { box_c[i + 1][j] = box_c[i][j]; box_c[i][j] = 0; // 将上边的全部平移过来 for (int k = i; k &gt; 0; k--) { box_c[k][j] = box_c[k - 1][j]; box_c[k - 1][j] = 0; } } if (box_c[i + 1][j] == box_c[i][j] &amp;&amp; map[i + 1][j] == 0 &amp;&amp; map[i][j] == 0) { box_c[i + 1][j] *= 2; map[i + 1][j] = 1; //标识此次合并 box_c[i][j] = 0; // 将上边的全部平移过来 for (int k = i; k &gt; 0; k--) { box_c[k][j] = box_c[k - 1][j]; box_c[k - 1][j] = 0; } } } } generateNewNum(); map_refresh();}void moveLeft(){ for (int i = 0; i &lt; 4; i++) { for (int j = 3; j &gt; 0; j--) { if (box_c[i][j - 1] == 0) { box_c[i][j - 1] = box_c[i][j]; box_c[i][j] = 0; // 将右边的全部平移过来 for (int k = j; k &lt; 3; k++) { box_c[i][k] = box_c[i][k + 1]; box_c[i][k + 1] = 0; } } if (box_c[i][j - 1] == box_c[i][j] &amp;&amp; map[i][j - 1] == 0 &amp;&amp; map[i][j] == 0) { box_c[i][j - 1] *= 2; map[i][j - 1] = 1; //标识此次合并 box_c[i][j] = 0; // 将右边的全部平移过来 for (int k = j; k &lt; 3; k++) { box_c[i][k] = box_c[i][k + 1]; box_c[i][k + 1] = 0; } } } } generateNewNum(); map_refresh();}void moveRight(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 3; j++) { if (box_c[i][j + 1] == 0) { box_c[i][j + 1] = box_c[i][j]; box_c[i][j] = 0; // 将左边的全部平移过来 for (int k = j; k &gt; 0; k--) { box_c[i][k] = box_c[i][k - 1]; box_c[i][k - 1] = 0; } } if (box_c[i][j + 1] == box_c[i][j] &amp;&amp; map[i][j + 1] == 0 &amp;&amp; map[i][j] == 0) { box_c[i][j + 1] *= 2; map[i][j + 1] = 1; //标识此次合并 box_c[i][j] = 0; // 将右边的全部平移过来 for (int k = j; k &gt; 0; k--) { box_c[i][k] = box_c[i][k - 1]; box_c[i][k - 1] = 0; } } } } generateNewNum(); map_refresh();}int main(){ init(); show(); // https://www.runoob.com/w3cnote/c-get-keycode.html while (true) { if (_kbhit()) { //如果有按键按下，则_kbhit()函数返回真 int ch = _getch(); //使用_getch()函数获取按下的键值 switch (ch) { case 119: // w moveUp(); show(); break; case 97: // a moveLeft(); show(); break; case 115: // s moveDown(); show(); break; case 100: // d moveRight(); show(); break; default: break; } if (ch == 27) { break; } //当按下ESC时结束 } } return 0;} 代码阅读与分析4*4 方格的构建我创建了 box_c 这个二维数组来构建了下面这样一个棋盘来存放数据。数据值为 0 表示这个格子空着，非零则是对应数字。 1234567891011/*([0][0]) ([0][1]) ([0][2]) ([0][3])([1][0]) ([1][1]) ([1][2]) ([1][3])([2][0]) ([2][1]) ([2][2]) ([2][3])([3][0]) ([3][1]) ([3][2]) ([3][3])*/ 另外还有 map 这个二维数组，我放到后边说。 生成新的数字因为要在 4*4 的方格内随机生成 2 或者 4，所以首先就先做一个随机数生成器。 首先引入两个库： 12#include &lt;cstdlib&gt;#include &lt;ctime&gt; &lt;cstdlib&gt; 提供了 srand() 和 rand() 函数。 srand() 接受一个用于初始化的随机数”种子”。 一般我们就用当前时间time(0)作为种子。（这就是为什么我们需要引入 &lt;ctime&gt; 这个库。 ） rand() 函数会产生一个 [0,RAND_MAX]范围内的整数。通过一些算式，我们可以人为构造一些式子来实现生成需求范围内的随机数。下表展示了一些式子。 目标类型及范围 表达式 [0,n) 内的整数 rand() % n [a,b) 内的整数 (rand() % (b-a)) + a [a,b] 内的整数 (rand() % (b-a+1)) + a (a,b] 内的整数 (rand() % (b-a)) + a + 1 0～1之间的浮点数 rand() / double(RAND_MAX) 还有一个通用公式：a + rand() % n。 其中的 a 是起始值，n 是整数的范围。 注意！srand()用于初始化，只需要初始化一次。所以，你的获取随机数函数应该长得像这样： 12345678910int getRandomNum(int min, int max){ return (rand() % (max - min + 1)) + min;}int main(){ srand(time(0)); cout &lt;&lt; getRandomNum(1,100) &lt;&lt; endl; return 0;} 而不是这样： 12345678910int getRandomNum(int min, int max){ srand(time(0)); return (rand() % (max - min + 1)) + min;}int main(){ cout &lt;&lt; getRandomNum(1,100) &lt;&lt; endl; return 0;} 错误的写法会导致快速生成随机数时每次返回的都是随机数序列的第一个… （可能是程序运行速度很快种子都是一样的结果）。 接着我定义了 getTwoOrFour() 和 generateNewNum() 函数。前者用于随机生成 2/4，不必多说。后者用于在 4*4 方格内随机放上一个数字，首先生成行列坐标，如果检查到这个格子空的，可以生成在这，那就生成，结束该函数的运行，否则进行下一次尝试。 12345678910111213141516171819202122int getTwoOrFour(){ if (getRandomNum(1, 2) == 1) { return 2; } return 4;}void generateNewNum(){ for (int i = 0; i &lt; 1;) { int possibleI = getRandomNum(0, 3); int possibleJ = getRandomNum(0, 3); if (box_c[possibleI][possibleJ] == 0) { i++; box_c[possibleI][possibleJ] = getTwoOrFour(); } }} 初始化初始化主要就是两方面：一方面是初始化随机数种子；另一方面是清空棋盘（其实还有清空 map 标记），然后随机找两个位置放上 2 或者 4。 1234567891011121314151617void init() // 初始化{ // 初始化随机数种子 srand(time(0)); // 初始全部赋值为0 for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { box_c[i][j] = 0; map[i][j] = 0; } } // 随机找两个位置填充2或者4 generateNewNum(); generateNewNum();} 移动与合并 注意这里的移动与合并算法可能不是最优解，可能比较低效，甚至可能有错误。仅供参考。 移动无非就是上下左右，彼此之间比较类似。这里以向上移动为例： 12345678910111213141516171819202122232425262728293031323334void moveUp(){ for (int j = 0; j &lt; 4; j++) { for (int i = 3; i &gt; 0; i--) { if (box_c[i - 1][j] == 0) { box_c[i - 1][j] = box_c[i][j]; box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } if (box_c[i - 1][j] == box_c[i][j] &amp;&amp; map[i - 1][j] == 0 &amp;&amp; map[i][j] == 0) { box_c[i - 1][j] *= 2; map[i - 1][j] = 1; //标识此次合并 box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } } } generateNewNum(); map_refresh();} 首先因为是向上移动，所以先拆分一下上边的二维数组，拆成四列。第一层 j 的循环就是列的循环。 在某一列中，我想从下往上考虑：如果上面一个格子是 0 ，那我就把现在这个格子里的数字上移；如果这个位置和上边位置的数一样，我就让上边位置的数乘二，然后下边位置赋0。不断从下往上扫描直到能移动的全部移动，能合并的全部合并。 但是有个问题是，每次移动各个数字只能发生一次合并！如果这个数字合并过了，那它就不应该再合并了。比如四个2,移动一次应该产生两个4而非1个8。 所以我创建了一个 map ，用于标识已经发生的合并。并且取消掉了之前的不断的从上到下的扫描，改为了如果发生了一次移动或者合并，即给当前格子进行了赋0操作的话，我就把下边的所有格子往上移动一次。 总结一下思路：如果以 0,1,2,3 从上往下标识这一列格子。我从 3 往上扫描到 1 ，如果发现当前格子是 0，也即上边格子空着，我就把这个格子开始下边的所有格子往上移动一位；类似的，如果发现上边格子和当前格子可以合并，并且查询 map 发现这两个格子里边的数字在这轮移动中都没有发生过合并，那就合并，并也将下边格子的内容全部往上移动。 当四列都结束后，便用 generateNewNum() 填充一个新数字，并且清空 map 的状态。 结束检测这个 C++ 代码中这块并没有实现，不过最后的 Web 版本是实现了的。借一下那边的代码讲一下思路吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ifEnd: function () { console.log(&quot;正在检测游戏是否结束！&quot;); var flag = 0; for (var i = 0; i &lt; 4; i++) { for (var j = 0; j &lt; 4; j++) { // 如果有空位，说明必定可以继续 if (box_c[i][j] == 0) { flag = 1; console.log(&quot;检测到游戏仍然有空位，游戏继续！&quot;); break; } } if (flag == 1) { break; } } // 为0则说明没有空位了 if (flag == 0) { console.log(&quot;检测到游戏没有空位了，下面检测是否有可合并方块！&quot;); var flag2 = 0; for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { if ((box_c[i][j] == box_c[i][j + 1]) || (box_c[i][j] == box_c[i + 1][j])) { flag2 = 1; console.log(&quot;检测到可合并方块，游戏继续！&quot;); break; } } if (flag2 == 1) { break; } } // 最后一列单独检测 for (var i = 0; i &lt; 3; i++) { if (box_c[i][3] == box_c[i + 1][3]) { flag2 = 1; console.log(&quot;检测到可合并方块，游戏继续！&quot;); break; } } // 最后一行单独检测 for (var j = 0; j &lt; 3; j++) { if (box_c[3][j] == box_c[3][j + 1]) { flag2 = 1; console.log(&quot;检测到可合并方块，游戏继续！&quot;); break; } } if (flag2 == 0) { console.log(&quot;检测到游戏无空位且无法继续移动，游戏结束！&quot;); alert('游戏结束，即将重新开始！'); location.reload(); } } } 游戏结束的标志是两个：一是没有空格子了，二是任意相邻格子没有相同数字不可能发生合并了。 所以首先就是扫描所有格子看看有没有空格子。如果没有格子，就开始扫描相邻格子是否有相同数字。我的扫描方法是从(0,0)到(2,2)都只检测它的右方和下方是否与它相同，然后再单独检测一下最右边一列前三个元素的下一个和最下边一行前三个元素的右边一个是否与它们自己相同。如果也没有相同的了，那就 Game Over 。 获取键盘输入直接看参考资料《C/C++ 获取键盘事件》吧… 参考资料《C++产生随机数》《C/C++ 获取键盘事件》… …","link":"/posts/10d14c30.html"},{"title":"Icarus 主题自带的标签插件的使用以及官方文档中的常用消息框模板","text":"之前有写过使用 Bulma 美化博文的方法，然后才发现原来 Icarus 本身就带了很多标签插件可供直接使用。而官方文档中的横跨文章的提示框、警告框什么的我找遍了文档也没发现作者告诉我了调用的办法，直到今天才看到大佬的一篇文章讲到原来那些本身就是用原生 html 写的。所以写下此篇笔记，方便以后用。 官方自带标签插件官方文档：《自定义Hexo标签插件 - Icarus》 消息框语法定义123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %} &lt;内容&gt;{% endmessage %} 参数解释color(颜色)可选参数，可能值、实现方法和效果见下方： 123{% message title:default %} 一个没有设置颜色的消息框。{% endmessage %} default 一个没有设置颜色的消息框。 123{% message color:dark title:dark %} 一个深色(dark)的消息框。{% endmessage %} dark 一个深色(dark)的消息框。 123{% message color:primary title:primary %} 一个主题色(primary)的消息框。{% endmessage %} primary 一个主题色(primary)的消息框。 123{% message color:info title:info %} 一个提示色(info)的消息框。{% endmessage %} info 一个提示色(info)的消息框。 123{% message color:success title:success %} 一个成功色(success)的消息框。{% endmessage %} success 一个成功色(success)的消息框。 123{% message color:warning title:warning %} 一个警告色(warning)的消息框。{% endmessage %} warning 一个警告色(warning)的消息框。 123{% message color:danger title:danger %} 一个危险色(danger)的消息框。{% endmessage %} danger 一个危险色(danger)的消息框。 size(尺寸)可选参数，可能值、实现方法和效果见下方： 123{% message size:small title:small %} 一个小(small)消息框。{% endmessage %} small 一个小(small)消息框。 123{% message title:default %} 一个默认大小的消息框。{% endmessage %} default 一个默认大小的消息框。 123{% message size:medium title:medium %} 一个中(medium)消息框。{% endmessage %} medium 一个中(medium)消息框。 123{% message size:large title:large %} 一个大(large)消息框。{% endmessage %} large 一个大(large)消息框。 icon(图标)可选参数，来源 FontAwesome，类名中间含空格的加引号！ 一些例子： 123{% message color:success icon:&quot;fa-solid fa-circle-check&quot; title:&quot;fa-solid fa-circle-check&quot; %} 一个外部带圈的勾。{% endmessage %} fa-solid fa-circle-check 一个外部带圈的勾。 123{% message color:warning icon:&quot;fa-solid fa-triangle-exclamation&quot; title:&quot;fa-solid fa-triangle-exclamation&quot; %} 一个警告标志。{% endmessage %} fa-solid fa-triangle-exclamation 一个警告标志。 123{% message color:danger icon:&quot;fa-solid fa-circle-exclamation&quot; title:&quot;fa-solid fa-circle-exclamation&quot; %} 一个错误标志。{% endmessage %} fa-solid fa-circle-exclamation 一个错误标志。 title(标题)可选参数，中间含空格的加引号！ 有标题的上面已经演示过，下面是各种没有标题的消息框。 123{% message %} 一个没有设置颜色的消息框。{% endmessage %} 一个没有设置颜色的消息框。 123{% message color:dark %} 一个深色(dark)的消息框。{% endmessage %} 一个深色(dark)的消息框。 123{% message color:primary %} 一个主题色(primary)的消息框。{% endmessage %} 一个主题色(primary)的消息框。 123{% message color:info %} 一个提示色(info)的消息框。{% endmessage %} 一个提示色(info)的消息框。 123{% message color:success %} 一个成功色(success)的消息框。{% endmessage %} 一个成功色(success)的消息框。 123{% message color:warning %} 一个警告色(warning)的消息框。{% endmessage %} 一个警告色(warning)的消息框。 123{% message color:danger %} 一个危险色(danger)的消息框。{% endmessage %} 一个危险色(danger)的消息框。 标签页语法定义123456789{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} 参数说明上面重复的参数用法类似，不再解释，下面看上面没有出现过的参数。 id必选参数，具有唯一性，整个文档中不可重复。 align(对齐方法)可选参数，可能值、实现方法和效果见下方： 12345678910{% tabs %}&lt;!-- tab id:page1-1 title:第一页 active --&gt;(没有对齐参数)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page1-2 title:第二页 --&gt;(没有对齐参数)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (没有对齐参数)这是标签页 1 (没有对齐参数)这是标签页 2 12345678910{% tabs align:centered %}&lt;!-- tab id:page2-1 title:第一页 active --&gt;(对齐参数：centered)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page2-2 title:第二页 --&gt;(对齐参数：centered)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (对齐参数：centered)这是标签页 1 (对齐参数：centered)这是标签页 2 12345678910{% tabs align:right %}&lt;!-- tab id:page3-1 title:第一页 active --&gt;(对齐参数：right)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page3-2 title:第二页 --&gt;(对齐参数：right)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (对齐参数：right)这是标签页 1 (对齐参数：right)这是标签页 2 12345678910{% tabs align:fullwidth %}&lt;!-- tab id:page4-1 title:第一页 active --&gt;(对齐参数：fullwidth)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page4-2 title:第二页 --&gt;(对齐参数：fullwidth)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (对齐参数：fullwidth)这是标签页 1 (对齐参数：fullwidth)这是标签页 2 style(样式)可选参数，可能值、实现方法和效果见下方： 12345678910{% tabs %}&lt;!-- tab id:page5-1 title:第一页 active --&gt;(样式：默认)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page5-2 title:第二页 --&gt;(样式：默认)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：默认)这是标签页 1 (样式：默认)这是标签页 2 12345678910{% tabs style:boxed %}&lt;!-- tab id:page6-1 title:第一页 active --&gt;(样式：boxed)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page6-2 title:第二页 --&gt;(样式：boxed)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：boxed)这是标签页 1 (样式：boxed)这是标签页 2 12345678910{% tabs style:toggle %}&lt;!-- tab id:page7-1 title:第一页 active --&gt;(样式：toggle)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page7-2 title:第二页 --&gt;(样式：toggle)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：toggle)这是标签页 1 (样式：toggle)这是标签页 2 12345678910{% tabs style:toggle-rounded %}&lt;!-- tab id:page8-1 title:第一页 active --&gt;(样式：toggle-rounded)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page8-2 title:第二页 --&gt;(样式：toggle-rounded)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：toggle-rounded)这是标签页 1 (样式：toggle-rounded)这是标签页 2 官方文档中的横跨文章的提示框、警告框等摘自官网的一些： 1234567{% raw %}&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译：&lt;a href=&quot;/hexo-theme-icarus/uncategorized/custom-hexo-tag-helpers/&quot;&gt;English&lt;/a&gt;。&lt;/div&gt;&lt;/article&gt;{% endraw %} 本文同时提供以下语言的翻译：English。 123456789{% raw %}&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;The following content is taken from &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://hexo.io/docs/tag-plugins.html&quot;&gt;Hexo documentation&lt;/a&gt;with minor revisions.&lt;/div&gt;&lt;/article&gt;{% endraw %} The following content is taken from Hexo documentation with minor revisions. 1234567{% raw %}&lt;article class=&quot;message message-immersive is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？请点击&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/zh-CN/CDN-Providers.md&quot;&gt;此处&lt;/a&gt;提交修改。&lt;/div&gt;&lt;/article&gt;{% endraw %} 文章内容有误？请点击此处提交修改。 还有更多参数请见：《Icarus消息框模板 - Astroblog》","link":"/posts/8ffe9166.html"},{"title":"C 语言中与(&amp;&amp;)和或(||)运算符的短路运算","text":"此篇笔记来源于下边的这个题目。 本来以为结果为 3，但是实际跑了一下发现结果是 1。请教了一下大佬知道了这叫做或运算符（||）的短路运算。 正常来说，或运算中只要有一个为真，结果就为真。所谓或的短路运算就是说，如果已经出现了真，那么后续的运算就不会进行了。以上面的题目为例就是，因为第一个 ++x 这个运算结果肯定为真，那么后面的另外两个 ++x 就不会运行。 类似的，还有与（&amp;&amp;）的短路运算。正常来说，与运算中必须所有均为真，结果才为真。所以与的短路就是，如果前面的运算结果已经有假了，那么就可以确定这个与运算总体的结果为假，也就不会运行后边的运算了。","link":"/posts/13d09bbb.html"},{"title":"挖老婆矿！—— NovelAI 初试","text":"最近一段时间，感觉突然之间，就有很多很多将现实图片二次元化啊，按照每句歌词生成一副画作啊的 AI 绘画应用的图文视频出现。和室友聊天还说是不是最近一段时间 AI 技术突破什么瓶颈突飞猛进了。后来才知道，原来是 NovelAI 泄露了… 这样一来，本地部署方便了起来，于是整了一个玩玩。由于跑 AI 嘛，GPU 比较呼啸，跟挖矿一样，我就戏称我这是在“挖老婆矿”了。 注：这篇文章更偏向于我记录生成时使用的 tag， 不涉及基础操作。我使用的 NovelAI 下载自这里。 一个头像（一堆头像）我最开始只是用几个 tag 生成。经历了一些粗浅的尝试后，发现生成的质量并不高。但是看到了一篇文章，照着里边的 tag 写，才算真正开始了探索。 首先是根据上边那篇文章最后的示例增改了点 tag 形成的 prompt: 1blue pen illustration, light blue background, flowers on face, growth, nature, beautiful face, pink hair,shawl hair, zoom in on eyes, apathy, red eye shadow, petite, best quality, masterpiece 然后生成出了下面这些相当不错的图案： 下边分类讲讲 tag: 提高总体质量的： 1masterpiece, best quality, by famous artist, beautiful face 使整体的风格偏向更具插画感： 1illustration 限定背景的： 1xxxx + backgroud (比如上边的淡蓝色背景就是 light blue background ) 让生成出来的 waifu 更幼的： 1petite 让脸上、头发上出现花朵装饰的： 1flowers on face 让眼睛更大的： 1zoom in one eyes 尝到了甜头后，我就想换头像了。但我不想完全抛弃现在的头像，于是就试图拿它做派生。 首先描述一下原来的头像，让 AI 知道我大概是想要怎样的一个 “老婆”。（虽然其实我描述的时候更感觉是在捏女儿） 顺便一说，我这个原来的头像其实也是 AI 生成的，叫 WaifuLabs，是我把原来生成出来的丢进 PS 去了水印，又自己修缮了一下得到的。 抛却那些提高质量的，大概给了 披肩发、深灰色头发、深灰色眼睛、红色眼影、白色衬衫、微笑 这些 tag。同时模仿了上边，给了 面部的花 之类的 tag： 1{{masterpiece,best quality}},shawl hair,dark grey hair, dark grey eyes,red eye shadow, white shirt,illustration,flower on face,growth, nature,beautiful face, smile, zoom in one eyes 以上边的内容为 prompt，同时把我改的那张扔给 NovelAI，根据生成结果又慢慢改，添加 tag，最终的 prompt 如下: 1{{masterpiece,best quality,by wlop}},shawl hair,dark grey hair, dark grey eyes,red eye shadow, white shirt,{{{illustration}}},flower on face, growth, nature, beautiful face, small smile, zoom in one eyes, {{{{petite}}}}, dramatic shadows, ink,eye-focus, portrait, red hairclip 跑了大概 100 张，然后挑了挑，下边展示的是部分高质量的： 又是一波奇奇怪怪的调整： 最后挑选出了这张我觉得挺有特色的： 然后开始根据这张进行派生： 一张壁纸（一堆壁纸）这事儿开始的挺搞笑的，当时我正在调上边的头像参数，坐我旁边玩 CSGO 的朋友希望我把某把枪拟人，然后发我了下边的图片： 然后我加了点描述词生成了，但生成效果并不好，我就又开始研究我上边的头像了。我完全忘记了我还拿着这张图生成的某张图在做派生呢… 我只是改回了我的 prompt，就意外地得到了下边这张图： 似乎是把枪头画成了那条条纹？我也不知道。反正着实是惊艳到我了，扔到 bigjpg 那边提高了一下分辨率，再扔进 PS 调了一下曲线，嘿嘿，新的手机壁纸有了！ 然后又拿这张图和基于上边改的 prompt 做了派生… 1{{masterpiece,best quality}},shawl hair,dark grey hair, dark grey eyes,red eye shadow,red scanf, light grey shirt,{{illustration}},red flower on face,white flower on hair,growth, nature,beautiful face, {{indifferent}}, zoom in one eyes,1girl, red flower background, gold fence background,focus on eye 相当不错！","link":"/posts/f17b3e8b.html"},{"title":"C&#x2F;C++ 格式化输入输出汇总","text":"本文汇总一下 C 语言 scanf 和 printf 的格式控制方法以及 C++ 的 &lt;iomanip&gt; 库。 C 语言此处内容来源于 《C Primer Plus （第 6 版）中文版》。 printf() 函数转换说明ANSI C 中 printf() 的转换说明（P69，表 4.3：转换说明及其打印的输出结果） 整数 转换说明 打印的结果 %d / %i 有符号十进制整数 %u 无符号十进制整数 %o 无符号八进制整数 %x 无符号十六进制整数，使用十六进制数 0f %X 无符号十六进制整数，使用十六进制数 0F %a / %A 十六进制数、浮点数和 p 计数法（C99/C11） 浮点数 转换说明 打印的结果 %e / %E 浮点数，e 计数法 %f 浮点数，十进制计数法 %g / %G 根据值的不同，自动选择 %f 或 %e / %E。%e / %E 格式用于指数小于-4 或大于等于精度时。 %a / %A 十六进制数、浮点数和 p 计数法（十六进制指数计数法）（C99/C11） 其他 转换说明 打印的结果 %c 单个字符（包括空白字符） %s 字符串 %p 指针 % 百分号 转换说明修饰符（P71，表 4.4：printf()的修饰符）： 修饰符 含义 标记 共 5 种（-, +, 空格, # , 0） 数字 最小字段宽度（不够自动变宽） .数字 精度（具体见下边说明） h 和整型转换说明一起使用，表示 short int 或 unsigned short int hh 和整型转换说明一起使用，表示 signed char 或 unsigned char j 和整型转换说明一起使用，表示 intmax_t 或 uintmax_t （这些类型定义在 &lt;stdint.h&gt; 中） l 和整型转换说明一起使用，表示 long int 或 unsigned long int（和浮点型转换说明构成 %lf，表示 double） ll 和整型转换说明一起使用，表示 long long int 或 unsigned long long int（C99） L 和浮点转换说明一起使用，表示 long double 类型的值 t 和整型转换说明一起使用，表示 ptrdiff_t （ptrdiff_t 是两个指针差值的类型，C99） z 和整型转换说明一起使用，表示 size_t （size_t 是 sizeof 返回的类型，C99） 上边的 .数字： 对于 %e、%E、%f，表示小数点右边数字的位数； 对于 %g、%G，表示有效数字的最大位数； 对于 %s，表示待打印字符的最大数量； 对于整型转换，表示待打印数字的最小位数，如有必要，使用前导 0 来达到这个位数。 只是用 . 表示其后跟随了一个 0，所以 %.f 和 %.0f 相同。 （P72，表 4.5：printf()中的标记）： 标记 含义 - 左对齐 + 有符号值前加正负号 空格 有符号值正不加，负加负号 # 把结果转换为另一种形式，具体看下边 0 对于数值格式，用前导 0 代替空格填充字段宽度。对于整数格式，如果出现-标记或者指定精度，则忽略该标记 # 的说明： %o：以 0 开始； %x / %X：以 0x / 0X 开始； 所有浮点格式：保证即使后边没有任何数字，也打印一个小数点字符； %g / %G：防止结果后边的 0 被删除。 scanf()函数大部分与上边相同，只讲不一样的。 （P80，表 4.7：scanf()转换说明中的修饰符）： 转换说明 含义 * 抑制赋值 数字 最大字符宽度。输入达到这个宽度或者第一次遇到空白字符时停止。 scanf() 的返回值是成功读取的项数。如果没有读取任何项，则返回 0；如果检测到“文件结尾”，返回 EOF （EOF 是定义 &lt;stdio.h&gt; 中定义的特殊值，一般用 #define 定义为 -1）。 注意：输入数字的时候，在不设置分隔符号时，scanf()默认使用空白字符进行分隔；但是输入字符时，空白字符不会被忽略，而是被顺利读入。 比如下边这道题： 有如下程序段： 123int a1, a2;char c1, c2;scanf(&quot;%d%c%d%c&quot;, &amp;a1, &amp;c1, &amp;a2, &amp;c2); 若要求 a1, a2, c1, c2 的值分别为 10, 20, A, B，正确的数据输入是（ ）： A. 10A20 B&lt;CR&gt; B. 10 A 20 B&lt;CR&gt; C. 10 A20B&lt;CR&gt; D. 10A 20B&lt;CR&gt; 正确答案为 D。 C++参考：【C++】C++标准库之 iomanip 库（格式输入输出）_Jacky_Feng 的博客-CSDN 博客 控制符 作用 oct 八进制输入/输出 dec 十进制输入/输出 hex 十六进制输入/输出 setbase(n) 设置为 n 进制 (n = 8, 10, 16) setprecision(n) 设置浮点数的有效数字为 n 位 setfill(c) 设置字符填充为 c setw(n) 设置宽度 setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示 setiosflags(ios::scientific) 设置浮点数以科学计数法表示 setiosflags(ios::left) 输出左对齐 setiosflags(ios::right) 输出右对齐 setiosflags(ios::skipws) 忽略前导空格 setiosflags(ios::uppercase) 在以科学计数法输出 E 与十六进制输出 X 以大写输出，否则小写 setiosflags(ios::showpos) 输出正数时显示”+”号 setiosflags(ios::showpoint) 强制显示小数点 resetiosflags() 终止已经设置的输出格式状态，在括号中应指定内容 更多请见：iomanip CPP 官方教程 _w3cschool","link":"/posts/b4e7acd7.html"},{"title":"C&#x2F;C++ 中赋值语句的返回值问题","text":"我曾经一直以为 C/C++ 中赋值语句的返回值不是 0 就是 1 —— 成功执行赋值操作返回 1，没有成功执行就返回 0。直到今天课上的一个例子，才让我知道，原来赋值语句的返回值就是赋的值的大小！ 起因是下边的这道题目： 12345678910111213141516171819202122int i;// 下边各个循环的执行次数是多少：// 1: 死循环for (i = 0;; i++){ printf(&quot;%d&quot;, i);}// 2：0次循环for (; i = 0; i++){ printf(&quot;%d&quot;, i);}// 3：0次循环for (i = 0; i &lt; 0; i++){ printf(&quot;%d&quot;, i);}// 4：死循环while (i = 1){ i++;} 第一个因为 for 语句的第二个参数缺失，所以该循环不会停止；第三个初值i=0;即不满足i&lt;0;，故不执行。 第四个，按照我错误的理解，赋值成功返回 1，所以说得通是while(true)永远执行，但四二个却无法这么解释了。去试了试写个下边两个东西输出赋值语句的返回值，才发现原来赋值语句的返回值就是赋的值。 C 代码： 12345678910#include &lt;stdio.h&gt;int main(){ int a = 0, b = 5, c = -5, d; printf(&quot;%d\\n&quot;, (int)(d = a)); printf(&quot;%d\\n&quot;, (int)(d = b)); printf(&quot;%d\\n&quot;, (int)(d = c)); return 0;} C++ 代码： 123456789101112#include &lt;iostream&gt;using namespace std;int main(){ int a = 0, b = 5, c = -5, d; cout &lt;&lt; int(d = a) &lt;&lt; endl; cout &lt;&lt; int(d = b) &lt;&lt; endl; cout &lt;&lt; int(d = c) &lt;&lt; endl; return 0;} 输出结果均如下： 12305-5","link":"/posts/9693ba6.html"},{"title":"【已解决】VS Code 中文乱码问题","text":"问题解决开门见山，我最后采用的解决方案是对 C/C++ 文件单独设置默认编码。大致的操作方法是，打开 VS Code 的 settings.json 文件，添加如下配置： 123456&quot;[cpp]&quot;: { &quot;files.encoding&quot;: &quot;gbk&quot;},&quot;[c]&quot;: { &quot;files.encoding&quot;: &quot;gbk&quot;} 具体的操作请参见原文：《VSCODE C 语言终端输出中文乱码编码设置》 解决过程复盘一下解决这个问题的过程。 首先了解到的是 VS Code 中文乱码的根本原因——VS Code 默认的编码格式是 UTF-8 （这一点可在 VS Code 右下角看到），而 VS Code 调用的终端是 CMD，默认的编码格式是 gbk。所以解决方案就是两个方向：要么是更改终端的默认编码，从默认的 gbk 转为 utf8；要么就是更改 VS Code 中的 C/C++ 文件的编码。 2022/10/26 更新： 看到一个有意思的科普视频，贴在这里，可以看看乱码到底是如何产生的。 00:15:00 锟斤拷�⊠是怎样炼成的——中文显示“⼊”门指南【柴知道】 332.1万 1.3万 视频 柴知道 第一个方向：更改终端默认编码了解到更改 CMD 编码为 utf8 的命令如下： 1chcp 65001 顺便一提，查看当前编码的命令为： 1chcp chcp 65001 这串命令的意思就是更改代码页为 65001，也就是用 utf8 编码。 这串命令不是永久生效的，所以每次都要输入，比较麻烦。网上也有一些解决方案，比如通过修改注册表每次都自动运行一下上边的命令（《修改 Windows10 命令终端 cmd 的编码为 UTF-8》），或者是配置 VS Code 让其自动输入的（《永久解决 VS Code 终端中文乱码问题》），可以去看看。 第二个方向：更改 VS Code 中的 C/C++ 文件的编码最初这个方法我只是想临时解决一下，就比较简单。点一下右下角的 UTF-8，选择 通过编码重新打开，选择 gbk 就行了。但这样只有一次，然后就想看看有没有永久的方法，便看到了上边的文章。 顺便一提，这里可能还要把 VS Code 设置中的自动猜测编码功能打开，具体操作如下： 使用 Ctrl + , 快捷键打开设置； 在搜索框输入 encoding ，找到 Files:Auto Guess Encoding，勾上它。 参考资料 《VSCODE C 语言终端输出中文乱码编码设置》 《修改 Windows10 命令终端 cmd 的编码为 UTF-8》 《永久解决 VS Code 终端中文乱码问题》","link":"/posts/ca05bed5.html"}],"tags":[{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"Edge","slug":"Edge","link":"/tags/Edge/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"推荐","slug":"推荐","link":"/tags/%E6%8E%A8%E8%8D%90/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"Element UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"问题","slug":"问题","link":"/tags/%E9%97%AE%E9%A2%98/"},{"name":"已解决","slug":"已解决","link":"/tags/%E5%B7%B2%E8%A7%A3%E5%86%B3/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"RLCraft","slug":"RLCraft","link":"/tags/RLCraft/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Bulma","slug":"Bulma","link":"/tags/Bulma/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"建模","slug":"建模","link":"/tags/%E5%BB%BA%E6%A8%A1/"},{"name":"Blender","slug":"Blender","link":"/tags/Blender/"},{"name":"Hexo插件","slug":"Hexo插件","link":"/tags/Hexo%E6%8F%92%E4%BB%B6/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"随机数生成器","slug":"随机数生成器","link":"/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"NovelAI","slug":"NovelAI","link":"/tags/NovelAI/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"iomanip","slug":"iomanip","link":"/tags/iomanip/"}],"categories":[{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"推荐","slug":"推荐","link":"/categories/%E6%8E%A8%E8%8D%90/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"游戏","slug":"游戏","link":"/categories/%E6%B8%B8%E6%88%8F/"},{"name":"Web","slug":"学习/Web","link":"/categories/%E5%AD%A6%E4%B9%A0/Web/"},{"name":"车","slug":"学习/车","link":"/categories/%E5%AD%A6%E4%B9%A0/%E8%BD%A6/"},{"name":"LaTeX","slug":"学习/LaTeX","link":"/categories/%E5%AD%A6%E4%B9%A0/LaTeX/"},{"name":"数学","slug":"学习/数学","link":"/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E5%AD%A6/"},{"name":"Minecraft","slug":"游戏/Minecraft","link":"/categories/%E6%B8%B8%E6%88%8F/Minecraft/"},{"name":"C&#x2F;C++","slug":"学习/C-C","link":"/categories/%E5%AD%A6%E4%B9%A0/C-C/"},{"name":"AI","slug":"学习/AI","link":"/categories/%E5%AD%A6%E4%B9%A0/AI/"},{"name":"建模","slug":"学习/建模","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%BB%BA%E6%A8%A1/"},{"name":"Hexo","slug":"学习/Web/Hexo","link":"/categories/%E5%AD%A6%E4%B9%A0/Web/Hexo/"},{"name":"Vue.js","slug":"学习/Web/Vue-js","link":"/categories/%E5%AD%A6%E4%B9%A0/Web/Vue-js/"},{"name":"RLCraft","slug":"游戏/Minecraft/RLCraft","link":"/categories/%E6%B8%B8%E6%88%8F/Minecraft/RLCraft/"},{"name":"NovelAI","slug":"学习/AI/NovelAI","link":"/categories/%E5%AD%A6%E4%B9%A0/AI/NovelAI/"},{"name":"Blender","slug":"学习/建模/Blender","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%BB%BA%E6%A8%A1/Blender/"}],"pages":[{"title":"","text":"","link":"/Bookmarks.html"},{"title":"","text":"555aa853c96ff5a922c522a73f469254","link":"/baidu_verify_code-53bseLro2G.html"},{"title":"","text":"google-site-verification: google7b9c7ea42a3102a3.html","link":"/google7b9c7ea42a3102a3.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}