{"posts":[{"title":"Chrome 插件推荐","text":"你可能常年使用着国产的一些浏览器，却也常年遭受着各种弹窗、全家桶的侵扰… 你也可能不止一次地听过”Chrome”，安装下来后却发现他空空如也，又默默地装回那些国产… 那么，让这些插件来拯救你吧 注：文中提到的鹏少、Joker鹏少等均指 B 站 up 主JOKER 鹏少，版权归其所有。他也是我非常喜欢的一个 up 主，为避免误会，特此声明。介绍中的引用部分为各个插件自己的介绍。 插件安装方法问度娘~ 或者在这里观看视频教程 必备插件Tampermonkey 介绍 The world’s most popular userscript manager 一个脚本管理插件，允许你自己通过编写脚本来实现某种功能，也可以下载脚本使用 下载地址 Chrome 网上应用店 谷歌访问助手 介绍 最简单易用的谷歌访问助手,为 chrome 扩展用户量身打造。可以解决 chrome 扩展无法自动更新的问题，同时可以访问谷歌 google 搜索，Gmail 邮箱，google+等谷歌服务。 帮助你访问所有 Google 的页面 截图预览 下载地址 Chrome 网上应用店 你也可以去鹏少资源网下载不用锁定主页的特别版 Infinity 新标签页(Pro) 介绍 百万用户选择的新标签页和快速拨号，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录。使你的主页和开始页更加美观和易用 在这里可以观看鹏少更详细的介绍 截图预览 下载地址 Chrome 网上应用店 百度优化 介绍 本扩展支持百度、搜狗、必应、好搜、谷歌搜索结果的页面结果广告优化和显示内容优化。绕过百度和搜狗的重定向，同时优化主流搜索引擎的搜索结果的样式效果，更方便快速的得到搜索的真实内容，更符合用户习惯。同时支持双列三列甚至四列展示百度谷歌和必应的页面，还自带有护眼模式 截图预览 下载地址 Chrome 网上应用店 划词翻译 介绍 支持谷歌、百度、有道三大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。 同类型的软件很多 但是自己感觉这款最轻量好用 截图预览 下载地址 Chrome 网上应用店 FireShot 介绍 捕捉网页截图，编辑并将它们保存为 PDF，JPEG，GIF，PNG 或 BMP；上传，打印，在 Photoshop 中打开，复制到剪贴板或电子邮件 在这里可以观看鹏少更详细的介绍 截图预览 下载地址 Chrome 网上应用店 Stylus 介绍 Stylus 是一个调整网页外观的用户样式管理器。它可让您轻松地为许多热门网站网站安装主题和皮肤。 在这里可以观看鹏少更详细的介绍 截图预览 下载地址 Chrome 网上应用店 官网 Adblock Plus 介绍 Adblock Plus 是拥有超过 5 亿次下载的全球最受欢迎的广告拦截软件之一。 下载地址 Chrome 网上应用店 AdGuard 广告拦截器 介绍 广告拦截扩展对抗广告和弹出窗口。拦截 Facebook，YouTube 和所有其它网站的广告。 下载地址 Chrome 网上应用店 Clutter Free 介绍 Reduce tab clutter - prevent duplicate tabs, quickly search &amp; switch tabs, and more… 自动关闭重复打开的标签页 下载地址 Chrome 网上应用店 crxMouse Chrome™ 手势 介绍 方便,快捷,充分发掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等. 截图预览 下载地址 Chrome 网上应用店 官网 IE Tab 介绍 在标签页中以 IE 内核显示网页。快捷、强健、可靠。这个版本是最流行的一个原因。 下载地址 Chrome 网上应用店 Imagus 介绍 Enlarge thumbnails, and show images/videos from links with a mouse hover. 在这里可以观看鹏少更详细的介绍 下载地址 Chrome 网上应用店 Lazy Tabs 介绍 Unload all inactive tabs (except pinned) at startup or by clicking an icon 下载地址 Chrome 网上应用店 OneTab 介绍 节省高达 95％的内存，并减轻标签页混乱现象 截图预览 下载地址 Chrome 网上应用店 云盘万能钥匙 介绍 您的云盘智能助手 在这里可以观看鹏少更详细的介绍 下载地址 Chrome 网上应用店 官网 适用于 B 站朋友们的插件哔哩哔哩助手 介绍 哔哩哔哩弹幕网辅助扩展，拥有视频区和直播区的人性化功能 截图预览 下载地址 Chrome 网上应用店 官网 获取哔哩哔哩 bilibili 视频的封面图片 介绍 获取哔哩哔哩 bilibili 视频的封面图片 下载地址 Chrome 网上应用店","link":"/posts/72a59031.html"},{"title":"记一次电脑清灰","text":"电脑是以前的老电脑，初一暑假时候买的y700。配置低的可怜，毫无性价比的一台机子吧，当年还是电脑小白的时候保意买的，在完全不懂的情况下被忽悠着忽悠着买了，满满的坑啊。 这电脑之前被我拆开来过，为了加一条固态，后盖螺丝因而已经不全了（拆必丢原则!），不过这次没丢! 硅脂买的是7921，网上说好用就买了，竟然还送了一些刷子垫片啥的，应该是很多人都买了清灰用的所以店家就把清灰附属需要的东西也都附赠了，这点还挺不错的。但是实际涂起来吧，这款硅脂是真的令我痛苦——真的很奇妙的质感，比较像容易断的那种橡皮泥(?)，反正结果就很尴尬（我知道我涂多了！没办法） 弄好装完发现点不亮了!吓了我一跳，结果发现是放那儿好久原来一直没接电源所以没电，接上电就能正常进系统了，太懒了，就没烤一下再看看。","link":"/posts/50b3c006.html"},{"title":"记一次网络改造","text":"事情的起因是跟爸闲聊我抱怨家里为什么没有预埋到我和我妹房间的网线，结果才知道原来是有的，只不过藏在空面板里没有装接口……于是就开始兴致勃勃地想把它装起来(这样我房间里就有有线网了!)，赶紧买了面板，交换机，网线和一众工具。 接网线难在第一个，不过第一个弄会了后面也就快了，此次没有试水晶头的接法，下次有机会试试。 昨天仅仅是把面板弄完了，交换机今天才到的刚刚也弄上了，现在都做的很方便接上就能用了! 不过在等交换机的时候把家里老的路由器小米WiFi4整了出来，稀里糊涂地捣鼓了半天刷上了个openwrt，这个东西似乎是个linux发行版？! 反正似乎潜力巨大，可以装好多东西，但现在还没太研究，以前想试的adguard home似乎也可以试试去了。 现在我的房间也终于有千兆网了!","link":"/posts/b9a9b40d.html"},{"title":"Edge 扩展推荐","text":"2019 年 7 月写过一篇 Chrome 插件推荐的文章，那时候我还在用 Chrome 作为我的主要浏览器。一晃三年过去了，我也早已从 Google Chrome 转入全新 Chromium 内核构建的 Edge 浏览器。微软倒蛮有意思，自己从头开发的东西不咋地，在别人的平台上倒是表现得相当好。由于国内的水土不服啊，我用 Chrome 时总会遇到同步不了的情况，这点的体验在 Edge 这儿得到了很好的改善，也是我用 Edge 的主要原因吧。前些天帮很多同学做新机开荒，也推荐他们就用这款“Win11 原装”浏览器。当然一个浏览器肯定是离不开扩展的，趁着帮他们开荒这个机会，也顺便整理了我认为必备的一些浏览器扩展。 本文更多的从个人角度出发，仅涵盖了笔者的主要需求，自然是粗略的，仅供参考。 全部用户Dark Reader简介：强制暗黑模式的网页 Infinity 新标签页 (Pro)简介：rt，一个新标签页扩展 OneTab简介： 打开了太多网页的时候，按一下可以帮你全部收起来，之后可以自由恢复 Prevent Duplicate Tabs简介： 帮你干掉那些重复的标签页 uBlock Origin简介：干掉广告，且是众多去广告插件中占用相对较少的 捕捉网页截图 - FireShot 的简介：rt，支持长截图（名字有点怪，可能是翻译问题，搜索 FireShot 就能找到） 暴力猴简介：装脚本的插件，和大名鼎鼎的油猴一样的功能，这个可能(?)小巧一点 沙拉查词-聚合词典划词翻译简介：rt，划词翻译，可配置内容超多 Imagus简介：可以把网页图片放大了看 User-Agent Switcher for Chrome简介：“伪装”你自己 Video Speed Controller简介：rt，但是竟然也可以改视频前广告的播放速度！ 哔哩哔哩用户pakku：哔哩哔哩弹幕过滤器简介：简化（过滤）你的 b 站弹幕 哔哩哔哩助手：bilibili.com 综合辅助扩简介：功能超多，我主要用来下载 b 站视频了 Steam 用户Augmented Steam简介：为 steam 官网提供了众多试用的玩意儿 IT 工作者Octotree - GitHub code tree简介：方便地查看 github 上某个 repository 的文件结构 Surfingkeys简介：像 vim 一样的玩意儿，让你完全用你的键盘浏览网页","link":"/posts/3c91f84e.html"},{"title":"Hexo 使用 Icarus 主题安装 abbrlink 插件后 toc 插件生成的目录存在错误无法跳转的问题","text":"配置 Heox 博客，为了优化 seo，安装了 abbrlink 插件。但突然发现原来可以正常使用的 Icarus 主题自带的 toc 目录侧边栏无法正常跳转。查看源代码发现&lt;a&gt;标签的href属性均显示为&quot;#&quot;而非正确地址，遂前往寻找解决方案。 问题解决来源：hexo 文章目录点击不跳转，html 没有生成 href_宁理大神 1996 的博客-CSDN 博客 修改(你的Blog目录)/node_modules/hexo-toc/lib/filter.js中的29~31行 由原来的这样 1234//$title.attr('id', id);$title.children(&quot;a&quot;).remove();$title.html('&lt;span id=&quot;' + id + '&quot;&gt;' + $title.html() + &quot;&lt;/span&gt;&quot;);$title.removeAttr(&quot;id&quot;); 改为这样 1234$title.attr(&quot;id&quot;, id);// $title.children('a').remove();// $title.html( '&lt;span id=&quot;' + id + '&quot;&gt;' + $title.html() + '&lt;/span&gt;' );// $title.removeAttr('id');","link":"/posts/a55922c1.html"},{"title":"RLCraft 新手教程一：过渡到你的正常生存","text":"本教程是笔者自己游玩过程中写的，出发点是笔者自己想玩但又不想花费时间看很多实况去了解一些细节，又找不到比较详细的文字版中文教程，以致于无从下手，只能慢慢啃各种模组的百科和 RLCraft Wiki，便以教程形式写下自己的游玩过程，希望对后来者有所帮助。笔者不是什么资深玩家，故难免有疏漏，请大家多多包涵。 由于 NTP 模组（No Tree Punching，无树可撸）的存在，初入 RLCraft，你的第一件事情不再是获取原木，而是撸树叶获取木棍，然后找到沙砾获取燧石。你可以按住鼠标左键徒手破坏树叶和沙砾，然后用右键点击掉落物以拿起它（或者你也可以按下 shift 来吸取附近的掉落物）。 手拿燧石右击石头/圆石等坚硬方块（?）上表面，你可以获取燧石碎块，然后打开背包，在 2*2 的合成栏上边放燧石碎块，下边放木棍，获取一把粗糙的小刀。 使用粗糙的小刀破坏草，可以获得植物纤维，在背包合成栏用三个植物纤维合成一个植物绳。然后再使用燧石碎块、植物绳、木棍合成粗糙的斧头。恭喜你获取了这个游戏的第一把斧头，用这把斧头你就可以开采原木了——当心，树倒下来可能会砸死你！ 你不再能够直接使用背包合成栏分解原木，而是需要把原木竖直放在地上，并用斧头右击其上表面，以获取两块木板。木棍也可以用类似的方式获取——将木板放在地上，然后用斧头右击。 你可以看 jei 获取更多燧石工具的制作方法，但你更可以开始制作原版的木制工具。用木镐挖石头会掉落石子，四个石子 2*2 摆放可以获取圆石，而挖圆石则会直接掉落圆石。 恭喜你进入石器时代！现在，你可以开始下矿了！但要时刻注意的一点是照明——恐怖生物会在黑暗中生成… 别自己怎么死的都不知道。你会发现木棍加煤炭不再能合成原版火把，它们现在只能合成熄灭的火把。要点亮它们，你需要的是一颗打火石——将熄灭的火把和打火石放在合成栏里，你就可以获得点燃的火把。但这火把仍然会熄灭——比如一场雨过后，比如燃烧很久之后… 虽然还有很多路要走，但你现在基本上可以短暂地享受一回类原版的 MC 了。 To be continue…","link":"/posts/a1ada34d.html"},{"title":"补记一个用 Vue.js 和 ElementUI 实现的在线抽奖网页","text":"这件事儿发生在我的高中某个新学期开始，新来了一个电脑老师。有点打赌或者考验我的性质吧，ta说ta弄了随机数点名的小网页，还能用同学的照片进行抽取，问我能不能实现一个。ta的实现方法是jQuery，技术上比较老，界面也不太好看。我想去尝试一下别的方法，正好也试试略微学了一点的Vue.js，为了好看，用了Element UI。 一两个周末最终实现到现在的效果，能输入名字抽人，能随机数抽人（学号抽人？），还有一个通过图片抽的到今天也还没做。当时对着Vue.js和Element UI的开发文档勉里勉强做出来这个效果，现在早把那些基础知识忘记了，也不知道以后有没有工夫完善它了。 你可以点击这里来玩玩看。","link":"/posts/6a8a1633.html"},{"title":"Hexo 在 Icarus 主题下更改字体","text":"起因在使用Hexo搭建博客的过程中，笔者发现使用hexo s创建的localhost:4000显示的网页上的字体效果与hexo d到github上的网页字体效果不同。遂想统一两者字体，希望通过换字体的方式达到该目的。 选择字体英文笔者选择的是JetBrains Mono，中文笔者选择的是Source Han Sans CN VF Blod(思源黑体)。需要注意的是我们不仅要找到某个自己喜欢的字体，还需要找到字体对应的英文名。本文以这两个开源字体为例。 过程icarus的字体设置位于&lt;Blog_path&gt;\\node_modules\\hexo-theme-icarus\\include\\style下的base.styl中。第9~10行，原来为： 12$family-sans-serif ?= Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif$family-code ?= 'Source Code Pro', monospace, 'Microsoft YaHei' 现改为（将所需字体添加在最前面）: 12$family-sans-serif ?= 'JetBrains Mono', 'Source Han Sans CN VF Blod', Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif$family-code ?= 'JetBrains Mono', 'Source Han Sans CN VF Blod', 'Source Code Pro', monospace, 'Microsoft YaHei' 后记起因中的问题莫名其妙消失了… 于是笔者改回了原来的样子。","link":"/posts/2527d7a7.html"},{"title":"Hexo 使用 Bulma 美化文章","text":"虽然笔者已经在博客上安装了 hexo-admonition 插件来一定程度上对主体为 Markdown 的文章进行一定样式上的补充，但该插件所能提供的内容确实有限。如果能使用原生的 Html 和 CSS 技术自定义文章某些内容就好了。 搜索资料时看到了这两篇文章： 活用 Bulma 美化 Icarus 文章 Hexo和Icarus折腾 现做一些学习笔记。 在 Markdown 文件中插入 Html 和 CSS 内容使用下面的 raw 标签: 123{% raw %}//在这里添加一些内容不希望被渲染的内容{% endraw %} 可以让我们在 Markdown 文档中添加 Html 内容，例如： 12345{% raw %}&lt;div class=&quot;notification is-info&quot;&gt;这是一段 info&lt;/div&gt;{% endraw %} 显示为 这是一段 info 而通过 &lt;style type=&quot;text/css&quot;&gt; 和 &lt;/style&gt; 标记，我们又可以在 Html 内容中直接添加 CSS 内容。 用 Bulma 实现的一些常见的玩意儿直接看 《活用 Bulma 美化 Icarus 文章》这篇文章吧 在 VS Code 中预览 Bulma 内容首先在 VS Code 中按下 Ctrl + Shift + X 打开扩展页面。安装 Markdown Preview Enhanced。重启你的 VS Code，然后使用 Ctrl + K、V 打开侧边预览。(具体见该插件的官方中文文档) 接着添加 Bulma 的CSS：按下 Ctrl + Shift + P，输入 Markdown Preview Enhanced: Customize CSS，回车。笔者直接使用 @import 进行引入。 所以只要在上面命令打开的 style.less 开头添加: 1@import &quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css&quot;; 按下 Ctrl + Shift + P，输入 Markdown Preview Enhanced: Extend Parser，回车。编辑 onWillParseMarkdown。在下边的这是一个标记处： 123456onWillParseMarkdown: function(markdown) { return new Promise((resolve, reject)=&gt; { //这是一个标记 return resolve(markdown) }) } 添加： 12345678markdown = markdown.replace( /\\{% raw %}/g, (whole) =&gt; (``))markdown = markdown.replace( /\\{% endraw %}/g, (whole) =&gt; (``)) 现在它看起来应该是这样： 12345678910111213onWillParseMarkdown: function (markdown) { return new Promise((resolve, reject) =&gt; { markdown = markdown.replace( /\\{% raw %}/g, (whole) =&gt; (``) ) markdown = markdown.replace( /\\{% endraw %}/g, (whole) =&gt; (``) ) return resolve(markdown) }) } 上面的方法存在的问题以及也许可行的解决方案(暂未实际解决)Markdown Preview Enhanced 替换的时候会将所有的 raw 标签全部替换掉，以至于在渲染源代码部分时，会出现一些错误。但这些错误仅在本地的 VS Code 渲染时发生，在网页上是没有问题的。但还是… 让强迫症很难受。 现在的需求是，如果 raw 标签位于代码块中，那么渲染时它无需被删除，否则应该被删除。 笔者的思路是：检测 raw 标签的上下文，如果上文包含了标记为 Html/js 的代码块起始标记，下文包含了代码块结束标记，则不进行替换；反之进行替换。 暂未实际实现。","link":"/posts/14706354.html"},{"title":"Hexo 插件 hexo-admonition 在 Icarus 主题下的使用与测试","text":"Hexo 博客中的文章是使用 Markdown 来渲染的。虽然原版 Markdown 已经提供了很多样式，但笔者仍觉得有些不够。在翻 Hexo 的官方插件列表时，笔者找到了 hexo-admonition 这个插件来为博文添加更多样式。 插件官方说明https://github.com/lxl80/hexo-admonition/blob/master/README.md 安装首先使用npm安装该插件。 1npm install hexo-admonition --save 接着更改你的hexo主题的css。我使用的icarus主题，所以在&lt;blog_path&gt;\\node_modules\\hexo-theme-icarus\\include\\style下的article.styl结尾添加了如下内容（因为是.styl而非.css，所以对官方提供的内容使用这个工具进行了转换）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// hexo-admonition.admonition margin 1.5625em 0 padding .6rem overflow hidden font-size .64rem page-break-inside avoid border-left .3rem solid #42b983 border-radius .3rem box-shadow 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1) background-color #fafafa &amp; &gt; :last-child margin-bottom 0 !importantp &amp;.admonition-title position relative margin -.6rem -.6rem .8em -.6rem !important padding .4rem .6rem .4rem 2.5rem font-weight 700 background-color rgba(66, 185, 131, .1).admonition-title &amp;::before position absolute top .9rem left 1rem width 12px height 12px background-color #42b983 border-radius 50% content ' '.info&gt;.admonition-title, .todo&gt;.admonition-title background-color rgba(0,184,212,.1).warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title background-color rgba(255,145,0,.1).failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title background-color rgba(255,82,82,.1).admonition.info, .admonition.todo border-color #00b8d4.admonition.warning, .admonition.attention, .admonition.caution border-color #ff9100.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error border-color #ff5252.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before background-color #00b8d4 border-radius 50%.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before background-color #ff9100 border-radius 50%.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before background-color #ff5252 border-radius 50% 后自己微调将第24行由 1top .9rem 改为 1top 0.6rem 语法说明123!!! &lt;type&gt; &lt;title&gt;(四个空格)(**空行结束标记**) type支持： note info, todo warning, attention, caution error, failure, missing, fail “活学活用” 当&lt;title&gt;未设置时，将会以&lt;type&gt;作为标题 如果要设置空标题，应当使用&quot;&quot; 这非常重要！ 空行结束标记不能少！ 测试这是一条note 这是一条info 这是一条todo 这是一条warning 这是一条attention 这是一条caution 这是一条error 这是一条failure 这是一条missing 这是一条fail 2022年9月10日更新： 发现原来 Icarus 主题本身已经提供了类似功能：自定义Hexo标签插件","link":"/posts/f81be6d0.html"},{"title":"Blender 自学日记（一）：界面与基础操作","text":"该系列是笔者在自学 Blender 的过程中所作的笔记。课程来源是 doyoudo。这篇笔记是第一课的学习内容。 00:08:45 Blender自学日记，新手系统案例课！第一集 5.4万 179 视频 doyoudo 基础操作按住 ~ 同时鼠标选择：快捷切换视图 Ctrl + Alt + Q：切换四视图显示 鼠标中键：旋转视图 Shift + 鼠标中键：移动视图 右侧网格按钮：切换为 2.5D 创作视图 X：删除元素 Shift + A：新建元素 N：调出常用属性 锁定摄像机：进入摄像机后可以直接调整视图 G：移动物体 R：旋转物体 S：放大缩小 G/S + X/Y/Z：按照轴向去移动/放缩 鼠标右键：取消刚才的这些操作","link":"/posts/5aa9eb29.html"},{"title":"Hexo 插件 hexo-bilibili-card 的使用与修改","text":"使用 Hexo 写博文时，可能需要插入一个视频卡片。我使用的 Icarus 主题提供了 Youtube 的视频卡片，而我更需要的是 Bilibili 的。于是找到了这个插件—— hexo-bilibili-card 。 安装1npm install hexo-bilibili-card --save 使用在你的 Markdown 文档中添加： 1{% bilicard av/BV %} 修改2022/10/26 更新：插件更新了，以下内容行数不对了，作废。 使用过程中，我对其本身的样式不太满意，便对其 CSS 进行了一定程度的修改。 打开 &lt;Blog_path&gt;\\node_modules\\hexo-bilibili-card\\source\\bilicard.css 注释掉第 90 行： 1margin-top: 1px; 注释掉第 121 行： 1top: 78px; 修改第 119 行为： 1bottom: 2px; 修改第 141~142 行为： 12width: 30px;height: 15px;","link":"/posts/bb53ea7f.html"},{"title":"手动挡学习笔记","text":"最近几天一直在忙着考驾照的事情，8月份第一次考科二挂了后就开始边练科二边练科三。最近两三天先后把科三、第二次科二、科四过了，顺利拿到了C1驾照。但是…学的是手动挡，家里的车却是自动挡。所以想着如果不记一下的话，以后估计开惯了自动挡手动挡就不会了，便想做些笔记。顺便也记录一下笔者自己的学车过程。 相关做法仅供参考，有些内容可能也只适用于笔者这边的考试。如有错误敬请各位大佬指出。 科目一就是刷题嘛。笔者本人是把2000道题的题库先完整了一遍，然后又模拟了20+次，所以相当于做了4000多道题吧，结果是98一把过的。笔者一直很担心自己过不了那些扣分/罚款题，甚至为此还自己做了个表格把扣分项全部列在了里边。结果实际上并没有用上多少就是了，因为实际考试根本没有那么多难题。可能自己用的软件为了让你冲VIP所以不冲的话给的题目就会比较难吧。笔者也认识一个刷了600道直接过的，还有一个当天下午考结果上午中午刷了1200道直接过的。可能考试的时候抽题目也有点运气成分，和笔者一起去的朋友第二把的难度显然低于第一把，所以第一把80多但第二把就100了。 科目二科二始终是一档就行了，油门也是锁死的，所以只要看离合与刹车两个踏板。核心要点：速度慢一点。 开始前准备 系好安全带 调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜 调整内外后视镜。左后视镜下边缘差不多与后车轮下边缘重合为宜，右后视镜车身差不多占1/3，然后地平线位于上下1/2左右。（具体不记得了，笔者自己也有点弄不明白这里，请大佬指点） 倒车入库笔者第一次科二两把都挂在这儿了，都是“倒库不入”。正确的操作如下： 首先鼻子正对从右往左数第三条虚线左边缘开，直到开到虚线与肩膀对齐。 挂倒挡，看左后视镜下边缘，差不多与虚线前边缘对齐或间隔几厘米的时候（因人而异），向左打死方向盘。 往后倒的同时观察左后视镜，三条虚线压住两条半了看车身与库边缘的距离，如果较大（30cm以上？），则保持打死状态继续倒，否则回半圈继续倒。 主要通过右后视镜观察车身是否正。这时候需要自己微调，反正就车屁股要往左就方向盘往左打，车屁股要往右就往右打。 车身正了，端平方向盘，看左后视镜，差不多等到左后视镜完全压住黄线了，停车。 挂前进档，起步。观察左后视镜看到左后轮压到前库线了，向右打死方向盘。车身正，回半圈方向盘继续开直到左侧车门框压到黄虚线。 挂倒挡，起步。待左后视镜对齐黄线了向右打半圈并开始观察右后视镜。看三条虚线类似上边第3、4点进行调整。 完全停好，挂前进档，起步。同样观察左后视镜看到左后轮压到前库线了（或者这里也可以稍微提前一点），向左打死。车身正回正。前轮过黄虚线后轮不过。结束倒车入库。 倒车入库的时间要求是：210s（3.5min） 坡道定点停车与起步 上坡前离合要稍微踩下边一点，鼻子对准从右往左数第二第三条虚线中间开（保证左右间距）。开到差不多坡顶前，看前车窗右侧商标距离杆子还有2cm左右时踩离合与刹车停车。 拉手刹，等3s，松手刹。 踩住刹车，很缓慢地松离合直到车身抖动或发动机转速表指针往下掉了一下，方向盘稍微往左打一点防止待会压右侧线。松刹车起步。 坡道定点停车与起步无时间要求。 直角转弯 进入右直角转弯区域前需要先左转，所以先向左打死，然后提前做准备打好右转灯。 进入区域，车身正方向盘回正。等到右边门把手右端点位于黄线前1~2cm时往右打死。 车身正回正，稍微开两步继续向左打死。（右直角转弯只评判右直角，所以这里左转压线也没事） 直角转弯无时间要求。 曲线行驶 往前看并伸长脖子看引擎盖左边一个凹下出，当凹下处压线后向左打一圈，方向盘微调使凹下处沿着曲线右边线走。 保持左一圈的动作直到上述凹下处压到曲线左边界，回正，往前开。 看到雨刮器铆钉旁凹下处右侧2~3cm处与曲线左边界重合后，往右打一圈。然后往前开直到驶出曲线行驶路段。 曲线行驶无时间要求。 侧方停车 首先调整边缘线与车身差不多30cm左右的位置。然后保持车身与右边缘线这个间距平行，注意观察右后视镜，直到右后视镜中出现一个直角（侧方的库的边缘角）。 挂倒挡，后退直到直角消失迅速向右打死。 往后的同时低头观察左后视镜，看到两条虚线方向盘迅速回正。然后伸长脖子注意左后轮，压到黄虚线位置后迅速往左打死。 观察右后视镜，到车身平行入库时踩离合刹车停车。 保持左打死状态，打左转向灯，换前进档。引擎盖左侧凹下处压左边线后迅速回正。引擎盖一半压黄线时向右打一圈，车身正回正，侧方停车完成。 侧方停车的时间要求是：从挂倒挡起90s内完成。 科目三起步前准备 系好安全带 调整座椅前后位置及高度，以能轻松踩下离合与刹车、能看到引擎盖前部边缘为宜 调整内外后视镜 起步停车时应处于空挡、手刹拉好的状态。想要起步，首先应该踩死离合与刹车。打开左转向灯，等3秒后，观察后方情况。确认安全后挂一档，松手刹，松刹车，缓松离合。等待4s左右完全放掉离合（考试要求6s内），踩油门加速。 换挡首先是各挡位的速度对应： 速度 挡位 10码以下 一档 10~20码 二档 20~35码 三档 35~40码 四档 40码以上 五档 换档前，首先踩油门到挡位速度的分界线。然后松油门，踩死离合，换挡，松离合，完成换挡操作。考试要求换挡在6s内完成。 加档必须一档一档加上（比如停车时空挡再起步就只能从一档开始加上去），减档可以跳着减（只要速度挡位匹配）。 变更车道与超车先打转向灯，等待3s后观察后方情况，然后转方向盘进入另一车道。 十字路口的转向右转看地上标线，一般是有三个右转向的箭头。从近及远，第一个之前或差不多那时候打右转向灯，第二个的地方减档，紧接着是点踩刹车和左右摇头观察情况。（考试时常规要保持三档20码左右的速度，所以这里减档就是到二档）。彻底完成转向后加速回到三档。右转即走右车道，但要注意不要开到非机动车道上去。 左转类似右转，不过是“左转左车道”。 掉头我考试的情况是左右两车道，并且靠侧边的是非机动车道。所以掉头时要先借右侧辅道。 首先打右转向灯，然后减二档，等待3s观察右后方情况，确认安全后进入右侧辅道。接着关闭右转灯，打左转灯，等待3s观察左前方和左后方的情况，确认安全后往左打死。这中间可以稍微踩点刹车放慢点速度。 靠边停车首先右转向灯，打一档，等3s后观察右后方情况。确认安全后进入右边车道停车。 减速与停车减速就是踩刹车； 停车要离合刹车一起踩并且离合要踩得更快更早一点点。车停后记得挂空挡。 考试过程中，除了人行横道，其余地方都可以停车。所以善用它！ 点踩刹车与左右摇头观察这点实际开车应该都没人做吧，完全是应付考试了。需要在路口转弯、靠近人行横道、公交车站的地方做这个动作。 注意点主要是：点踩刹车不用踩太下，碰一下刹车立马抬起就行了。两次点踩刹车不要太连续，不然容易掉档。摇头的时候，幅度要大一点。 夜间灯光考试近光灯 夜间同方向近距离跟车行驶 夜间在窄桥/窄路上与非机动车会车 夜间直行通过路口 夜间在照明良好的道路上行驶 远光灯 夜间在没有路灯、照明不良的道路上行驶 远近灯光交替 夜间通过急弯/坡路/拱桥 夜间通过没有交通信号灯的路口 夜间超越前方车辆 示宽灯+双闪 路边临时停车 夜间在路口发生交通事故，妨碍交通难以移动 科目四刷了300道不到去了，大部分都是常识，相对比较好过。 附：笔者教练讲的完整流程及注意点科二 【侧方停车】(1)先调整好边缘线30公分左右，再看向右面大反光镜直角出来就停车。(2)开始挂倒挡，倒车看后右反光镜看不见直角。就向右把方向打死。(3)再看左反光镜里后面露出两条虚线把方向回正。(4)然后在看左后轮压虚线向左打死。(5)最后再看大镜车身平行刚进虚线就停。【2】出侧方位，打左转向灯。挂前进挡出库看前面左车头凹巢面挡外框黄线把方向回正。继续向前左车头当一半外面黄线时向右打一圈车身正把它回正。侧方位结束。【3】侧方位规定在挂倒挡开始90秒之内完成。【倒车入库】先看从右边数第三条虚线停在我们车中间与肩膀平行，倒车入库开始两百十秒钟完成。看左反光镜下檐 余肩膀线从合同时 向左打死方向，再看左反光镜库里面第三条虚线挡住一半时把方向回半圈。再看右面反光镜与库线平行，把方向右回正。在看左前反光镜下檐 于库角线刚从合停车。挂前档向右时看两反光镜调整出库大小。左后轮到库角向右打死，车头正回半圈。一直到肩膀停车，挂倒档看左镜子下檐于肩膀线从合向右打半圈打死。右面大反光镜库第三条虚线时一半把方向回半圈。就是等车上与地上黄线平行。把方向全部回正。就等停车看前面左反光镜檐于 库角线停车，出库调整大小左后面库角向左打死。车身正回正前轮到肩膀线。 科三 1.继续完成考试。先打左转向灯。向左回头观望。确保安全后。踩离合。挂一挡。松手刹。又手推到一点钟的位置。右脚放油门。左脚慢慢抬起离合。车子开始走动一般数四秒。把离合器全部松掉。 (记住 左脚必须在六秒钟之内。完全离合器踏板。超过六秒扣100分，行车过程中。加减档 也必须在。六秒钟内完成)，从松手下到起步 必须十秒钟内起步走哦 2.行车过程中。加速加档。10码以上加二档20码以上加三档35码以上加四档。加档只能一个一个档往上加。不能跳跃加档，减档可以速度与档位匹配时可以越档位减档。3.还有会车动作，准备会车稍微向左一点。不要压中心线。听到电脑语音指定。与机动车会车。向右靠。沿着右边线点行驶。小心右边压线。3到4秒后，电脑语音指定。结束回车。你靠中心随便行驶。会车结束以后。直接踩油门踩35码以上加四档。四挡加上去离合器放掉5秒过后，踩离合直接推三档，四档就完成了。4.超越前方车辆。电脑发出指定，你打左转向灯。向前方数三秒后，向左回头观望。头必须左后90度以上观望。确认安全后，方向稍微向左。行驶到另一个车道。等车辆完全进入另一个车道后，关闭左转向灯。车身直驶回原车道。你打开右转向灯。向前方数三秒后向右回头观望。头必须90度以上。方向稍微向右使上另一个车道，完全进入另一个车道后把转向灯关掉。5.直线行驶。一般的我教听到指令控制好方向油门踩上去。达到40km以上中间会听到我的敲门声松掉油门。。让它自由滑行。方向微调。记住必须直线行驶100米以后。会听到结束直线行驶。滑行自由行驶了，6.遇到路口一般减速减档轻点刹车左右观望。人行横道，公交车站台轻点刹车，左右观望通过。停车放空挡。7.听到适当路口掉头时，借右侧辅道先打右转向灯。减二档。三秒以后回头观望。向右进入辅道记住小心右面压边线。完全进入辅道后启左转向灯，三秒以后。向左回头观望。一把快打死掉头。8.进入对方车道路后，准备停车。打好右转向灯，记住一定要等好电脑指令。请靠边停车。可以换一挡数三秒。右回头观望后往右向右靠。注意停不进去随时随地都可以停车放空挡等， 看前小反光镜与边线30公分以内。踩离合踩刹车。放空挡拉手刹。等电脑成绩合格。才可下车。","link":"/posts/66959aa9.html"},{"title":"Hexo 在 Icarus 主题下渲染数学公式","text":"这个问题的起因是笔者写数学课笔记的时候发现本地使用 Typora 时正常可以渲染的数学公式无法在我的博客上显示。在查找资料的过程中发现 Hexo 默认渲染器不支持 LaTeX。正当我想着是否要换渲染器时，才发现我使用的 Icarus 主题只要稍微设置一下就可以渲染了。 官方文档地址：http://ppoffice.github.io/hexo-theme-icarus/Plugins/Other/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6/#MathJax 打开 _config.icarus.yml 文件，找到下面这行： 1mathjax: false 修改 mathjax 的值为 true，即变成这样： 1mathjax: true 然后在需要渲染数学公式的文档开头添加： 1mathjax: true 待解决的问题： 似乎这样的字符并不全，比如 \\Alpha 在网站上被渲染成下面那样，而非 正确的Α","link":"/posts/e201bde3.html"},{"title":"LaTeX 公式基础","text":"用 LaTeX 写数学公式的时候，总记不住一些写法，故在此记录学习笔记。 常见符号希腊字母大小写希腊字母的写法区别就在于 LaTeX 符号的首字母大小写。 若要使用斜体只要在前面加上 var 前缀，例如 \\varGamma 可以用来显示 $\\varGamma$ 。 大写字母 LaTeX 写法 小写字母 LaTeX 写法 $\\Alpha$ \\Alpha $\\alpha$ \\alpha $\\Beta$ \\Beta $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\Epsilon$ \\Epsilon $\\epsilon$ \\epsilon $\\Zeta$ \\Zeta $\\zeta$ \\zeta $\\Eta$ \\Eta $\\eta$ \\eta $\\Theta$ \\Theta $\\theta$ \\theta $\\Iota$ \\Iota $\\iota$ \\iota $\\Kappa$ \\Kappa $\\kappa$ \\kappa $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\Mu$ \\Mu $\\mu$ \\mu $\\Nu$ \\Nu $\\nu$ \\nu $\\Xi$ \\Xi $\\xi$ \\xi $\\Omicron$ \\Omicron $\\omicron$ \\omicron $\\Pi$ \\Pi $\\pi$ \\pi $\\Rho$ \\Rho $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Tau$ \\Tau $\\tau$ \\tau $\\Upsilon$ \\Upsilon $\\upsilon$ \\upsilon $\\Phi$ \\Phi $\\phi$ \\phi $\\Chi$ \\Chi $\\chi$ \\chi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega 运算符 渲染结果 LaTeX 写法 记法 $\\pm$ \\pm 英文：Plus + Minus $\\mp$ \\mp 英文：Minus + Plus $\\times$ \\times times 就有“乘”的意思 $\\div$ \\div $6 \\div 3=2$ 表述为：Six divided by two is three. $\\geq$ \\geq “大于等于”的英文：greater than or equal to $\\leq$ \\leq “小于等于”的英文：less than or equal to $\\neq$ \\neq “不等于”的英文：not equal to $\\approx$ \\approx “约等于”的英文：approximately equal to $\\propto$ \\propto “正比于”的英文：be proportional to 圈与点 渲染结果 LaTeX 写法 $\\degree$ \\degree $\\circ$ \\circ $\\cdot$ \\cdot $\\cdotp$ \\cdotp $\\cdots$ \\cdots $\\ddots$ \\ddots $\\bullet$ \\bullet $\\dot{a}$ \\dot{a} 集合相关 渲染结果 LaTeX 写法 $\\in$ \\in $\\notin$ \\notin $\\subset$ \\subset $\\subseteq$ \\subseteq $\\supset$ \\supset $\\supseteq$ \\supseteq $\\cap$ \\cap $\\cup$ \\cap $\\complement$ \\complement 上下标的输入方法上标 ^ ，下标 _，例如： 1X_1 = a^2,X_2 = b^2 $$X_1 = a^2,X_2 = b^2$$ 同时上下标，只要连续输入 _ 和 ^ 即可，例如: 1X_3^2 = 9,X_4^2 = 16 $$X_3^2 = 9,X_4^2 = 16$$ 上下标如果由多字符组成，则需要加上花括号，例如： 1X_{i+j}^{k+l} $$X_{i+j}^{k+l}$$ 左边的上下标只要写在前面就行了，例如： 1^a_bX^c_d $$^a_bX^c_d$$ 所以除了通过 \\degree 的方法写度数，也可以通过上标的方法达到类似效果： 145\\degree,90^{\\circ} $$45\\degree,90^{\\circ}$$ “上升”： 1X^{X^{X^{X^{X^{X}}}}} $$X^{X^{X^{X^{X^{X}}}}}$$ ”下降“： 1X_{X_{X_{X_{X_{X}}}}} $$X_{X_{X_{X_{X_{X}}}}}$$ 分式1\\frac{a}{b} $$\\frac{a}{b}$$ 根式 渲染结果 LaTeX 写法 $\\sqrt{2}$ \\sqrt{2} $\\sqrt[3]{2}$ \\sqrt[3]{2} 1\\sqrt[b]{a} $$\\sqrt[b]{a}$$ 其他常用符号写法 渲染结果 LaTeX 写法 记法 $\\to$ \\to $\\infty$ \\infty ”无穷“的英文：infinity $\\lim_{x \\to 0}$ \\lim_{x \\to 0} $\\bot$ \\bot $\\perp$ \\perp ”相互垂直“的英文：perpendicular to each other $\\dot{a}$ \\dot{a} $\\hat{a}$ \\hat{a} $\\bar{a}$ \\bar{a} $\\vec{a}$ \\vec{a} ”向量“的英文：vector $\\tilde{a}$ \\tilde{a} ”波浪号“的英文：tilde 参考资料 latex公式语法_ecy_uooki的博客-CSDN博客_latex公式语法 latex不等于符号_Bagba的博客-CSDN博客_latex 不等于 latex补集怎么打 - 代码先锋网 (codeleading.com) 如何用latex编写上标、下标？ - 知乎 (zhihu.com)","link":"/posts/848a7d31.html"},{"title":"大一新生的高数预备知识学习笔记","text":"这篇文章主要是笔者从宋浩老师处学习高数高数知识的课堂笔记，也加入了一些笔者自己搜到的东西。具体课程你可以看这里： 00:01:26 大一新生的高数预备知识简介 80.3万 294 视频 宋浩老师官方 反三角函数y=arcsinX y=arccosX y=arctanX y=arccotX y=secX正割是余弦的倒数：$$secX = \\frac{1}{cosX}$$ 定义域：显然$cosX \\neq 0$，所以$y=secX$的定义域为：$X\\neq k\\pi +\\frac{\\pi}{2},k\\in Z$ y=cscX 一些补充$$sec^2x=1+tan^2x,csc^2x=1+cot^2x$$ 可以使用下面的方法进行记忆： 六边形的中间是$1$。红色三角形的上边两个角的平方之和等于下边一个的平方，即：$$sin^2x+cos^2x=1$$$$tan^2x+1=sec^2x$$$$cot^2x+1=csc^2x$$ 多项式的除法 次数高的放前面，低的放后边 缺项的补出来 不带余数 带余数 有理分式的拆分何为有理分式：有理分式就是一个多项式比一个多项式 何为有理分式的拆分：将相乘的项变成相加减 过程： 极坐标基础概念首先看转动角度，其次看这个点到原点的距离。 例如：直角坐标系中$(2,2)$点在极坐标系中表示为$(2\\sqrt{2},\\frac{\\pi}{4})$；$(-2,2)$表示为$(2\\sqrt{2},\\frac{3\\pi}{4})$。 极坐标中的原点叫极点，极轴是从极点向$X$轴正方向引入的一条射线（仅正方向有）。极坐标中的点到极点的距离叫做极径，记作$\\rho(\\rho\\geq0)$（距离肯定是个非负数）；从极轴逆时针转过的角度记作$\\theta(0\\leq\\theta&lt;2\\pi)$（但实际上不一定取这个范围）。所以极坐标中一点$P$的坐标记为$P(\\rho,\\theta)$。 一般先考虑$\\theta$再考虑$\\rho$。 一些常见图像的极坐标表示 括号内范围是默认范围，可写可不写 射线例如一条以极点为端点，$\\theta=45^\\circ$的射线表述为：$$\\theta = 45^\\circ(,\\rho\\geq0)$$ 圆例如一个以极点为圆心，$1$为半径的圆表述为：$$(0\\leq\\theta&lt;2\\pi,)\\rho=1$$ 半圆例如一个以极点为圆心，$1$为半径的位于$X$轴上方的半圆表述为：$$0\\leq\\theta\\leq\\pi,\\rho=1$$ 圆面例如一个以极点为圆心，$1$为半径的圆面表述为：$$(0\\leq\\theta&lt;2\\pi,)0\\leq\\rho\\leq1$$ 半圆面例如一个以极点为圆心，$1$为半径的位于$X$轴上方的半圆面表述为：$$0\\leq\\theta\\leq\\pi,0\\leq\\rho\\leq1$$ 又例如这个以$(1,0)$为圆心，$1$为半径的位于$X$轴上方的半圆面表述为：$$0\\leq\\theta\\leq\\frac{\\pi}{2},0\\leq\\rho\\leq2cos\\theta$$ 又例如这个： 圆环","link":"/posts/33435544.html"},{"title":"VS Code 的安装与配置基础 C&#x2F;C++ 开发环境","text":"笔者以前学习 C++ 的时候，使用的是 DevCpp 。这个软件让我这个初学者比较舒服的点是，我不用太过详细地考虑编译的过程——新建一个 cpp 文件，写一点小程序，按下 F11，程序运行。我不需要管选择编译器啊、配置编译命令啊啥啥的。但是到 VS Code 这边，这都要我自己做了，只能说相当不友好。这里记录一下我配置 VS Code 的 C/C++ 环境的完整过程，希望对你有所帮助。 安装 Visual Studio Code打开 VS Code 官网，点击 Download for Windows 按钮（其他平台请选择对应平台的安装包，此处以 Windows 平台为例），等待下载完成。 国内 VS Code 下载速度慢的解决方案 此方法来自：https://zhuanlan.zhihu.com/p/112215618 在你的下载软件处（笔者这里是 IDM，你如果是浏览器下载的就去浏览器的下载管理器里找），找到下载地址。将下载地址中的 az764295.vo.msecnd.net 替换为 vscode.cdn.azure.cn，然后取消原任务，用修改过的下载链接新建一个下载。 打开安装包，一路下一步，直到下面这个界面，按照下边的进行选择，直到安装完毕。 VS Code 设置中文打开 VS Code，点击图示左侧第五个图标或使用快捷键 Ctrl+Shift+X 打开 拓展 页面，搜索：Chinese，找到 Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code 这个插件，点击 Install 安装，等待安装完成后按照提示点击右下角 Restart 按钮重启 VS Code。 安装并检查编译器DevCpp 安装的时候也帮我们安装好了编译器，但 VS Code 并没有。所以我们还得自己装一个编译器。这里以 Mingw-w64 为例（参考官方教程）。 参考 MSYS2 官网下载安装和安装。 国内 MSYS2 下载速度慢的解决方案 在这个按钮上右键，选择复制链接。 然后前往https://ghproxy.com/这个网站，粘贴上面复制的下载链接，点击下载。 打开安装包，一路默认下一步。耐心等待（国内网络可以！只要耐心等！）直到出现下面的界面： 输入下面的命令安装 gcc： 1pacman -S mingw-w64-x86_64-gcc 接下来需要添加环境变量。直接搜索 高级系统设置： 打开后点击环境变量。 添加系统变量。 打开 CMD 检查一下是否成功：输入 gcc -v，如果有结果，就安装成功了。 C/C++ 扩展的安装按照上面的方法打开扩展，首先是几个 C/C++ 基础扩展，直接搜索 C++。 第一个：C/C++ 直接点击安装（笔者这里截图的时候还没重启，如果按照上述步骤已经安装了中文语言包并重启了 Code，这里的 Install 按钮就会变成 安装）。 第二个：C/C++ Extension Pack 第三个：C/C++ Compile Run 这个扩展提供了极其简单的F6一键编译运行功能。 正常运行测试新建一个文件夹，就叫 HelloWorld 吧。打开文件夹，右键，选择 通过 Code 打开。新建一个 HelloWorld.cpp，粘贴下面的代码： 123456789#include &lt;iostream&gt;using namespace std;int main(){ cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; return 0;} Ctrl+S 保存，F6 运行，成功输出结果。 Debug2022 年 10 月 6 日更新： 完成上边的步骤之后，你应该可以正常运行程序了。下面的教程是安装调试器以及通过 C/C++ Runner 让调试等工作变得简单。 首先再次打开 msys2.exe (默认位置是：C:\\msys64\\msys2.exe)，类似上边安装 gcc ，输入下边的命令安装 gdb。类似的，还需要输入下面的命令安装 gdb: 1pacman -S mingw-w64-x86_64-gdb 然后在 VS Code 中搜索并安装 C/C++ Runner 插件。 安装 C/C++ Runner 插件时其依赖项 CodeLLDB 无法安装的解决方案 按照右下角的提示前往这里下载 codelldb-x86_64-windows.vsix文件。 在 VS Code 中按下 Ctrl + Shift + P，输入 install，选择从VSIX安装...，选择上边下好的文件，等待安装完成。 安装完成后，左下角点击 Select folder.，选择当前文件夹。 然后按下小齿轮进行编译，按下三角形运行，设置好断点按下小虫子进行 Debug。 解决中文乱码问题2022 年 10 月 13 日更新： 参见我的另一篇文章：《【已解决】VS Code 中文乱码问题》 参考资料 国内下载 vscode 速度慢问题解决 官方教程：C++ programming with Visual Studio Code windows 10 环境下 使用 msys2 + vs code 配置 c++ 的编译环境","link":"/posts/a7a0ce82.html"},{"title":"C++ 中 cin 与 cout 的转进制输入输出","text":"笔者的朋友有道输入八进制输出十进制的题目，他是使用数学方法实现的。笔者隐隐约约记得好像cin和cout有控制输入输出数字进制的方法，查找了一些资料，做一下笔记。 进制 对应缩写 二进制 bin 八进制 oct 十进制 dec 十六进制 hex 接下来只要在输入/输出的时候加上这些缩写就行了。 比如输入一个八进制数然后以十进制输出它： 1234567891011#include &lt;iostream&gt;using namespace std;int main(){ unsigned long long num; cin &gt;&gt; oct &gt;&gt; num; cout &lt;&lt; dec &lt;&lt; num &lt;&lt; endl; return 0;} 程序运行结果： 1217501000 （”1750”是输入，”1000”是输出）","link":"/posts/9e863176.html"},{"title":"补记一个用 C++ 实现的 2048 小游戏","text":"校科协的加入有条件，面试前一步是笔试。免去笔试的方法也不是没有，可以做免试题。看了各个组的免试题，发现都好难好难，只有前端组的 2048 敢去尝试尝试。但我有没怎么学过 JS，便想着先用 C++ 实现一下逻辑，再把代码改过去。 游戏规则引用免试题中的原话： 在一个 4 * 4 大小共计 16 个的方格中，初始时会有随机两个方格出现 2 / 4 ，每次通过 方向键 控制所有方块向同一个方向运动，两个相同数字的方块撞在一起之后合并成为他们的和，每次操作之后会在空白的方格处随机生成一个 2 或者 4 ，当最终得到一个 2048 的方块时即获得游戏胜利。如果16个格子全部填满并且相邻的格子都不相同也就是无法移动的话，那么 Game Over 。 写这篇博客的时候才发现原来还有”当最终得到一个 2048 的方块时即获得游戏胜利”这句话，我并没有实现这个就是说。 C++ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;conio.h&gt;using namespace std;short box_c[4][4]; // 运算用 box_content// short box_s[4][4]; // 显示用 box_showbool map[4][4]; // 用于表示是否发生过合并/*([0][0]) ([0][1]) ([0][2]) ([0][3])([1][0]) ([1][1]) ([1][2]) ([1][3])([2][0]) ([2][1]) ([2][2]) ([2][3])([3][0]) ([3][1]) ([3][2]) ([3][3])*/int getRandomNum(int min, int max){ // 这里不能srand，不然就会生成出来都是同一个随机数 return (rand() % (max - min + 1)) + min;}int getTwoOrFour(){ if (getRandomNum(1, 2) == 1) { return 2; } return 4;}void generateNewNum(){ for (int i = 0; i &lt; 1;) { int possibleI = getRandomNum(0, 3); int possibleJ = getRandomNum(0, 3); if (box_c[possibleI][possibleJ] == 0) { i++; box_c[possibleI][possibleJ] = getTwoOrFour(); } }}// 清空mapvoid map_refresh(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { map[i][j] = 0; } }}void init() // 初始化{ // 初始化随机数种子 srand(time(0)); // 初始全部赋值为0 for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { box_c[i][j] = 0; map[i][j] = 0; } } // 随机找两个位置填充2或者4 /* for (int i = 0; i &lt; 2;) { int possibleI = getRandomNum(0, 3); int possibleJ = getRandomNum(0, 3); if (box_c[possibleI][possibleJ] == 0) { i++; box_c[possibleI][possibleJ] = getTwoOrFour(); } } */ // 直接用这个函数生成两个得了 generateNewNum(); generateNewNum();}// 本来想显示运算分离的，后来感觉好像没啥必要/* void refreshShow(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { box_s[i][j] = box_c[i][j]; } }} */void show(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { cout &lt;&lt; box_c[i][j] &lt;&lt; &quot; &quot;; // cout &lt;&lt; box_s[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl;}void moveUp(){ for (int j = 0; j &lt; 4; j++) { for (int i = 3; i &gt; 0; i--) { if (box_c[i - 1][j] == 0) { box_c[i - 1][j] = box_c[i][j]; box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } if (box_c[i - 1][j] == box_c[i][j] &amp;&amp; map[i - 1][j] == 0 &amp;&amp; map[i][j] == 0) { box_c[i - 1][j] *= 2; map[i - 1][j] = 1; //标识此次合并 box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } } } generateNewNum(); map_refresh();}void moveDown(){ for (int j = 0; j &lt; 4; j++) { for (int i = 0; i &lt; 3; i++) { if (box_c[i + 1][j] == 0) { box_c[i + 1][j] = box_c[i][j]; box_c[i][j] = 0; // 将上边的全部平移过来 for (int k = i; k &gt; 0; k--) { box_c[k][j] = box_c[k - 1][j]; box_c[k - 1][j] = 0; } } if (box_c[i + 1][j] == box_c[i][j] &amp;&amp; map[i + 1][j] == 0 &amp;&amp; map[i][j] == 0) { box_c[i + 1][j] *= 2; map[i + 1][j] = 1; //标识此次合并 box_c[i][j] = 0; // 将上边的全部平移过来 for (int k = i; k &gt; 0; k--) { box_c[k][j] = box_c[k - 1][j]; box_c[k - 1][j] = 0; } } } } generateNewNum(); map_refresh();}void moveLeft(){ for (int i = 0; i &lt; 4; i++) { for (int j = 3; j &gt; 0; j--) { if (box_c[i][j - 1] == 0) { box_c[i][j - 1] = box_c[i][j]; box_c[i][j] = 0; // 将右边的全部平移过来 for (int k = j; k &lt; 3; k++) { box_c[i][k] = box_c[i][k + 1]; box_c[i][k + 1] = 0; } } if (box_c[i][j - 1] == box_c[i][j] &amp;&amp; map[i][j - 1] == 0 &amp;&amp; map[i][j] == 0) { box_c[i][j - 1] *= 2; map[i][j - 1] = 1; //标识此次合并 box_c[i][j] = 0; // 将右边的全部平移过来 for (int k = j; k &lt; 3; k++) { box_c[i][k] = box_c[i][k + 1]; box_c[i][k + 1] = 0; } } } } generateNewNum(); map_refresh();}void moveRight(){ for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 3; j++) { if (box_c[i][j + 1] == 0) { box_c[i][j + 1] = box_c[i][j]; box_c[i][j] = 0; // 将左边的全部平移过来 for (int k = j; k &gt; 0; k--) { box_c[i][k] = box_c[i][k - 1]; box_c[i][k - 1] = 0; } } if (box_c[i][j + 1] == box_c[i][j] &amp;&amp; map[i][j + 1] == 0 &amp;&amp; map[i][j] == 0) { box_c[i][j + 1] *= 2; map[i][j + 1] = 1; //标识此次合并 box_c[i][j] = 0; // 将右边的全部平移过来 for (int k = j; k &gt; 0; k--) { box_c[i][k] = box_c[i][k - 1]; box_c[i][k - 1] = 0; } } } } generateNewNum(); map_refresh();}int main(){ init(); show(); // https://www.runoob.com/w3cnote/c-get-keycode.html while (true) { if (_kbhit()) { //如果有按键按下，则_kbhit()函数返回真 int ch = _getch(); //使用_getch()函数获取按下的键值 switch (ch) { case 119: // w moveUp(); show(); break; case 97: // a moveLeft(); show(); break; case 115: // s moveDown(); show(); break; case 100: // d moveRight(); show(); break; default: break; } if (ch == 27) { break; } //当按下ESC时结束 } } return 0;} 代码阅读与分析4*4 方格的构建我创建了 box_c 这个二维数组来构建了下面这样一个棋盘来存放数据。数据值为 0 表示这个格子空着，非零则是对应数字。 1234567891011/*([0][0]) ([0][1]) ([0][2]) ([0][3])([1][0]) ([1][1]) ([1][2]) ([1][3])([2][0]) ([2][1]) ([2][2]) ([2][3])([3][0]) ([3][1]) ([3][2]) ([3][3])*/ 另外还有 map 这个二维数组，我放到后边说。 生成新的数字因为要在 4*4 的方格内随机生成 2 或者 4，所以首先就先做一个随机数生成器。 首先引入两个库： 12#include &lt;cstdlib&gt;#include &lt;ctime&gt; &lt;cstdlib&gt; 提供了 srand() 和 rand() 函数。 srand() 接受一个用于初始化的随机数”种子”。 一般我们就用当前时间time(0)作为种子。（这就是为什么我们需要引入 &lt;ctime&gt; 这个库。 ） rand() 函数会产生一个 [0,RAND_MAX]范围内的整数。通过一些算式，我们可以人为构造一些式子来实现生成需求范围内的随机数。下表展示了一些式子。 目标类型及范围 表达式 [0,n) 内的整数 rand() % n [a,b) 内的整数 (rand() % (b-a)) + a [a,b] 内的整数 (rand() % (b-a+1)) + a (a,b] 内的整数 (rand() % (b-a)) + a + 1 0～1之间的浮点数 rand() / double(RAND_MAX) 还有一个通用公式：a + rand() % n。 其中的 a 是起始值，n 是整数的范围。 注意！srand()用于初始化，只需要初始化一次。所以，你的获取随机数函数应该长得像这样： 12345678910int getRandomNum(int min, int max){ return (rand() % (max - min + 1)) + min;}int main(){ srand(time(0)); cout &lt;&lt; getRandomNum(1,100) &lt;&lt; endl; return 0;} 而不是这样： 12345678910int getRandomNum(int min, int max){ srand(time(0)); return (rand() % (max - min + 1)) + min;}int main(){ cout &lt;&lt; getRandomNum(1,100) &lt;&lt; endl; return 0;} 错误的写法会导致快速生成随机数时每次返回的都是随机数序列的第一个… （可能是程序运行速度很快种子都是一样的结果）。 接着我定义了 getTwoOrFour() 和 generateNewNum() 函数。前者用于随机生成 2/4，不必多说。后者用于在 4*4 方格内随机放上一个数字，首先生成行列坐标，如果检查到这个格子空的，可以生成在这，那就生成，结束该函数的运行，否则进行下一次尝试。 12345678910111213141516171819202122int getTwoOrFour(){ if (getRandomNum(1, 2) == 1) { return 2; } return 4;}void generateNewNum(){ for (int i = 0; i &lt; 1;) { int possibleI = getRandomNum(0, 3); int possibleJ = getRandomNum(0, 3); if (box_c[possibleI][possibleJ] == 0) { i++; box_c[possibleI][possibleJ] = getTwoOrFour(); } }} 初始化初始化主要就是两方面：一方面是初始化随机数种子；另一方面是清空棋盘（其实还有清空 map 标记），然后随机找两个位置放上 2 或者 4。 1234567891011121314151617void init() // 初始化{ // 初始化随机数种子 srand(time(0)); // 初始全部赋值为0 for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { box_c[i][j] = 0; map[i][j] = 0; } } // 随机找两个位置填充2或者4 generateNewNum(); generateNewNum();} 移动与合并 注意这里的移动与合并算法可能不是最优解，可能比较低效，甚至可能有错误。仅供参考。 移动无非就是上下左右，彼此之间比较类似。这里以向上移动为例： 12345678910111213141516171819202122232425262728293031323334void moveUp(){ for (int j = 0; j &lt; 4; j++) { for (int i = 3; i &gt; 0; i--) { if (box_c[i - 1][j] == 0) { box_c[i - 1][j] = box_c[i][j]; box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } if (box_c[i - 1][j] == box_c[i][j] &amp;&amp; map[i - 1][j] == 0 &amp;&amp; map[i][j] == 0) { box_c[i - 1][j] *= 2; map[i - 1][j] = 1; //标识此次合并 box_c[i][j] = 0; // 将下边的全部平移过来 for (int k = i; k &lt; 3; k++) { box_c[k][j] = box_c[k + 1][j]; box_c[k + 1][j] = 0; } } } } generateNewNum(); map_refresh();} 首先因为是向上移动，所以先拆分一下上边的二维数组，拆成四列。第一层 j 的循环就是列的循环。 在某一列中，我想从下往上考虑：如果上面一个格子是 0 ，那我就把现在这个格子里的数字上移；如果这个位置和上边位置的数一样，我就让上边位置的数乘二，然后下边位置赋0。不断从下往上扫描直到能移动的全部移动，能合并的全部合并。 但是有个问题是，每次移动各个数字只能发生一次合并！如果这个数字合并过了，那它就不应该再合并了。比如四个2,移动一次应该产生两个4而非1个8。 所以我创建了一个 map ，用于标识已经发生的合并。并且取消掉了之前的不断的从上到下的扫描，改为了如果发生了一次移动或者合并，即给当前格子进行了赋0操作的话，我就把下边的所有格子往上移动一次。 总结一下思路：如果以 0,1,2,3 从上往下标识这一列格子。我从 3 往上扫描到 1 ，如果发现当前格子是 0，也即上边格子空着，我就把这个格子开始下边的所有格子往上移动一位；类似的，如果发现上边格子和当前格子可以合并，并且查询 map 发现这两个格子里边的数字在这轮移动中都没有发生过合并，那就合并，并也将下边格子的内容全部往上移动。 当四列都结束后，便用 generateNewNum() 填充一个新数字，并且清空 map 的状态。 结束检测这个 C++ 代码中这块并没有实现，不过最后的 Web 版本是实现了的。借一下那边的代码讲一下思路吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ifEnd: function () { console.log(&quot;正在检测游戏是否结束！&quot;); var flag = 0; for (var i = 0; i &lt; 4; i++) { for (var j = 0; j &lt; 4; j++) { // 如果有空位，说明必定可以继续 if (box_c[i][j] == 0) { flag = 1; console.log(&quot;检测到游戏仍然有空位，游戏继续！&quot;); break; } } if (flag == 1) { break; } } // 为0则说明没有空位了 if (flag == 0) { console.log(&quot;检测到游戏没有空位了，下面检测是否有可合并方块！&quot;); var flag2 = 0; for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { if ((box_c[i][j] == box_c[i][j + 1]) || (box_c[i][j] == box_c[i + 1][j])) { flag2 = 1; console.log(&quot;检测到可合并方块，游戏继续！&quot;); break; } } if (flag2 == 1) { break; } } // 最后一列单独检测 for (var i = 0; i &lt; 3; i++) { if (box_c[i][3] == box_c[i + 1][3]) { flag2 = 1; console.log(&quot;检测到可合并方块，游戏继续！&quot;); break; } } // 最后一行单独检测 for (var j = 0; j &lt; 3; j++) { if (box_c[3][j] == box_c[3][j + 1]) { flag2 = 1; console.log(&quot;检测到可合并方块，游戏继续！&quot;); break; } } if (flag2 == 0) { console.log(&quot;检测到游戏无空位且无法继续移动，游戏结束！&quot;); alert('游戏结束，即将重新开始！'); location.reload(); } } } 游戏结束的标志是两个：一是没有空格子了，二是任意相邻格子没有相同数字不可能发生合并了。 所以首先就是扫描所有格子看看有没有空格子。如果没有格子，就开始扫描相邻格子是否有相同数字。我的扫描方法是从(0,0)到(2,2)都只检测它的右方和下方是否与它相同，然后再单独检测一下最右边一列前三个元素的下一个和最下边一行前三个元素的右边一个是否与它们自己相同。如果也没有相同的了，那就 Game Over 。 获取键盘输入直接看参考资料《C/C++ 获取键盘事件》吧… 参考资料《C++产生随机数》《C/C++ 获取键盘事件》… …","link":"/posts/10d14c30.html"},{"title":"Icarus 主题自带的标签插件的使用以及官方文档中的常用消息框模板","text":"之前有写过使用 Bulma 美化博文的方法，然后才发现原来 Icarus 本身就带了很多标签插件可供直接使用。而官方文档中的横跨文章的提示框、警告框什么的我找遍了文档也没发现作者告诉我了调用的办法，直到今天才看到大佬的一篇文章讲到原来那些本身就是用原生 html 写的。所以写下此篇笔记，方便以后用。 官方自带标签插件官方文档：《自定义Hexo标签插件 - Icarus》 消息框语法定义123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %} &lt;内容&gt;{% endmessage %} 参数解释color(颜色)可选参数，可能值、实现方法和效果见下方： 123{% message title:default %} 一个没有设置颜色的消息框。{% endmessage %} default 一个没有设置颜色的消息框。 123{% message color:dark title:dark %} 一个深色(dark)的消息框。{% endmessage %} dark 一个深色(dark)的消息框。 123{% message color:primary title:primary %} 一个主题色(primary)的消息框。{% endmessage %} primary 一个主题色(primary)的消息框。 123{% message color:info title:info %} 一个提示色(info)的消息框。{% endmessage %} info 一个提示色(info)的消息框。 123{% message color:success title:success %} 一个成功色(success)的消息框。{% endmessage %} success 一个成功色(success)的消息框。 123{% message color:warning title:warning %} 一个警告色(warning)的消息框。{% endmessage %} warning 一个警告色(warning)的消息框。 123{% message color:danger title:danger %} 一个危险色(danger)的消息框。{% endmessage %} danger 一个危险色(danger)的消息框。 size(尺寸)可选参数，可能值、实现方法和效果见下方： 123{% message size:small title:small %} 一个小(small)消息框。{% endmessage %} small 一个小(small)消息框。 123{% message title:default %} 一个默认大小的消息框。{% endmessage %} default 一个默认大小的消息框。 123{% message size:medium title:medium %} 一个中(medium)消息框。{% endmessage %} medium 一个中(medium)消息框。 123{% message size:large title:large %} 一个大(large)消息框。{% endmessage %} large 一个大(large)消息框。 icon(图标)可选参数，来源 FontAwesome，类名中间含空格的加引号！ 一些例子： 123{% message color:success icon:&quot;fa-solid fa-circle-check&quot; title:&quot;fa-solid fa-circle-check&quot; %} 一个外部带圈的勾。{% endmessage %} fa-solid fa-circle-check 一个外部带圈的勾。 123{% message color:warning icon:&quot;fa-solid fa-triangle-exclamation&quot; title:&quot;fa-solid fa-triangle-exclamation&quot; %} 一个警告标志。{% endmessage %} fa-solid fa-triangle-exclamation 一个警告标志。 123{% message color:danger icon:&quot;fa-solid fa-circle-exclamation&quot; title:&quot;fa-solid fa-circle-exclamation&quot; %} 一个错误标志。{% endmessage %} fa-solid fa-circle-exclamation 一个错误标志。 title(标题)可选参数，中间含空格的加引号！ 有标题的上面已经演示过，下面是各种没有标题的消息框。 123{% message %} 一个没有设置颜色的消息框。{% endmessage %} 一个没有设置颜色的消息框。 123{% message color:dark %} 一个深色(dark)的消息框。{% endmessage %} 一个深色(dark)的消息框。 123{% message color:primary %} 一个主题色(primary)的消息框。{% endmessage %} 一个主题色(primary)的消息框。 123{% message color:info %} 一个提示色(info)的消息框。{% endmessage %} 一个提示色(info)的消息框。 123{% message color:success %} 一个成功色(success)的消息框。{% endmessage %} 一个成功色(success)的消息框。 123{% message color:warning %} 一个警告色(warning)的消息框。{% endmessage %} 一个警告色(warning)的消息框。 123{% message color:danger %} 一个危险色(danger)的消息框。{% endmessage %} 一个危险色(danger)的消息框。 标签页语法定义123456789{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} 参数说明上面重复的参数用法类似，不再解释，下面看上面没有出现过的参数。 id必选参数，具有唯一性，整个文档中不可重复。 align(对齐方法)可选参数，可能值、实现方法和效果见下方： 12345678910{% tabs %}&lt;!-- tab id:page1-1 title:第一页 active --&gt;(没有对齐参数)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page1-2 title:第二页 --&gt;(没有对齐参数)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (没有对齐参数)这是标签页 1 (没有对齐参数)这是标签页 2 12345678910{% tabs align:centered %}&lt;!-- tab id:page2-1 title:第一页 active --&gt;(对齐参数：centered)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page2-2 title:第二页 --&gt;(对齐参数：centered)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (对齐参数：centered)这是标签页 1 (对齐参数：centered)这是标签页 2 12345678910{% tabs align:right %}&lt;!-- tab id:page3-1 title:第一页 active --&gt;(对齐参数：right)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page3-2 title:第二页 --&gt;(对齐参数：right)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (对齐参数：right)这是标签页 1 (对齐参数：right)这是标签页 2 12345678910{% tabs align:fullwidth %}&lt;!-- tab id:page4-1 title:第一页 active --&gt;(对齐参数：fullwidth)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page4-2 title:第二页 --&gt;(对齐参数：fullwidth)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (对齐参数：fullwidth)这是标签页 1 (对齐参数：fullwidth)这是标签页 2 style(样式)可选参数，可能值、实现方法和效果见下方： 12345678910{% tabs %}&lt;!-- tab id:page5-1 title:第一页 active --&gt;(样式：默认)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page5-2 title:第二页 --&gt;(样式：默认)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：默认)这是标签页 1 (样式：默认)这是标签页 2 12345678910{% tabs style:boxed %}&lt;!-- tab id:page6-1 title:第一页 active --&gt;(样式：boxed)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page6-2 title:第二页 --&gt;(样式：boxed)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：boxed)这是标签页 1 (样式：boxed)这是标签页 2 12345678910{% tabs style:toggle %}&lt;!-- tab id:page7-1 title:第一页 active --&gt;(样式：toggle)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page7-2 title:第二页 --&gt;(样式：toggle)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：toggle)这是标签页 1 (样式：toggle)这是标签页 2 12345678910{% tabs style:toggle-rounded %}&lt;!-- tab id:page8-1 title:第一页 active --&gt;(样式：toggle-rounded)这是标签页 1&lt;!-- endtab --&gt;&lt;!-- tab id:page8-2 title:第二页 --&gt;(样式：toggle-rounded)这是标签页 2&lt;!-- endtab --&gt;{% endtabs %} 第一页 第二页 (样式：toggle-rounded)这是标签页 1 (样式：toggle-rounded)这是标签页 2 官方文档中的横跨文章的提示框、警告框等摘自官网的一些： 1234567{% raw %}&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译：&lt;a href=&quot;/hexo-theme-icarus/uncategorized/custom-hexo-tag-helpers/&quot;&gt;English&lt;/a&gt;。&lt;/div&gt;&lt;/article&gt;{% endraw %} 本文同时提供以下语言的翻译：English。 123456789{% raw %}&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-lightbulb mr-2&quot;&gt;&lt;/i&gt;The following content is taken from &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://hexo.io/docs/tag-plugins.html&quot;&gt;Hexo documentation&lt;/a&gt;with minor revisions.&lt;/div&gt;&lt;/article&gt;{% endraw %} The following content is taken from Hexo documentation with minor revisions. 1234567{% raw %}&lt;article class=&quot;message message-immersive is-warning&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？请点击&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/ppoffice/hexo-theme-icarus/edit/site/source/_posts/zh-CN/CDN-Providers.md&quot;&gt;此处&lt;/a&gt;提交修改。&lt;/div&gt;&lt;/article&gt;{% endraw %} 文章内容有误？请点击此处提交修改。 还有更多参数请见：《Icarus消息框模板 - Astroblog》","link":"/posts/8ffe9166.html"},{"title":"C 语言中与(&amp;&amp;)和或(||)运算符的短路运算","text":"此篇笔记来源于下边的这个题目。 本来以为结果为 3，但是实际跑了一下发现结果是 1。请教了一下大佬知道了这叫做或运算符（||）的短路运算。 正常来说，或运算中只要有一个为真，结果就为真。所谓或的短路运算就是说，如果已经出现了真，那么后续的运算就不会进行了。以上面的题目为例就是，因为第一个 ++x 这个运算结果肯定为真，那么后面的另外两个 ++x 就不会运行。 类似的，还有与（&amp;&amp;）的短路运算。正常来说，与运算中必须所有均为真，结果才为真。所以与的短路就是，如果前面的运算结果已经有假了，那么就可以确定这个与运算总体的结果为假，也就不会运行后边的运算了。","link":"/posts/13d09bbb.html"},{"title":"挖老婆矿！—— NovelAI 初试","text":"最近一段时间，感觉突然之间，就有很多很多将现实图片二次元化啊，按照每句歌词生成一副画作啊的 AI 绘画应用的图文视频出现。和室友聊天还说是不是最近一段时间 AI 技术突破什么瓶颈突飞猛进了。后来才知道，原来是 NovelAI 泄露了… 这样一来，本地部署方便了起来，于是整了一个玩玩。由于跑 AI 嘛，GPU 比较呼啸，跟挖矿一样，我就戏称我这是在“挖老婆矿”了。 注：这篇文章更偏向于我记录生成时使用的 tag， 不涉及基础操作。我使用的 NovelAI 下载自这里。 一个头像（一堆头像）我最开始只是用几个 tag 生成。经历了一些粗浅的尝试后，发现生成的质量并不高。但是看到了一篇文章，照着里边的 tag 写，才算真正开始了探索。 首先是根据上边那篇文章最后的示例增改了点 tag 形成的 prompt: 1blue pen illustration, light blue background, flowers on face, growth, nature, beautiful face, pink hair,shawl hair, zoom in on eyes, apathy, red eye shadow, petite, best quality, masterpiece 然后生成出了下面这些相当不错的图案： 下边分类讲讲 tag: 提高总体质量的： 1masterpiece, best quality, by famous artist, beautiful face 使整体的风格偏向更具插画感： 1illustration 限定背景的： 1xxxx + backgroud (比如上边的淡蓝色背景就是 light blue background ) 让生成出来的 waifu 更幼的： 1petite 让脸上、头发上出现花朵装饰的： 1flowers on face 让眼睛更大的： 1zoom in one eyes 尝到了甜头后，我就想换头像了。但我不想完全抛弃现在的头像，于是就试图拿它做派生。 首先描述一下原来的头像，让 AI 知道我大概是想要怎样的一个 “老婆”。（虽然其实我描述的时候更感觉是在捏女儿） 顺便一说，我这个原来的头像其实也是 AI 生成的，叫 WaifuLabs，是我把原来生成出来的丢进 PS 去了水印，又自己修缮了一下得到的。 抛却那些提高质量的，大概给了 披肩发、深灰色头发、深灰色眼睛、红色眼影、白色衬衫、微笑 这些 tag。同时模仿了上边，给了 面部的花 之类的 tag： 1{{masterpiece,best quality}},shawl hair,dark grey hair, dark grey eyes,red eye shadow, white shirt,illustration,flower on face,growth, nature,beautiful face, smile, zoom in one eyes 以上边的内容为 prompt，同时把我改的那张扔给 NovelAI，根据生成结果又慢慢改，添加 tag，最终的 prompt 如下: 1{{masterpiece,best quality,by wlop}},shawl hair,dark grey hair, dark grey eyes,red eye shadow, white shirt,{{{illustration}}},flower on face, growth, nature, beautiful face, small smile, zoom in one eyes, {{{{petite}}}}, dramatic shadows, ink,eye-focus, portrait, red hairclip 跑了大概 100 张，然后挑了挑，下边展示的是部分高质量的： 又是一波奇奇怪怪的调整： 最后挑选出了这张我觉得挺有特色的： 然后开始根据这张进行派生： 一张壁纸（一堆壁纸）这事儿开始的挺搞笑的，当时我正在调上边的头像参数，坐我旁边玩 CSGO 的朋友希望我把某把枪拟人，然后发我了下边的图片： 然后我加了点描述词生成了，但生成效果并不好，我就又开始研究我上边的头像了。我完全忘记了我还拿着这张图生成的某张图在做派生呢… 我只是改回了我的 prompt，就意外地得到了下边这张图： 似乎是把枪头画成了那条条纹？我也不知道。反正着实是惊艳到我了，扔到 bigjpg 那边提高了一下分辨率，再扔进 PS 调了一下曲线，嘿嘿，新的手机壁纸有了！ 然后又拿这张图和基于上边改的 prompt 做了派生… 1{{masterpiece,best quality}},shawl hair,dark grey hair, dark grey eyes,red eye shadow,red scanf, light grey shirt,{{illustration}},red flower on face,white flower on hair,growth, nature,beautiful face, {{indifferent}}, zoom in one eyes,1girl, red flower background, gold fence background,focus on eye 相当不错！","link":"/posts/f17b3e8b.html"},{"title":"一个有关指针传参的问题","text":"这是我学习指针过程中遇到的一个问题，问过大佬才似乎懂了点，在此记录。顺便记下一句大佬说的话： 注意到一点就行，指针其实也就是个存了内存地址的变量，它本身同时也具有内存地址。 问题的产生事情是这样，学习了一点指针，就想自己实现一个会自动变长的数组。我也不期望把它做成一个类什么的，只有一个小目标，就是实现一个函数，能往这个动态数组后边加元素。我本来的 错误 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;void append(int *nums, int size, int n){ if (nums) // 如果数组指针不为空 { // 暂存原来的数据 int *tmp_nums = new int[size]; memcpy(tmp_nums, nums, sizeof(int) * size); // 释放掉原指针 delete[] nums; // 元素数量 + 1 nums = new int[size + 1]; memcpy(nums, tmp_nums, sizeof(int) * size); nums[size] = n; delete[] tmp_nums; } else { nums = new int[1]; nums[0] = n; }}int main(){ int tmp_n; int size = 0; int *nums = nullptr; for (int i = 51; i &lt;= 55; i++) { tmp_n = i; append(nums, size, tmp_n); size++; } for (int i = 0; i &lt; size; i++) { cout &lt;&lt;nums[i] &lt;&lt; &quot; &quot;; } return 0;} 在调试过程中发现一直会报 Segmentation fault，但是如果改成下边这样，却是可以的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int *nums = nullptr;void append(int size, int n){ if (nums) // 如果数组指针不为空 { // 暂存原来的数据 int *tmp_nums = new int[size]; memcpy(tmp_nums, nums, sizeof(int) * size); // 释放掉原指针 delete[] nums; // 元素数量 + 1 nums = new int[size + 1]; memcpy(nums, tmp_nums, sizeof(int) * size); nums[size] = n; delete[] tmp_nums; } else { nums = new int[1]; nums[0] = n; }}int main(){ int tmp_n; int size = 0; for (int i = 51; i &lt;= 55; i++) { tmp_n = i; append(size, tmp_n); size++; } for (int i = 0; i &lt; size; i++) { cout &lt;&lt;nums[i] &lt;&lt; &quot; &quot;; } return 0;} 改动的内容就是把原来的数组变成了全局的。局部的不正常，全局就对了，所以猜测，类似是形参和实参的区别。大佬们帮我分析了分析，提出了下边的解决方案： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;void append(int **, int, int);int main(){ int tmp_n; int size = 0; int *nums = nullptr; for (int i = 51; i &lt;= 55; i++) { tmp_n = i; /* nums 是一个指针，这个指针是我们动态数组的第一个元素的地址 对 nums 取地址传参，传的是 nums 这个指针的地址 */ append(&amp;nums, size, tmp_n); size++; } for (int i = 0; i &lt; size; i++) { cout &lt;&lt;nums[i] &lt;&lt; &quot; &quot;; } return 0;}/*接上文的注释ptr 是一个指针，这个指针是上边的 nums 的地址*ptr 得到了这个地址的值，这个值是指向动态数组第一个元素的指针**ptr 是第一个元素的值*/void append(int **ptr, int size, int n){ if (*ptr) // 如果数组指针不为空 { // 暂存原来的数据 int *tmp_nums = new int[size]; memcpy(tmp_nums, *ptr, sizeof(int) * size); // 释放掉原指针 delete[] * ptr; // 元素数量 + 1 *ptr = new int[size + 1]; memcpy(*ptr, tmp_nums, sizeof(int) * size); (*ptr)[size] = n; delete[] tmp_nums; } else { (*ptr) = new int[1]; (*ptr)[0] = n; }} 这样运行结果就正常了。 分析及解决方案2022 年 11 月 16 日更新：这边写的错误原因有点乱，我重新写了一篇：《当形参、实参是指针变量…》 下边给出两个简化的代码来解释这个问题。 首先来看代码 1，是对上边错误代码的简化: 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void getMemory(int *p){ p = new int; cout &lt;&lt;&quot;The pointer in getMemory() points at:&quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt;&quot;The address of the pointer in getMemory():&quot; &lt;&lt; &amp;p &lt;&lt; endl;}int main(){ int *p; getMemory(p); cout &lt;&lt;&quot;The pointer in main() points at:&quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt;&quot;The address of the pointer in main():&quot; &lt;&lt; &amp;p &lt;&lt; endl; delete p; return 0;} 下边是代码 1 对应的程序的一个可能的输出 (具体内存地址可能不同): 1234The pointer in getMemory() points at: 0x10161c0The address of the pointer in getMemory(): 0x61fdf0The pointer in main() points at: 0x10The address of the pointer in main(): 0x61fe18 可以看到，在 getMemory() 中的 int* 类型的指针 p 与 main() 中的 int* 类型的指针 p 并不是同一个指针（存储这两个指针的内存地址不一样，在 getMemory() 中的指针 p 存储在 0x61fdf0，而 main() 中的存储在 0x61fe18），所以虽然我们在 getMemory() 中 new 得了存储空间（getMemory() 中的指针 p 指向了 0x10161c0），但这实际上只是为 getMemory() 中的指针 p 申请了存储空间，main() 中的指针 p 并没有申请到空间（main() 中的指针 p 指向了 0x10）。 也即，我们自己的函数中的指针是一个副本，给这个指针申请空间的操作并没有实现给 main() 中的同名指针也申请到空间！ 接着是代码 2，类似于上边的正确解法： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void getMemory2(int **p2){ *p2 = new int; cout &lt;&lt; &quot;The pointer in getMemory() points at:&quot; &lt;&lt; *p2 &lt;&lt; endl; cout &lt;&lt; &quot;The address of the pointer in getMemory():&quot; &lt;&lt; p2 &lt;&lt; endl;}int main(){ int *p1; getMemory2(&amp;p1); cout &lt;&lt; &quot;The pointer in main() points at:&quot; &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; &quot;The address of the pointer in main():&quot; &lt;&lt; &amp;p1 &lt;&lt; endl; delete p1; return 0;} 下边是代码 2 对应的程序的一个可能的输出 (具体内存地址可能不同): 1234The pointer in getMemory() points at: 0x7461c0The address of the pointer in getMemory(): 0x61fe18The pointer in main() points at: 0x7461c0The address of the pointer in main(): 0x61fe18 从 main() 开始看，p1 是一个 int* 类型的指针。与上边代码 1 不同，现在 getMemory2() 这个函数接受的参数是指针的指针，也就是指针的地址，所以我们传入的是 &amp;p1，也就是指针 p1 的地址。 再看 getMemory2() 函数，传入参数后，相当于现在 p2 = &amp;p1，那么 *p2 = p1。这里的 “=” 表示 “就是” 而非赋值，所以我们对于 *p2 进行的任何操作，与对 p1 进行的操作都是等效的。 还有一种解决方案 —— 使用引用传递，对于上边的问题也就是使用 int* &amp; 类型，代码 3 如下： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void getMemory(int *&amp;p){ p = new int; cout &lt;&lt; &quot;The pointer in getMemory() points at: &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;The address of the pointer in getMemory(): &quot; &lt;&lt; &amp;p &lt;&lt; endl;}int main(){ int *p; getMemory(p); cout &lt;&lt; &quot;The pointer in main() points at: &quot; &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &quot;The address of the pointer in main(): &quot; &lt;&lt; &amp;p &lt;&lt; endl; delete p; return 0;} 只要将上边的代码 1 中 void getMemory(int *p) 改为 void getMemory(int *&amp;p) 就行了，下边是可能的输出： 1234The pointer in getMemory() points at: 0x10261c0The address of the pointer in getMemory(): 0x61fe18The pointer in main() points at: 0x10261c0The address of the pointer in main(): 0x61fe18 可以看到已经实现了我们想要的效果。 也可以参考参考这篇文章：《C++ 函数的传入参数是指针的指针（**）的详解》","link":"/posts/50c16b14.html"},{"title":"C&#x2F;C++ 中赋值语句的返回值问题","text":"我曾经一直以为 C/C++ 中赋值语句的返回值不是 0 就是 1 —— 成功执行赋值操作返回 1，没有成功执行就返回 0。直到今天课上的一个例子，才让我知道，原来赋值语句的返回值就是赋的值的大小！ 起因是下边的这道题目： 12345678910111213141516171819202122int i;// 下边各个循环的执行次数是多少：// 1: 死循环for (i = 0;; i++){ printf(&quot;%d&quot;, i);}// 2：0 次循环for (; i = 0; i++){ printf(&quot;%d&quot;, i);}// 3：0 次循环for (i = 0; i &lt; 0; i++){ printf(&quot;%d&quot;, i);}// 4：死循环while (i = 1){ i++;} 第一个因为 for 语句的第二个参数缺失，所以该循环不会停止；第三个初值i=0;即不满足i&lt;0;，故不执行。 第四个，按照我错误的理解，赋值成功返回 1，所以说得通是while(true)永远执行，但四二个却无法这么解释了。去试了试写个下边两个东西输出赋值语句的返回值，才发现原来赋值语句的返回值就是赋的值。 C 代码： 12345678910#include &lt;stdio.h&gt;int main(){ int a = 0, b = 5, c = -5, d; printf(&quot;%d\\n&quot;, (int)(d = a)); printf(&quot;%d\\n&quot;, (int)(d = b)); printf(&quot;%d\\n&quot;, (int)(d = c)); return 0;} C++ 代码： 123456789101112#include &lt;iostream&gt;using namespace std;int main(){ int a = 0, b = 5, c = -5, d; cout &lt;&lt; int(d = a) &lt;&lt; endl; cout &lt;&lt; int(d = b) &lt;&lt; endl; cout &lt;&lt; int(d = c) &lt;&lt; endl; return 0;} 输出结果均如下： 12305-5","link":"/posts/9693ba6.html"},{"title":"C 语言中使用变量输出小数点位数","text":"这事儿要从一周前讲起，有人在群里问了这么一道题，要求用 C 实现： 习题 2-5 分数化小数（decimal）输入正整数 a,b,c，输出 a/b 的小数形式，精确到小数点后 c 位。a,b&lt;=10^6，c&lt;=100。输入包含多组数据，结束标记为 a=b=c=0。样例输入：1 6 40 0 0样例输出：0.1667 当时我做了个简化的版本 —— 最多处理 1000 组输入，并且 c 比较小（即不需要高精度）的情况的代码，主要是做一个字符串处理，来构造一个传给 printf() 的格式控制字符串，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // 需要用到它的 itoa() 函数#include &lt;string.h&gt; // 用到strcat拼接字符数组，memset清空字符数组int main(){ // 仅实现了最多有 1000 个输入的情况 unsigned int a[1000], b[1000], c[1000], cnt = 0; double ans[1000]; for (int i = 0;; i++) { if (cnt == 1000) { break; } scanf(&quot;%u%u%u&quot;, &amp;a[i], &amp;b[i], &amp;c[i]); cnt++; if (!(a[i] == 0 &amp;&amp; b[i] == 0 &amp;&amp; c[i] == 0)) { if (b[i] != 0) { ans[i] = a[i] * 1.0 / b[i]; } } else { break; } } for (int i = 0; i &lt; cnt - 1; i++) { char formatMsgP1[] = &quot;%.&quot;; char *formatMsgP2; // 根据位数动态确定 char 数组的大小 if (c[i] &gt; 99) { formatMsgP2 = malloc(sizeof(char) * 3); } else if (c[i] &gt; 9) { formatMsgP2 = malloc(sizeof(char) * 2); } else { formatMsgP2 = malloc(sizeof(char)); } itoa(c[i], formatMsgP2, 10); char formatMsgP3[] = &quot;lf\\n&quot;; char formatMsg[20]; strcat(formatMsg, formatMsgP1); strcat(formatMsg, formatMsgP2); strcat(formatMsg, formatMsgP3); printf(formatMsg, ans[i]); memset(formatMsg, 0, sizeof(formatMsg)); // 清空数组 free(formatMsgP2); // 释放指针 } return 0;} 这样的代码就比较麻烦，大量的代码都用在字符串拼接了。但今天看到一篇文章（《使用变量设定小数点位数》），才知道原来根本不需要那么麻烦。 本来我的目标是构造这么一个格式控制字符串 %.&lt;c&gt;lf，其中 &lt;c&gt; 需要由用户输入。上边的思路就是输入数字之后用 itoa() 函数把输入的数字转成字符串，然后拼一拼。 但实际上可以这样： 1printf(&quot;%.*lf&quot;, c[i], ans[i]); 使用 *，printf() 就知道了，需要去后边找这么一个参数。 所以上边 return 0; 前面那个 for 里那么多东西都只要换成这一句就行了。 下边贴出一个用动态数组实现的任意组数数据输入的代码（依然没有高精度，我不会啊）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct NUMS{ unsigned int c; double ans;};struct NUMS *p = 0;unsigned long long size = 0;void append(unsigned int, double);int main(){ int a = 0, b = 0, c = 0; do { scanf(&quot;%u%u%u&quot;, &amp;a, &amp;b, &amp;c); if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) break; else { double tmp_ans = a * 1.0 / b; append(c, tmp_ans); } } while (1); for (int i = 0; i &lt; size; i++) { printf(&quot;%.*lf\\n&quot;, (p + i)-&gt;c, (p + i)-&gt;ans); } return 0;}void append(unsigned int _c, double _ans){ if (p == 0) { p = calloc(1, sizeof(struct NUMS)); p-&gt;c = _c; p-&gt;ans = _ans; size++; } else { struct NUMS *tmp = calloc(size, sizeof(struct NUMS)); memcpy(tmp, p, sizeof(struct NUMS) * size); free(p); p = calloc(size + 1, sizeof(struct NUMS)); memcpy(p, tmp, sizeof(struct NUMS) * (size + 1)); (p + size)-&gt;c = _c; (p + size)-&gt;ans = _ans; size++; free(tmp); }}","link":"/posts/45e2d42.html"},{"title":"二维数组到底是啥啊...","text":"一维数组还是比较容易理解的，但是二维数组，我始终没弄清楚这玩意儿是按照什么规则从二维的样子转成一维然后存起来的，也因此常常犯下下标写反了的错误。我觉得是时候详细地理一理这玩意儿到底是个啥了… 怎么转成了一维？要知道二维数组到底是怎么转成了一维存在内存里，或者说，我到底是应该从前往后（前面的一个数字先不动，先让后边的数字动）读这个数组，还是从后往前（后面的一个数字先不动，先让前面的数字动）读这个数组，其实方法很简单 —— 我们只要把数组里每个元素的地址输出来就行了。比如下边这串代码： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main(){ int a[2][3] = {0}; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 3; j++) { cout &lt;&lt; &quot;&amp;a[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot;[&quot; &lt;&lt; j &lt;&lt; &quot;] = &quot; &lt;&lt; &amp;a[i][j] &lt;&lt; &quot; &quot; &lt;&lt; endl; } } return 0;} 可能的输出如下： 123456&amp;a[0][0] = 0x61fe00&amp;a[0][1] = 0x61fe04&amp;a[0][2] = 0x61fe08&amp;a[1][0] = 0x61fe0c&amp;a[1][1] = 0x61fe10&amp;a[1][2] = 0x61fe14 可以看到，正确的读法应该是：从前往后，前面的保持不动，从最后一个开始变化。 也就是说，对于 a[2][3] 这样一个数组，应该这么理解：a[2][3] 前面的 [2] 表示这是一个包含两个元素的数组，后面的 [3] 表示前面所说的两个元素每一个都是包含三个元素的数组。 赋初值的一些问题知道了上边的东西，所以我们知道，我们可以写一个类似 int a[][3] = {0,0,0,0,0,0}; 的玩意儿，却不能写一个 int a[2][] = {0,0,0,0,0,0} 的玩意儿 —— 相当于第二个方括号里边是告诉了编译器后边这一串数字按几个为一组，由于 {} 中元素个数不足是会往后边自动补零的，所以少了这个每组几个的参数，编译器就不知道你这到底有多少个元素了。 用指向数组的指针（数组指针）来实现一个其中一维可以动态调整的二维数组？类似上边的赋初值时候的问题，这个动态的二维数组的内层，也就是按几个为一组的那一层，必须是已经确定的，例如，我们依然创建一个 2*3 的二维数组，其中前面的 2 是在运行时确定的： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main(){ int n = 2; int(*p)[3] = new int[n][3]; int now = 1; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; 3; j++) { p[i][j] = now; now++; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 3; j++) cout &lt;&lt; p[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } return 0;} 输出结果如下: 121 2 34 5 6 能不能用 int** p 来创建一个两个维度都能变化的二维数组？不知道啊就是说…","link":"/posts/57fd79a.html"},{"title":"值传递、指针传递、引用传递","text":"接上文《一个有关指针传参的问题》，打算结合一些简单的例子系统地梳理一下 C/C++ 中的值传递、指针传递和 C++ 中特有的 引用传递。 值传递值传递传递实际上只是在执行函数的时候将实参的值赋给了形参，在此之后函数体内对形参的任何操作都与原来的实参无关了。 例如下边这个代码 1: 1234567891011121314151617181920212223// 值传递 (C++代码)#include &lt;iostream&gt;using namespace std;void func(int n){ cout &lt;&lt; &quot;The value of n in func(): &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &quot;The address of n in func(): &quot; &lt;&lt; &amp;n &lt;&lt; endl; n++; cout &lt;&lt; &quot;Then the value of n in func(): &quot; &lt;&lt; n &lt;&lt; endl;}int main(){ int n = 0; cout &lt;&lt; &quot;The value of n in main(): &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &quot;The address of n in main(): &quot; &lt;&lt; &amp;n &lt;&lt; endl; func(n); cout &lt;&lt; &quot;Then the value of n in main(): &quot; &lt;&lt; n &lt;&lt; endl; return 0;} 123456789101112131415161718192021// 值传递 (C代码)#include &lt;stdio.h&gt;void func(int n){ printf(&quot;The value of n in func(): %d\\n&quot;, n); printf(&quot;The address of n in func(): 0x%x\\n&quot;, &amp;n); n++; printf(&quot;Then the value of n in func(): %d\\n&quot;, n);}int main(){ int n = 0; printf(&quot;The value of n in main(): %d\\n&quot;, n); printf(&quot;The address of n in main(): 0x%x\\n&quot;, &amp;n); func(n); printf(&quot;Then the value of n in main(): %d\\n&quot;, n); return 0;} 下边是可能的输出： 123456The value of n in main(): 0The address of n in main(): 0x61fe1cThe value of n in func(): 0The address of n in func(): 0x61fdf0Then the value of n in func(): 1Then the value of n in main(): 0 第二行第四行说明，main() 中的实参 n 与 func() 中的形参 n 存储在内存的不同位置，不是同一个变量。第五第六行说明，对形参 n 的操作，不会影响实参 n。 指针传递指针传递也就是传参时不直接传某个参数的值，而是传它的地址。把这个地址作为实参，而形参又是复制实参而来的，所以形参也是原来参数的地址，这样再对形参解除引用，实际上就是对同一内存的值进行操作，所以当然在自定函数中的操作会在主函数中反映出来，请看下边的代码 2： 1234567891011121314151617181920212223// 指针传递 (C++代码)#include &lt;iostream&gt;using namespace std;void func(int *p){ cout &lt;&lt; &quot;The value of n(*p) in func(): &quot; &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; &quot;The address of n(p) in func(): &quot; &lt;&lt; p &lt;&lt; endl; (*p)++; cout &lt;&lt; &quot;Then the value of n(*p) in func(): &quot; &lt;&lt; *p &lt;&lt; endl;}int main(){ int n = 0; cout &lt;&lt; &quot;The value of n in main(): &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &quot;The address of n in main(): &quot; &lt;&lt; &amp;n &lt;&lt; endl; func(&amp;n); // 把想要传递的参数的地址作为实参传入 cout &lt;&lt; &quot;Then the value of n in main(): &quot; &lt;&lt; n &lt;&lt; endl; return 0;} 123456789101112131415161718192021// 指针传递 (C代码)#include &lt;stdio.h&gt;void func(int *p){ printf(&quot;The value of n(*p) in func(): %d\\n&quot;, *p); printf(&quot;The address of n(p) in func(): 0x%x\\n&quot;, p); (*p)++; printf(&quot;Then the value of n(*p) in func(): %d\\n&quot;, *p);}int main(){ int n = 0; printf(&quot;The value of n in main(): %d\\n&quot;, n); printf(&quot;The address of n in main(): 0x%x\\n&quot;, &amp;n); func(&amp;n); printf(&quot;Then the value of n in main(): %d\\n&quot;, n); return 0;} 下边是可能的输出： 123456The value of n in main(): 0The address of n in main(): 0x61fe1cThe value of n(*p) in func(): 0The address of n(p) in func(): 0x61fe1cThen the value of n(*p) in func(): 1Then the value of n in main(): 1 这实际上就是 《一个有关指针传参的问题》- 分析及解决分案 中的代码 2 的思路。只不过这里我们是对 int 类型的普通变量操作，所以函数接受的参数类型是 int*，而在那篇文章中是要对 int*类型的变量操作，所以自定函数接受的参数类型变成了int**。 引用传递 注意引用传递是 C++ 的特性，C 没有这个特性。 引用传递相当于给实参取了个别名，对形参的操作会同步到实参那边去，还是来看下边的代码 3 吧： 1234567891011121314151617181920212223// 引用传递 (C++代码)#include &lt;iostream&gt;using namespace std;void func(int &amp;n2){ cout &lt;&lt; &quot;The value of n2 in func(): &quot; &lt;&lt; n2 &lt;&lt; endl; cout &lt;&lt; &quot;The address of n2 in func(): &quot; &lt;&lt; &amp;n2 &lt;&lt; endl; n2++; cout &lt;&lt; &quot;Then the value of n2 in func(): &quot; &lt;&lt; n2 &lt;&lt; endl;}int main(){ int n1 = 0; cout &lt;&lt; &quot;The value of n1 in main(): &quot; &lt;&lt; n1 &lt;&lt; endl; cout &lt;&lt; &quot;The address of n1 in main(): &quot; &lt;&lt; &amp;n1 &lt;&lt; endl; func(n1); cout &lt;&lt; &quot;Then the value of n1 in main(): &quot; &lt;&lt; n1 &lt;&lt; endl; return 0;} 下边是可能的输出： 123456The value of n1 in main(): 0The address of n1 in main(): 0x61fe1cThe value of n2 in func(): 0The address of n2 in func(): 0x61fe1cThen the value of n2 in func(): 1Then the value of n1 in main(): 1 类似地，int 类型的引用类型是 int&amp;，int* 的引用类型是 int*&amp;。 参考文章 C++ 值传递、指针传递、引用传递 - 简书 (jianshu.com) C++ 值传递、指针传递、引用传递详解 - zqlucky - 博客园 (cnblogs.com)","link":"/posts/c8a20144.html"},{"title":"C++ const 用法汇总","text":"最开始只是用 const 来定义常量，学到了指针传参的时候又知道了用 const 来防止一些值的修改，学到类的时候又看到非静态成员函数后边加个 const 来干嘛干嘛，然后么又听说什么顶层 const、底层 const… 真是越学越迷糊了，赶紧做一波整理。 [2023 年 3 月 24 日更新：] 此文章已经重写，请查看：_The const and constexpr in C++ (REMAKE)_ 最基本的用法 —— 定义常量这个不必多说，直接上代码： 1234int a = 1;const int b = 1;a = 2; // 正确：a 没有 const 修饰，可以改变其值b = 2; // 错误：b 有 const 修饰，不能改变其值 除了这个，还有一点是，虽然似乎我们可以通过一些“骚操作”改变 const 修饰的变量（常量?）的值，但是输出的时候，会发现结果并没有改变。看下边的代码： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(){ const int x = 7; int *p = (int *)&amp;x; // 奇怪的骚操作 // 直接 int *p = &amp;x; 是不行的 // 但这样可以 // 这样我们就可以通过指针 p 来直接操作那块内存 *p = 12; cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; return 0;}/*输出结果：712*/ 但是如果加上 volatile 关键词，却可以发现结果也可以跟着变： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(){ volatile const int x = 7; int *p = (int *)&amp;x; *p = 12; cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; return 0;}/*输出结果：1212*/ 但是，上边的 const 修饰的都不是全局变量。如果修饰的是全局变量，我们似乎就不能通过指针的小把戏来改变 const 的值了： 12345678910111213141516// 错误代码：// 这玩意儿能通过编译，但是压根跑不起来#include &lt;iostream&gt;using namespace std;const int x = 1;int main(){ int *p1 = (int *)&amp;x; *p1 = 7; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; &quot;*p1 = &quot; &lt;&lt; *p1 &lt;&lt; endl; return 0;} 但如果加上了 volatile 依然可以跑，并且也可以用指针来修改它的值： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;volatile const int y = 2;int main(){ int *p2 = (int *)&amp;y; *p2 = 8; cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; endl; cout &lt;&lt; &quot;*p2 = &quot; &lt;&lt; *p2 &lt;&lt; endl; return 0;}/*运行结果：y = 8*p2 = 8*/ 总结一下，就是—— 如果是局部的 const，那至少有两方面的保护：一是编译检查，看看我们下边的代码是否显而易见地尝试去改变它的值，如果有那就报错；二是编译器的自动优化，编译器会把这个变量的值复制一份放到寄存器里，所以即使我们用指针改变了原来内存里的值，输出的结果还是原来的值（备份到寄存器的原来的值的拷贝），所以当我们使用 voliatile 关键字关闭了编译器的这种优化，让程序每运行到要用到这个 const 修饰的变量的时候都去原来的地址读取值的时候，我们的小把戏成功了。 如果是全局的 const，还会有其他的机制，具体还没弄清楚，不过你可以看看《Linux 系统编程学习总结 （二）ELF - 知乎》这篇文章，也许会有帮助？ 顶层 const 和底层 const首先，讨论顶层底层的 const，一般都是对指针变量才有意义。那么啥是顶层 const？啥是底层 const？ 顶层 const（top-level const）表示指针本身是个常量;底层 const（low-level const）表示指针所指的对象是一个常量。 举几个例子： 1234567891011int x = 7;int y = 12;int *const p1 = &amp;x; // 顶层 constconst int *p2 = &amp;x; // 底层 constconst int *const p3 = &amp;x; // 左边是底层 const, 右边是顶层 constp1 = &amp;y; // 错误，p1 是顶层 const 修饰的，所以 p1 指向的地址是确定的，无法更改它的指向p2 = &amp;y; // 正确，p2 没有被顶层 const 修饰，这意味着我们可以修改它的指向p3 = &amp;y; // 错误*p1 = y; // 正确，p1 没有被底层 const 修饰，这意味着我们可以修改它指向的值*p2 = y; // 错误，p2 是底层 const 修饰的，我们无法改变它指向的值*p3 = y; // 错误 也就是说： 仅仅被顶层 const 修饰，意味着指针变量的指向无法改变，但可以操作指向的值（指针常量? 指针（地址）是个常量）； 仅仅被底层 const 修饰，意味着指针变量的指向可以改变，但无法操作指向的值（常量指针？ 指向常量的指针）； 如果两重修饰，那么就就没办法改变指针的指向，也没办法操作指向的值。 顺便一说对于引用的情况。因为引用必须初始化并且初始化完成后（起玩别名后就不能改变它引用的对象了），所以 const int &amp; 就是顶层的，并且没有 int &amp; const 这种写法。 函数中的 const参数列表中的 const其实就是希望函数运行过程中不改变这个变量的值。比如写函数原型的时候用 const int &amp;，其中 const 表示这个函数对这个变量的操作是只读的，不会改变原来的值，而 &amp; 的作用就是，既然这里只是要读一读这个变量的值，并不对它进行操作，那我就不创建副本了，直接用它自己。 返回的 const这边还没弄清楚，以后弄清楚了再写。 类的非静态成员函数后边跟的 const这样可以让这个函数的 this 是只读的。 看这篇文章：《C\\C++ 中函数后面加 const_51CTO 博客_c++ const 函数》 非静态成员函数后面加 const（加到非成员函数或静态成员后面会产生编译错误）表示成员函数隐含传入的 this 指针为 const 指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对 this 指针的 const 引用）唯一的例外是对于 mutable 修饰的成员。加了 const 的成员函数，可以被非 const 对象和 const 对象调用，但不加 const 的成员函数 只能被非 const 对象调用。 参考资料 《C++ const 用法小结 （欢迎大家拍砖） - karllen - 博客园》 《Linux 系统编程学习总结 （二）ELF - 知乎》 《C\\C++ 中函数后面加 const_51CTO 博客_c++ const 函数》 《C++ 顶层 const 和底层 const - 知乎》 《C++ 干货系列 —— 顶层 const 和底层 const - 知乎》","link":"/posts/7ec6ba38.html"},{"title":"C&#x2F;C++ 格式化输入输出汇总","text":"本文汇总一下 C 语言 scanf 和 printf 的格式控制方法以及 C++ 的 &lt;iomanip&gt; 库。 C 语言此处内容来源于 《C Primer Plus （第 6 版）中文版》。 printf() 函数转换说明ANSI C 中 printf() 的转换说明（P69，表 4.3：转换说明及其打印的输出结果） 整数 转换说明 打印的结果 %d / %i 有符号十进制整数 %u 无符号十进制整数 %o 无符号八进制整数 %x 无符号十六进制整数，使用十六进制数 0f %X 无符号十六进制整数，使用十六进制数 0F %a / %A 十六进制数、浮点数和 p 计数法（C99/C11） 浮点数 转换说明 打印的结果 %e / %E 浮点数，e 计数法 %f 浮点数，十进制计数法 %g / %G 根据值的不同，自动选择 %f 或 %e / %E。%e / %E 格式用于指数小于-4 或大于等于精度时。 %a / %A 十六进制数、浮点数和 p 计数法（十六进制指数计数法）（C99/C11） 其他 转换说明 打印的结果 %c 单个字符（包括空白字符） %s 字符串 %p 指针 %% 百分号 转换说明修饰符（P71，表 4.4：printf()的修饰符）： 修饰符 含义 标记 共 5 种（-, +, 空格, # , 0） 数字 最小字段宽度（不够自动变宽） .数字 精度（具体见下边说明） h 和整型转换说明一起使用，表示 short int 或 unsigned short int hh 和整型转换说明一起使用，表示 signed char 或 unsigned char j 和整型转换说明一起使用，表示 intmax_t 或 uintmax_t （这些类型定义在 &lt;stdint.h&gt; 中） l 和整型转换说明一起使用，表示 long int 或 unsigned long int（和浮点型转换说明构成 %lf，表示 double） ll 和整型转换说明一起使用，表示 long long int 或 unsigned long long int（C99） L 和浮点转换说明一起使用，表示 long double 类型的值 t 和整型转换说明一起使用，表示 ptrdiff_t （ptrdiff_t 是两个指针差值的类型，C99） z 和整型转换说明一起使用，表示 size_t （size_t 是 sizeof 返回的类型，C99） 上边的 .数字： 对于 %e、%E、%f，表示小数点右边数字的位数； 对于 %g、%G，表示有效数字的最大位数； 对于 %s，表示待打印字符的最大数量； 对于整型转换，表示待打印数字的最小位数，如有必要，使用前导 0 来达到这个位数。 只是用 . 表示其后跟随了一个 0，所以 %.f 和 %.0f 相同。 （P72，表 4.5：printf()中的标记）： 标记 含义 - 左对齐 + 有符号值前加正负号 空格 有符号值正不加，负加负号 # 把结果转换为另一种形式，具体看下边 0 对于数值格式，用前导 0 代替空格填充字段宽度。对于整数格式，如果出现-标记或者指定精度，则忽略该标记 # 的说明： %o：以 0 开始； %x / %X：以 0x / 0X 开始； 所有浮点格式：保证即使后边没有任何数字，也打印一个小数点字符； %g / %G：防止结果后边的 0 被删除。 scanf()函数大部分与上边相同，只讲不一样的。 （P80，表 4.7：scanf()转换说明中的修饰符）： 转换说明 含义 * 抑制赋值 数字 最大字符宽度。输入达到这个宽度或者第一次遇到空白字符时停止。 scanf() 的返回值是成功读取的项数。如果没有读取任何项，则返回 0；如果检测到“文件结尾”，返回 EOF （EOF 是定义 &lt;stdio.h&gt; 中定义的特殊值，一般用 #define 定义为 -1）。 注意：输入数字的时候，在不设置分隔符号时，scanf()默认使用空白字符进行分隔；但是输入字符时，空白字符不会被忽略，而是被顺利读入。 比如下边这道题： 有如下程序段： 123int a1, a2;char c1, c2;scanf(&quot;%d%c%d%c&quot;, &amp;a1, &amp;c1, &amp;a2, &amp;c2); 若要求 a1, a2, c1, c2 的值分别为 10, 20, A, B，正确的数据输入是（ ）： A. 10A20 B&lt;CR&gt; B. 10 A 20 B&lt;CR&gt; C. 10 A20B&lt;CR&gt; D. 10A 20B&lt;CR&gt; 正确答案为 D。 C++参考：【C++】C++标准库之 iomanip 库（格式输入输出）_Jacky_Feng 的博客-CSDN 博客 控制符 作用 oct 八进制输入/输出 dec 十进制输入/输出 hex 十六进制输入/输出 setbase(n) 设置为 n 进制 (n = 8, 10, 16) setprecision(n) 设置浮点数的有效数字为 n 位 setfill(c) 设置字符填充为 c setw(n) 设置宽度 setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示 setiosflags(ios::scientific) 设置浮点数以科学计数法表示 setiosflags(ios::left) 输出左对齐 setiosflags(ios::right) 输出右对齐 setiosflags(ios::skipws) 忽略前导空格 setiosflags(ios::uppercase) 在以科学计数法输出 E 与十六进制输出 X 以大写输出，否则小写 setiosflags(ios::showpos) 输出正数时显示”+”号 setiosflags(ios::showpoint) 强制显示小数点 resetiosflags() 终止已经设置的输出格式状态，在括号中应指定内容 更多请见：iomanip CPP 官方教程 _w3cschool","link":"/posts/b4e7acd7.html"},{"title":"求解最大公约数的四种算法","text":"这是一次计算机导论课的作业。本来对于最大公约数的求解算法，我就只知道一个辗转相除法。原来，其实还有别的一些 … 法一：试除法（穷举法）也许这应该才是最先能想到的算法——两个数中取小的那个，由大到小穷举这个数的所有因数，并且看看这个数是不是另一个数的因数，如果是，那这个数就是这两个数的最大公约数了。 1. 时间复杂度$O(min(a,b))$ 1. 自然语言描述 定义变量 $a,b$，用于存放两个待求取最大公约数的值，确保 $a\\leq b$； 定义变量 $i=a$； 如果 $i\\geq1$，执行步骤 4； 判断 $i$ 是否是 $a$ 的因数，如果是，执行步骤 5，否则，执行步骤 7； 判断 $i$ 是否是 $b$ 的因数，如果是，执行步骤 6，否则，执行步骤 7； 跳出循环，$i$ 就是 $a$ 和 $b$ 的最大公约数； $i$ 自减 $1$，执行步骤 3； 1. 伪代码描述1234567891011121314var a,b,i:integer;input(a);input(b);BeginFor i&lt;-a to 1 doBegin If a%i==0 Then If b%i==0 Then Begin print(i); break; End;End;End; 1. 流程图 1. C++ 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main(){ uint64_t a, b; cin &gt;&gt; a &gt;&gt; b; if (a &gt; b) swap(a, b); for (int i = a; i &gt;= 1; i--) { if (a % i == 0) if (b % i == 0) { cout &lt;&lt; i &lt;&lt; endl; break; } } return 0;} 法二：辗转相除法（欧几里得算法）这大概是最常见的计算最大公约数的算法了吧… 2. 时间复杂度可近似看作 $O(log(max(a,b)))$，但取模运算性能较差。 2. 自然语言描述 定义变量 a，b 并读入； 如果 b == 0，返回 a； 否则，更新 a 的值为原来 b 的值，更新 b 的值为原来 a%b 的值，回到步骤 2。 2. 伪代码描述1234567var a,b:integer;def gcd(a,b):Begin If b==0 Then return a; Else return(gcd(b, a%b));End; 2. 流程图 2. C++ 代码主函数及 gcd 函数的函数声明： 123456789101112#include &lt;iostream&gt;using namespace std;uint64_t gcd(uint64_t, uint64_t);int main(){ uint64_t a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; gcd(a, b) &lt;&lt; endl; return 0;} gcd 函数（递归实现）： 1234567uint64_t gcd(uint64_t a, uint64_t b){ if (b == 0) return a; else return gcd(b, a % b);} gcd 函数（递归函数，写成一行的版本）： 1uint64_t gcd(uint64_t a, uint64_t b) { return b ? gcd(b, a % b) : a; } gcd 函数（迭代实现）： 12345678910uint64_t gcd(uint64_t a, uint64_t b){ while (b != 0) { uint64_t tmp = a % b; a = b; b = tmp; } return a;} 法三：更相减损法更相减损法又叫更相减损术，出自《九章算术》，是咱老祖宗的智慧。这个东西本来是为了约分而设计的，但是，既然都约分了，那自然也可以用来求取最大公约数。 这个算法的原文描述是这样： 可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。 翻译成白话就是： （如果需要对分数进行约分，那么）可以折半的话，就折半（也就是用 2 来约分）。如果不可以折半的话，那么就比较分母和分子的大小，用大数减去小数，互相减来减去，一直到减数与差相等为止，用这个相等的数字来约分。 这两段引用的来源是：更相减损术_百度百科 (baidu.com) 3. 时间复杂度$O(max(a,b))$ 3. 自然语言描述 定义变量 a、b 并读入； 如果 变量 a、b 能被 2 整除，那就都除以 2。不断重复执行这一步直到 a、b 任意一个不能被 2 整除，记录下进行这一步的次数，存入变量 cnt 中； 定义三个变量 x1、x2、x3，用于表示被减数、减数和差； x1 赋初值为 a、b 中较大的那一个，x2 赋初值为 a、b 中较小的那一个，x3 赋初值为 x1-x2； 在 x2!=x3 的情况下，不断更新 x1 = max(x2, x3)，x2 = min(x2, x3)，x3 = x1 - x2； 返回 x2 + pow(2, cnt)。 3. 流程图3. C++ 代码下边给出的是基于原文描述实现的更相减损法： 123456789101112131415161718192021uint64_t gcd(uint64_t a, uint64_t b){ uint64_t cnt = 0; // 统计除以二的次数 while (a % 2 == 0 &amp;&amp; b % 2 == 0) { cnt++; a /= 2; b /= 2; } uint64_t x1, x2, x3; // 分别表示被减数、减数、差 x1 = max(a, b); x2 = min(a, b); x3 = x1 - x2; while (x2 != x3) { x1 = max(x2, x3); x2 = min(x2, x3); x3 = x1 - x2; } return x2 * pow(2, cnt);} 如果去掉那些“可半者半之”，直接进行后面的“辗转相减”部分，也是可以的： 1234567891011121314uint64_t gcd(uint64_t a, uint64_t b){ uint64_t x1, x2, x3; // 分别表示被减数、减数、差 x1 = max(a, b); x2 = min(a, b); x3 = x1 - x2; while (x2 != x3) { x1 = max(x2, x3); x2 = min(x2, x3); x3 = x1 - x2; } return x2; // 或者 return x3;} 于是也可以写出递归形式： 123456789uint64_t gcd(uint64_t a, uint64_t b){ if (a &lt; b) a ^= b, b ^= a, a ^= b; // 确保 a&gt;=b if (2 * b == a) return b; else return gcd(b, a - b);} 法四：Stein 算法这个算法是辗转相除法的改进版本，避免了取模运算，且算法性能稳定。 4. 时间复杂度$O(log(max(a,b)))$ 版本一：学习自这篇文章，正好学习一下位运算的一些“骚操作”（见下文引用处）。 4.1. 自然语言描述 定义变量 a、b 并读入，确保 a&gt;=b（如果 a&lt;b 则交换）； 如果两个数都是偶数，那就不断除以 2 直至至少一个不是偶数； 如果一奇一偶，那就把那个偶数不断除以 2 直至它也为一个奇数； 对两个奇数进行辗转相减（或者辗转相除？上边那篇文章里这么说，但是除的话不是无法避免取模运算效率低下的问题了嘛 emm），直至求出它们的最大公约数； 4.1. 流程图 4.1. C++ 代码 (1) 按位与 (&amp;): a&amp;x 为对数 a 的二进制形式的取位操作，即去 a 二进制形式的第 x 位。这里有一个重要应用就是 a&amp;1 可以用于判断数 a 的奇偶性，即 a 末位为 0 即为偶数，末位为 1 即为奇数。 (2) 异或运算 (^): 具体介绍参考之前的随笔：http://www.cnblogs.com/COLIN-LIGHTNING/p/8298554.html；应用为交换两数：a^=b,b^=a,a^=b 即完成了两数交换。 (3) 按位左移 (&lt;&lt;): a&lt;&lt;=x 即为使 a 乘以 2 的 x 次幂，原理是让 a 的二进制形式左移 x 位；应用为对与 2 的幂次方相乘使运算更快更方便； (4) 按位右移 (&gt;&gt;): a&gt;&gt;=x 即为使 a 除以 2 的 x 次幂，原理是让 a 的二进制形式右移 x 位；应用为对与 2 的幂次方相除使运算更快更方便； 大佬的代码大致是这样的： 1234567891011121314151617uint64_t gcd(uint64_t a, uint64_t b){ if (a &lt; b) a ^= b, b ^= a, a ^= b; // 确保 a&gt;=b，也可以 swap(a,b); if (b == 0) return a; if ((!(a &amp; 1)) &amp;&amp; (!(b &amp; 1))) // a&amp;1 若为 0 表示 a%2==0，也就是 a 能被 2 整除； // 若非 0 则表示 a%2!=0，也就是 a 不能被 2 整除。 // b&amp;1 类似。所以这里判断的是 “当 a、b 都是偶数的时候” return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; // 步骤 2：将 a、b 都除以 2。注意最后的左移，在递归返回过程中将2因子乘上。 else if ((a &amp; 1) &amp;&amp; (!(b &amp; 1))) // “当 a 为奇数，b 为偶数时” return gcd(a, b &gt;&gt; 1); // 步骤 3：将仍为偶数的那个数不断除以 2 直至其为奇数。 else if ((!(a &amp; 1)) &amp;&amp; (b &amp; 1)) // “当 a 为偶数，b 为奇数时” return gcd(a &gt;&gt; 1, b); // 与上面类似 else return gcd(a - b, b); // 步骤 4：用辗转相减法处理，求取这两个奇数的最大公约数;} 版本二：来自这里，对均为奇数的情况做了不同的处理，其他都是一样的。 4.2. 自然语言描述 定义变量 a、b 并读入； 如果 a==b，则直接返回 a 或 b，否则下一步； 如果 a&lt;b，交换 a、b 的值，确保 a&gt;b； 判断属于下边哪种情况，按对应的情况更新 a、b 的值，回到步骤 2。 四种情况分别是： 均为偶数: gcd(a,b) = 2 * gcd(a/2,b/2); 均为奇数: gcd(a,b) = gcd((a+b)/2,(a-b)/2); a 为奇数，b 为偶数: gcd(a,b) = gcd(a,b/2); a 为偶数，b 为奇数: gcd(a,b) = gcd(a/2,b); 4.2. 流程图 4.2. C++ 代码最后代码和上边也没有太大差别。 123456789101112131415uint64_t gcd(uint64_t a, uint64_t b){ if (a == b) return a; if (a &lt; b) a ^= b, b ^= a, a ^= b; if (!(a &amp; 1) &amp;&amp; !(b &amp; 1)) // 均为偶数 return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; // 别忘了要乘回来 else if ((a &amp; 1) &amp;&amp; (b &amp; 1)) // 均为奇数 return gcd((a + b) &gt;&gt; 1, (a - b) &gt;&gt; 1); else if ((a &amp; 1) &amp;&amp; !(b &amp; 1)) // a 奇 b 偶 return gcd(a, b &gt;&gt; 1); else if (!(a &amp; 1) &amp;&amp; (b &amp; 1)) // a 偶 b 奇 return gcd(a &gt;&gt; 1, b);} 参考资料： 《求最大公约数的 4 种常用算法AmethystFOB 的博客 - CSDN 博客求最大公约数的四种算法》 《更相减损术_百度百科 (baidu.com)》 《教你写一手漂亮的伪代码（详细规则 &amp; 简单实例）_陈同学的博客 - CSDN 博客_伪代码的简单例子》 《伪代码是什么？如何写一个伪代码？-C#.Net 教程 - PHP 中文网》 《流程图_百度百科 (baidu.com)》 《for、while、do while 三种循环的流程图画法总结（附案例） - 知乎 (zhihu.com)》 《switch 语句流程图怎么画？简单的 switch 语句流程图模板分享 (liuchengtu.com)》 《浅谈 Stein 算法求最大公约数 (GCD) 的原理及简单应用 - COLINGAO - 博客园 (cnblogs.com)》","link":"/posts/504f038d.html"},{"title":"当形参、实参是指针变量...","text":"接《一个有关指针传参的问题》，再理一理这里边的一些问题… 在单向值传递的过程中，我们知道，形参是对实参的值的拷贝。在实参的值传递给形参后，对形参的一切操作，都不会对实参产生什么影响。比如下边这串代码： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;void func(int n);int main(){ int n = 5; cout &lt;&lt; &quot;Before func(), main(): n = &quot; &lt;&lt; n &lt;&lt; endl; func(n); cout &lt;&lt; &quot;After func(), main(): n = &quot; &lt;&lt; n &lt;&lt; endl; return 0;}void func(int n){ cout &lt;&lt; &quot;Before n++, func(): n = &quot; &lt;&lt; n &lt;&lt; endl; n++; cout &lt;&lt; &quot;After n++, func(): n = &quot; &lt;&lt; n &lt;&lt; endl;} 下边是输出结果： 1234Before func(), main(): n = 5Before n++, func(): n = 5After n++, func(): n = 6After func(), main(): n = 5 通过打印它们的地址，我们也可以认识到这一点： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;void func(int n);int main(){ int n = 5; cout &lt;&lt; &quot;In main(): &quot; &lt;&lt; endl; cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &quot;&amp;n = &quot; &lt;&lt; &amp;n &lt;&lt; endl; cout &lt;&lt; endl; func(n); return 0;}void func(int n){ cout &lt;&lt; &quot;In func(): &quot; &lt;&lt; endl; cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &quot;&amp;n = &quot; &lt;&lt; &amp;n &lt;&lt; endl;}/*输出结果：In main():n = 5&amp;n = 0x61fe1cIn func():n = 5&amp;n = 0x61fdf0*/ 如果把变量类型从普通类型变成指针类型，那么类似的，发生的其实也是一次值传递，也即，指针变量的值发生了一次拷贝，请看下边的例子： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void func(int *p);int main(){ int *p = new int; cout &lt;&lt; &quot;In main(): &quot; &lt;&lt; endl; cout &lt;&lt; &quot;p = &quot; &lt;&lt; (int *)p &lt;&lt; endl; cout &lt;&lt; &quot;&amp;p = &quot; &lt;&lt; &amp;p &lt;&lt; endl; cout &lt;&lt; endl; func(p); return 0;}void func(int *p){ cout &lt;&lt; &quot;In func(): &quot; &lt;&lt; endl; cout &lt;&lt; &quot;p = &quot; &lt;&lt; (int *)p &lt;&lt; endl; cout &lt;&lt; &quot;&amp;p = &quot; &lt;&lt; &amp;p &lt;&lt; endl;} 在我电脑上的输出结果是： 1234567In main():p = 0xee61c0&amp;p = 0x61fe18In func():p = 0xee61c0&amp;p = 0x61fdf0 可以看到，int * 类型的指针变量 p 的值是相同的，但地址不同，这是两个变量。 把上边代码 main() 中的 p 记为 p1，func() 中的记为 p2，那么就可以这样理解为，当调用 func() 时，p2 与 p1 指向了相同的位置，但它们确实不是同一个指针。 对于《一个有关指针传参的问题》中的那段错误代码，其实错误就是，在函数中 new 出来内存后，只是让形参指向了那片内存，而原来的实参并没有同步地指过去。 但是只要确定形参的指针和实参的指针指向的地址是相同的，那么对这同一片内存进行的操作，就是同步的，比如： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;void func(int *p);int main(){ int *p = new int; *p = 5; cout &lt;&lt; &quot;Before func(), main(): (*p) = &quot; &lt;&lt; *p &lt;&lt; endl; func(p); cout &lt;&lt; &quot;After func(), main(): (*p) = &quot; &lt;&lt; *p &lt;&lt; endl; return 0;}void func(int *p){ cout &lt;&lt; &quot;Before (*p)++, func(): (*p) = &quot; &lt;&lt; *p &lt;&lt; endl; (*p)++; cout &lt;&lt; &quot;After (*p)++, func(): (*p) = &quot; &lt;&lt; *p &lt;&lt; endl;} 输出结果： 1234Before func(), main(): (*p) = 5Before (*p)++, func(): (*p) = 5After (*p)++, func(): (*p) = 6After func(), main(): (*p) = 6 由于数组名其实就是数组第一个元素（下标为 0 的那个元素）的地址，所以类似的，在函数中对数组形参的操作会等效到数组实参上去： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void func(int[], int);int main(){ int a[3] = {0, 1, 2}; for (int x : a) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; func(a, 3); for (int x : a) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return 0;}void func(int arr[], int n){ for (int i = 0; i &lt; n; i++) arr[i]++;} 输出结果： 120 1 21 2 3","link":"/posts/1ef1e20b.html"},{"title":"C 标准库中 qsort 和 C++ STL 中 sort 的用法","text":"虽然到现在还是不能完全理解 qsort 和 sort 这两个函数的底层原理，但至少，先学会如何使用吧。 qsort需要包含的库: stdlib.h (C++ 中 是 cstdlib) 函数原型： 1void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)) 参数解释： base: 必选，数组名（数组首元素的地址）； nitems: 必选，数组中元素的个数； size: 必选，数组中单个元素的大小； compar: 必选，一个函数指针，具体这个函数要干嘛下边细说。 最后一个参数是函数指针，这个指针指向的函数的原型应该类似于下边这样： 1int cmp(const void *a, const void *b); 这是一个返回值为 -1、0 或 1 的函数。 如果要实现升序，那么应该是： a&gt;b：返回 1（或其他正数）;a==b：返回 0;a&lt;b: 返回 -1（或其他负数）; 如果是降序，那么就应该反过来，像下边这样： a&gt;b：返回 -1（或其他负数）;a==b：返回 0;a&lt;b: 返回 1（或其他正数）; 比如我要对 int 类型的数组升序排序，那么我的 cmp 函数应该像下边这样： 1234567891011int cmp(const void *a, const void *b){ const int *x = (const int *)a; const int *y = (const int *)b; if (*x &gt; *y) return 1; else if (*x == *y) return 0; else return -1;} 或者也可以简化成下边这样： 1234int cmp(const void *a, const void *b){ return (*(const int *)a - *(const int *)b);} 这里的 a&gt;b 等比较方式只是形式上我这么写，实际上有可能这两个元素我并不能直接这么比（比如如果这里的 a、b 都是 struct），那么就应该类似下边这样： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct{ unsigned int ID; unsigned int score;} STUDENT;int cmp(const void *, const void *);int main(){ STUDENT stu[5] = {{1, 5}, {2, 3}, {3, 1}, {4, 2}, {5, 4}}; qsort(stu, 5, sizeof(STUDENT), cmp); for (int i = 0; i &lt; 5; i++) { printf(&quot;ID: %u, Score: %u\\n&quot;, stu[i].ID, stu[i].score); } return 0;}int cmp(const void *a, const void *b){ const STUDENT *x = (const STUDENT *)a; const STUDENT *y = (const STUDENT *)b; // 降序排序 if (x-&gt;score &gt; y-&gt;score) return -1; else if (x-&gt;score == y-&gt;score) return 0; else return 1;} 输出是： 12345ID: 1, Score: 5ID: 5, Score: 4ID: 2, Score: 3ID: 4, Score: 2ID: 3, Score: 1 sort需要包含的库: algorithm（C++ STL 中的算法库） 函数原型： 12template &lt;class RandomAccessIterator, class Compare&gt;void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); 参数解释： first: 必选，排序开始处（参与排序的第一个元素）；last: 必选，排序结束处的后一个紧挨着的位置（参与排序的最后一个元素的后一个位置）；comp: 可选，用来指定怎么排序的函数，没有的话如果可以默认升序。 下边给出一些例子： 给一个数组升序排序： 12int arr[5] = {5, 1, 3, 2, 4};sort(arr, arr + 5); 给一个 vector 降序排序： 12vector&lt;int&gt; nums = {5, 1, 3, 2, 4};sort(nums.begin(), nums.end(), greater&lt;int&gt;()); 这里用了 greater&lt;typename&gt;() 这个东东直接表达我这个排序需要降序排序，类似的还有 less&lt;typename&gt;() 用来指定升序。 然后是自定义这第三个参数，我们就用上边 qsort 那个例子吧： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct STUDENT{ unsigned int ID; unsigned int score;};bool cmp(STUDENT, STUDENT);int main(){ STUDENT stu[5] = {{1, 5}, {2, 3}, {3, 1}, {4, 2}, {5, 4}}; sort(stu, stu + 5, cmp); for (int i = 0; i &lt; 5; i++) { printf(&quot;ID: %u, Score: %u\\n&quot;, stu[i].ID, stu[i].score); } return 0;}bool cmp(STUDENT a, STUDENT b){ if (a.score &gt; b.score) return true; else return false;} 或者也可以把 cmp 写成下边这种更容易记住的方式： 12345bool cmp(STUDENT a, STUDENT b){ return a.score &gt; b.score; // 表示排序完成后前一个元素比后一个元素大，即降序排序} 输出和上边是一样的。 注意 在 qsort 中，最后一个参数的函数的返回值应是一个有符号整型。在期望升序排序时，这个返回值应该指定为：第一个元素大于第二个元素，返回正数；第一个元素等于第二个元素，返回 0；第一个元素小于第二个元素，返回负数。 在 C++ STL 的 sort 中，最后一个参数的返回值应是一个布尔值。在期望升序排序时，这个返回值应该是 (第一个元素 &lt; 第二个元素) 的运算结果。","link":"/posts/eab95d6e.html"},{"title":"初探深度优先搜索（DFS）和广度优先搜索（BFS）","text":"深度优先搜索（DFS，Depth First Search）和广度优先搜索（BFS，Breadth First Search），我从来没弄明白过。是时候努力去好好理解一下了。 B 站找了两个视频看，这篇文章是笔记。 所以图直观还是直接看视频吧… 《不怕你学不会系列：深度优先搜索_哔哩哔哩_bilibili》 《不怕你学不会系列：宽度优先搜索_哔哩哔哩_bilibili》 深度优先搜索DFS 的搜索过程要结合 栈 来理解，实际上这个过程就是在对一个 栈 在操作。比如我们有这样一张图： graph TB; 1((1))===2((2))===4((3))===8((4))===5((5)) 2((2))===5((5)) 1((1))===3((8))===6((6))===8((4)) 3((8))===7((9)) 6((6))===9((7)) 我的博客支持 mermaid 嘛… emm 好像不支持… 我们建立一个栈，然后开始遍历上边这张图。我们做以下约定： 已经入栈的节点要被标记为已经遍历； 起始节点为 1，将其入栈，作为最初的栈顶； 查看与当前栈顶元素相连并且未被标记的节点，将其入栈； 如果有多个满足 3 中条件的元素，节点序号较小的优先入栈； 当栈顶元素没有相连节点或所有相连节点均已经被标记后，将其出栈。 所以对于上边的图，我们依次进行下面的操作： 节点 1 入栈，并将其标记； 查找与当前栈顶元素节点 1 相连并且没有标记的元素，有节点 2 和节点 8，节点 2 优先入栈，将节点 2 标记； 查找与当前栈顶元素节点 2 相连并且没有标记的元素，有节点 3 和节点 5，节点 3 优先入栈，将节点 3 标记； 查找与当前栈顶元素节点 3 相连并且没有标记的元素，只有节点 4，节点 4 入栈，并将其标记； 查找与当前栈顶元素节点 4 相连并且没有标记的元素，有节点 5 和 节点 6 ，节点 5 优先入栈，将节点 5 标记； 查找与当前栈顶元素节点 5 相连的元素，有节点 2 和节点 4，但均已被标记，所以当前栈顶节点 5 出栈； 查找与当前栈顶元素节点 4 相连并且没有标记的元素，只有节点 6，节点 6 入栈，并将其标记； 查找与当前栈顶元素节点 6 相连并且没有标记的元素，有节点 7 和节点 8，节点 7 优先入栈，将节点 7 标记； 查找与当前栈顶元素节点 7 相连的元素，没有这样的元素，节点 7 出栈； 查找与当前栈顶元素节点 6 相连并且没有标记的元素，只有节点 8，节点 8 入栈，并将其标记； 查找与当前栈顶元素节点 8 相连并且没有标记的元素，只有节点 9， 节点 9 入栈，并将其标记； 查找与当前栈顶元素节点 9 相连并且没有标记的元素，没有这样的元素，节点 9 出栈； 查看当前栈顶元素节点 8，类似，节点 8 出栈； 查看当前栈顶元素节点 6，类似，节点 6 出栈； 查看当前栈顶元素节点 4，类似，节点 4 出栈； 查看当前栈顶元素节点 3，类似，节点 3 出栈； 查看当前栈顶元素节点 2，类似，节点 2 出栈； 查看当前栈顶元素节点 1，类似，节点 1 出栈。 上边对这个栈的操作过程应该如下边所示： （栈空） 节点 1 节点 1、节点 2 节点 1、节点 2、节点 3 节点 1、节点 2、节点 3、节点 4 节点 1、节点 2、节点 3、节点 4、节点 5 节点 1、节点 2、节点 3、节点 4 节点 1、节点 2、节点 3、节点 4、节点 6 节点 1、节点 2、节点 3、节点 4、节点 6、节点 7 节点 1、节点 2、节点 3、节点 4、节点 6 节点 1、节点 2、节点 3、节点 4、节点 6、节点 8 节点 1、节点 2、节点 3、节点 4、节点 6、节点 8、节点 9 节点 1、节点 2、节点 3、节点 4、节点 6、节点 8 节点 1、节点 2、节点 3、节点 4、节点 6 节点 1、节点 2、节点 3、节点 4 节点 1、节点 2、节点 3 节点 1、节点 2 节点 1 （栈空） 宽度优先搜索BFS 的搜索过程要联系 队列 来理解，约定如下： 已经入队的节点要被标记为已经遍历； 第一个入队的是节点 1，将其作为最初的队首和队尾； 遍历与当前队首相连但未被标记的节点，按照数字大小依次入队，并且移动队尾； 队首移动到下一个元素。 例如对下边这个图： graph TB; 1((1))===2((2))===4((4))===8((8)) 2((2))===5((5))===8((8)) 1((1))===3((3))===6((6))===8((8)) 6((6))===9((9)) 3((3))===7((7))===9((9)) 队列维护的情况如下（加粗的表示队首、斜体表示队尾）： 1、2、3 1、2、3、4、5 1、2、3、4、5、6、7 1、2、3、4、5、6、7、8 1、2、3、4、5、6、7、8 1、2、3、4、5、6、7、8、9 1、2、3、4、5、6、7、8、9 1、2、3、4、5、6、7、8、9 1、2、3、4、5、6、7、8、9","link":"/posts/a336c1b8.html"},{"title":"C 语言文件操作","text":"简单记录一下 C 语言的文件操作的相关内容。 前期准备1234// stdio.h 提供了 C 语言中的许多 IO，当然包括文件 IO#include &lt;stdio.h&gt;// 定义文件指针FILE *fp; 打开文件 fopen() fopen() 函数 函数名称：fopen参数：待打开文件的名称（包含该文件名的字符串地址），打开文件的模式；返回值：成功打开文件则返回一个文件指针，否则返回空指针（NULL） 例如： 123456FILE *fp;if (fp = fopen(&quot;example.file&quot;, &quot;r&quot;) == NULL){ fprintf(stderr, &quot;Fail to open the file.\\n&quot;); exit(EXIT_FAILURE);} 需要注意，该函数第二个参数是一个字符串，可能的值如下（表来自《C Primer Plus（第 6 版）中文版》P357 表 13.1）： 模式字符串 含义 “r” 以读模式打开文件 “w” 以写模式打开文件，把现有文件长度截为 0，如果文件不存在，则创建一个新文件 “a” 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件 “r+” 以更新模式打开文件（即可以读写文件） “w+” 以更新模式打开文件，如果文件存在，则将其长度截为 0，如果文件不存在则创建一个新文件 “a+” 以更新模式打开文件，在现有文件的末尾添加内容，如果文件不存在则创建一个新文件，可以读整个文件，但只能从末尾添加内容 “rb”、”wb”、”ab”、”rb+”、”r+b”、”wb+”、”w+b”、”ab+”、”a+b” 与上边的对应类似，但以二进制模式打开文件 “wx”、”wbx”、”w+x”、”wb+x”或”w+bx” （C11）与上边对应类似，但如果文件已存在或以独占模式打开文件，则打开文件失败 带字母 x 的写模式比以前的具有更多特性： 如果以传统的一种写模式打开一个现有文件，fopen() 会把该文件的长度截为 0，这样就丢失了该文件的内容。但是使用带 x 字母的写模式，即使 fopen() 操作失败，原文件的内容也不会被删除； 如果环境允许，x 模式的独占特性使得其他程序或线程无法访问正在被打开的文件。 关闭文件 fclose() fclose() 函数 函数名称：fclose参数：待关闭文件的名称（包含该文件名的字符串地址）；返回值：成功关闭返回 0，否则返回 EOF。 注意区分 fopen() 和 fclose() 的返回值！前者失败时返回 NULL（通常情况下就是 0），后者成功时返回 0。 读写文件fprintf() 和 fscanf()这两个函数分别和 printf() 和 scanf() 类似，只不过 printf() 和 scanf() 分别默认了写和读的标准文件是 stdout 和 stdin，而 fprintf() 和 fscanf() 的第一个参数都需要指定文件指针。 getc() 和 putc()这两个函数分别和 getchar() 和 putchar() 类似，只是需要提供文件指针。 ungetc() ungetc() 函数 函数名称：ungetc函数原型：int ungetc(int c, FILE *fp);函数作用：把 c 指定的字符放回输入流中返回值：如果成功，则返回被推入的字符，否则返回 EOF fgets() 和 fputs()虽然这两个函数也分别类似于 gets() 和 puts()，但比起上边几个函数的”类似”，这个要低一点，所以详细说明一下。 fgets() 函数 函数名称：fgets函数原型：char *fgets (char * restrict str, int n, FILE * restrict fp);返回值：如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。 需要注意 fgets() 的第二个参数，因为 fgets() 读取输入知道第一个换行符的后边（意味着它会读入换行符），或读到文件结尾，或读取 n-1 个字符，并在结尾加上一个 \\0 使之成为一个字符串。 fputs() 函数 函数名称：fputs函数原型：int fputs (char * restrict str, FILE * restrict fp);返回值：该函数返回一个非负值，如果发生错误则返回 EOF。 fputs() 与 puts() 类似，但不会在结尾自动添加换行。 注意区分 fgets() 与 gets()， fputs() 与 puts()！gets() 不保留换行符所以 puts() 自动添加换行符；fgets() 保留换行符所以 fputs() 不会添加换行符。 fread() 和 fwrite()上述的函数都是以文本形式读写文件，这两个函数用于以二进制形式读写文件。 fread() 函数 函数名称：fread函数原型：size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);返回值：返回成功读取项的数量。正常情况下返回值等于 nmemb，发生错误则返回值小于 nmemb。 fwrite() 函数 函数名称：fwrite函数原型：size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);返回值：返回成功写入项的数量。正常情况下返回值等于 nmemb，发生错误则返回值小于 nmemb。 参数 size 表示待写入数据块的大小（以字节为单位），nmemb 表示待写入数据块的数量。 下边是两个使用这两个函数的例子。 123456789101112// 保存一个大小为 256 字节的 buffer 数组char buffer[256];fwrite(buffer, 256, 1, fp);// 保存一个内含 10 个 double 类型值的数组// 或者说理解成保存 10 个 double 类型的值double earnings[10];fwrite(earnings, sizeof(double), 10, fp);// 读取 10 个 double 类型的值到一个数组中double earnings[10];fread(earnings, sizeof(double), 10, fp); 随机访问 fseek() 和 ftell() fseek() 函数 函数名称：fseek函数原型：int fseek(FILE *_File,long _Offset,int _Origin);参数：文件指针，偏移量(long 类型)，模式返回值：正常则返回 0，错误则返回 -1。 第二个参数偏移量必须是一个 long 类型的值，代表偏移的字节数。这个值为正，则表示像文件末尾方向移动；为负则表示向文件开头处。第三个参数可以理解成起点位置，可以使用 SEEK_SET、SEEK_CUR 或 SEEK_END 分别定位到文件开始、当前位置或文件末尾（老版本应分别使用 0、1、2）。 下边是一些例子（来自《C Primer Plus（第 6 版）中文版》P364）： 12345fseek(fp, 0L, SEEK_SET); // 定位至文件开始处fseek(fp, 10L, SEEK_SET); // 定位至文件中第 10 个字节fseek(fp, 2L, SEEK_CUR); // 从文件当前位置向结尾方向移动 2 个字节fseek(fp, 0L, SEEK_END); // 定位至文件末尾fseek(fp, -10L, SEEK_END); // 从文件结尾处回退 10 个字节 ftell() 函数 函数名称：ftell函数原型：long ftell(FILE *_File);返回值：返回当前位置距文件开始的字节数，如文件的第一个字节到文件开始处的距离为 0。 下边是书中给出的一个例子： 12345678fseek(fp, 0L, SEEK_END); // 首先定位到文件结尾last = ftell(fp); // 统计字节数，并存储到 last 中// 逆序打印每一个字节的字符for (count = 1L; count &lt;= last; count++){ fseek(fp, -count, SEEK_END); ch = getc(fp);} 其他函数刷新缓冲区 fflush() fflush() 函数 函数名称：fflush函数原型：int fflush(FILE *fp);函数作用：调用该函数将刷新缓冲区，即将输出缓冲区中所有的未写入数据被发送到 fp 指定的输出文件。如果 fp 为空指针，所有输出缓冲区都被刷新。返回值：成功返回 0，错误返回 EOF。 创建替换使用缓冲区 setvbuf() setvbuf() 函数 函数名称：setvbuf函数原型：int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);返回值：成功返回 0，否则返回非零值。 第二个参数指向待使用的缓冲区。如果是 NULL，则自动分配。第三个参数为模式，有下边几种： 模式 描述 _IOFBF 全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。 _IOLBF 行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。 _IONBF 无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。 feof() 和 ferror()当上一次输入调用检测到文件结尾时，feof() 函数返回一个非零值，否则返回 0。当读写出现错误，ferror() 函数返回一个非零值，否则返回 0。","link":"/posts/914118ff.html"},{"title":"为何说三进制是效率最高的进制？以及其他一些与三进制有关的东西...","text":"这是一次计算机导论的作业。老师提供了很多课题供我们选择，我选择的是“有人说三进制是被证明理论上效率最高的进制，请广泛搜集相关资料，撰写关于三进制的科普报告，或者对其他进制进行对比和评价。 为什么在理论上三进制是最高效率的进制？ 这里的内容来自知乎大佬 @白云龙的这篇回答。B站 up 主 @差评君 的这个视频中对这篇回答进行了动画形式的展现。 首先，先让我们来约定一下什么叫“进制的效率”：$$进制的效率 = \\frac{表达的信息量}{表达这些信息所需的资源}$$比如我们需要表达十进制下 0~999 这 1000 个数字，这就是我们 $表达的信息量$，我们选择用写有数字的牌子来表示它们。 在十进制下，0~999 我们至少需要三位，每位上我们都需要 0~9 十个数字的牌子，所以三位一共是 30 个数字牌子； 在二进制下，0~999 是 0~1111100111，我们至少需要十位，每位是 0 或 1，所以一共是 20 个数字牌子； 在三进制下，0~999 是 0~1101000，至少七位，每位是 0、1 或 2，所以一共是 21 个数字牌子； 在四进制下，0~999 是 0~33213，需要 20 个数字牌子； 在五进制下，0~999 是 0~12444，需要 25 个数字牌子； … 这些数字牌子的个数就是 $表达这些信息所需的资源$。到目前为止，似乎二进制和四进制的效率最高。 但这样理解并不完全准确。因为实际上， 对于某些进制而言，对应数量的数字牌子其实不止能表达这么多信息。比如在二进制情况下，20 个数字牌子表达的数字总量应该是 $2^{10} = 1024 $ 个；在三进制的情况下，21个数字牌子表达的数字总量却是 $3^7 = 2187$ 个；在四进制的情况下，20 个数字牌子表达的数字总量是 $4^5 = 1024$ 个… 也就是说，虽然对于上边十进制而言，它那 30 个牌子表达的信息量确实就是 0~999 这 1000 个数字的信息，或者我们说 1000 种状态信息，但对于下边的比如二进制、三进制、四进制，对应的 20 个、21个、20个牌子其实表达了超过 1000 种状态，我们用这些牌子是有浪费的。 这么来算，我们大致可以得到，十进制的效率是 $\\frac{1000}{30} \\approx 33.3333$，二进制的效率是 $\\frac{1024}{20} = 51.2$，三进制的效率是 $\\frac{2187}{21} \\approx 104.1429$，四进制的效率是 $\\frac{1024}{20} = 51.2$… 从这个例子我们已经大概能看到三进制的效率了，那么怎么证明这件事儿呢？ 回顾上边的思考过程，我们的数字牌子个数是怎么被算出来的呢？我们大概可以总结出：$$数字牌子的个数 = 进制数 \\times 所需的位数$$而为了满足上边的表达 1000 个状态的要求，所以我们要求：$$进制数^{所需的位数} \\geq 1000$$也就是说：$$所需的位数 = 向上取整（log_{进制数}1000）$$因为进制数必须是整数，所以我们必须加上 $向上取整$，但就是因为这个向上取整，我们浪费了很多的资源，所以我们先假设 $进制数$ 是个实数。 那么现在对上面 $数字牌子的个数$ 的式子改成 $表达这些信息所需的资源$，这样这个式子就成了下边这样：$$表达这些信息所需的资源 = 进制数 \\times log_{进制数}表达的信息量$$记 $表达这些所需的资源$ 为 $R$，$进制数$ 为 $N$，$表达的信息量$ 为 $I$：$$R = N \\times log_NI$$记效率为 $E$，那么：$$E = \\frac{I}{R} = \\frac{I}{Nlog_NI} = \\frac{I}{lnI}\\times\\frac{lnN}{N}$$求导$$\\frac{dE}{dN} = \\frac{I}{lnI}\\times\\frac{1-lnN}{N^2}$$分析单调性，我们知道，当 $N = e$ 时，效率 $E$ 最大。 所以也就是，e 进制 理论上才是效率最高的进制。 但是，e 进制是个啥呢？试试 e 附近的 2 和 3，得到 $E(2) \\approx 0.3466\\times\\frac{I}{lnI}$，$E(3)\\approx 0.3662\\times\\frac{I}{lnI}$，所以，三进制是理论上效率最高的进制。 为什么没用三进制？在上边的两个引用里，知乎大佬 @白云龙 和 b 站 up 主 @差评君 都给出了一些答案。@白云龙 大佬的说法是，在实际的实现过程中，实现二进制的“牌子”和实现三进制的“牌子”的成本不一样，可能二进制的01牌子就便宜好用，但三进制的牌子就是又贵又难用，最后所需的资源还要乘上每个牌子的单价，加上这层因素后，二进制比三进制更经济。这其实也就是 @差评君 所言的，二进制只需高低电平来区分01，但三进制需要实现三种电流状态就比较复杂。 但其实我觉得，这样的问题并不是什么太大的问题，就像 SLC、MLC、TLC 一样。既然我们都可以在同样的电子数的情况下分别实现 2、4、8种状态的区别，那多实现一个除了01以外的第三个状态似乎也类似？(我瞎说的哦，别当真，大佬轻喷…)。主要是，二进制计算机确实已经走到了这样一个瓶颈期，我们的芯片制程来到了十几纳米甚至几纳米、我们的光刻机使用的光已经来到了极紫外光的情况下，想要进一步提升二进制计算机的一丁点性能所消耗的成本是极其庞大的。但是，三进制却是一条新的路，也许就是一条出路。 如果我们把视角从全人类缩到我们中国，在这个光刻机远远落后于欧美的情况下，或许三进制，真的就是我们中国的出路。 参考资料 《为什么计算机不用 e 进制，按道理说 e 进制难道不是最高效的吗？ - 知乎 (zhihu.com)》 苏联的三进制电脑，为什么被二进制干掉了？【差评君】哔哩哔哩 《SLC、MLC、TLC 颗粒的区别是什么 | Crucial (英睿达) | Crucial 英睿达》","link":"/posts/1d122915.html"},{"title":"VS Code 中文乱码问题","text":"2023 年 1 月 12 日更新： 找到了方便地改变 Windows 中终端默认编码的方法，所以原来的改变 C/C++ 文件默认编码的方法可以淘汰了。 现在的新办法是： 打开 “控制面板 - 时钟和区域 - 区域 - 管理 - 更改系统区域设置(C)…” 勾选 “Beta 版: 使用 Unicode UTF-8 提供全球语言支持(U)” 确定，重启电脑。 打开 CMD 测试一下，输入 chcp 可以发现已经变成了 65001，说明成功了。 方法来源：《Git Bash 中文显示乱码，options 修改为 zh_CN 和 utf-8 还是不行怎么办？看这里_bboy 枫亭的博客 - CSDN 博客_git +options》 以下是原来的文章 开门见山，我最后采用的解决方案是对 C/C++ 文件单独设置默认编码。大致的操作方法是，打开 VS Code 的 settings.json 文件，添加如下配置： 123456&quot;[cpp]&quot;: { &quot;files.encoding&quot;: &quot;gbk&quot;},&quot;[c]&quot;: { &quot;files.encoding&quot;: &quot;gbk&quot;} 具体的操作请参见原文：《VSCODE C 语言终端输出中文乱码编码设置》 解决过程复盘一下解决这个问题的过程。 首先了解到的是 VS Code 中文乱码的根本原因——VS Code 默认的编码格式是 UTF-8 （这一点可在 VS Code 右下角看到），而 VS Code 调用的终端是 CMD，默认的编码格式是 gbk。所以解决方案就是两个方向：要么是更改终端的默认编码，从默认的 gbk 转为 utf8；要么就是更改 VS Code 中的 C/C++ 文件的编码。 2022/10/26 更新： 看到一个有意思的科普视频，贴在这里，可以看看乱码到底是如何产生的。 00:15:00 锟斤拷�⊠是怎样炼成的——中文显示“⼊”门指南【柴知道】 422.4万 1.9万 视频 柴知道 第一个方向：更改终端默认编码了解到更改 CMD 编码为 utf8 的命令如下： 1chcp 65001 顺便一提，查看当前编码的命令为： 1chcp chcp 65001 这串命令的意思就是更改代码页为 65001，也就是用 utf8 编码。 这串命令不是永久生效的，所以每次都要输入，比较麻烦。网上也有一些解决方案，比如通过修改注册表每次都自动运行一下上边的命令（《修改 Windows10 命令终端 cmd 的编码为 UTF-8》），或者是配置 VS Code 让其自动输入的（《永久解决 VS Code 终端中文乱码问题》），可以去看看。 第二个方向：更改 VS Code 中的 C/C++ 文件的编码最初这个方法我只是想临时解决一下，就比较简单。点一下右下角的 UTF-8，选择 通过编码重新打开，选择 gbk 就行了。但这样只有一次，然后就想看看有没有永久的方法，便看到了上边的文章。 顺便一提，这里可能还要把 VS Code 设置中的自动猜测编码功能打开，具体操作如下： 使用 Ctrl + , 快捷键打开设置； 在搜索框输入 encoding ，找到 Files:Auto Guess Encoding，勾上它。 参考资料 《VSCODE C 语言终端输出中文乱码编码设置》 《修改 Windows10 命令终端 cmd 的编码为 UTF-8》 《永久解决 VS Code 终端中文乱码问题》","link":"/posts/ca05bed5.html"},{"title":"Simple git tutorial","text":"This is a simple tutorial of git, also including some info about GitHub. Before we start, there are two questions we must know. What is git? &amp;&amp; What is GitHub? Git is a free and open-source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. This is an introduction to git on its official website. Simply speaking, git is a version control software.And what is GitHub? GitHub is a website, a platform and a community, which provides developers place to store and share their codes. Since it use git as its version control software, it got a name “GitHub”. Here is GitHub. Creating a GitHub accountThe official tutorial for creating a GitHub account is here: Signing up for a new GitHub account - GitHub Docs Downloading and installing gitYou can download git from here. For detailed installing steps in windows, this maybe helpful:Git 详细安装教程（详解 Git 安装过程的每一个步骤） Configuring gitTo configure user info for all local repositories: 12git config --global user.name &quot;&lt;your_name&gt;&quot;git config --global user.email &quot;&lt;your_email@example.com&gt;&quot; Connecting to GitHubOpen your git bash, and run: 1ssh-keygen -t ed25519 -C &quot;&lt;your_email@example.com&gt;&quot; For old system, you may run: 1ssh-keygen -t rsa -b 4096 -C &quot;&lt;your_email@example.com&gt;&quot; Go to Your profile on GitHub. Click SSH and GPG keys on the left. Click New SSH key. Choose a title, and paste all content in ~/.ssh/id_ed25519.pub. Then click Add SSH key. Learn more from here. Simply explaining what we’ve done. ssh-keygen is a tool that help us create a key(~/.ssh/id_ed25519) and a lock(~/.ssh/id_ed25519.pub). Then, we use the id_ed25519.pub file to lock our repos on GitHub, and leave the id_ed25519, the key, in our PC. We can then avoid repeating login GitHub. Simple git commands1234567891011121314151617# Creating a new repogit clone# Checking out a repogit clone &lt;username&gt;@&lt;host&gt;:&lt;/path/to/repo&gt;# Connecting to your repo on GitHubgit remote add origin &lt;server&gt;# Addinggit add &lt;directory&gt;/&lt;file&gt;# Committinggit commit -m &quot;&lt;commit_message&gt;&quot;# Pushinggit push origin &lt;branch&gt; Learn moreGit 详细安装教程（详解 Git 安装过程的每一个步骤） git - the simple guide - no deep shit! git - the simple guide - no deep shit! - zh GitHub Training Kit","link":"/posts/9363e311.html"},{"title":"Package managers in Linux (To be continued)","text":"This post tries to simply introduce some package managers and their basic usage. pacmanThe pacman package manager is the default package manager of Arch Linux. Learn more about pacman on the official wiki here. pacman - Changing to mirrorBefore you start to use pacman, changing its source to mirror source in your country might be greatly helpful. Firstly, find a mirror you need on Mirror Overview of ArchLinux offical site. Here I choose the mirror from my mother school, whose URL is https://mirrors.njupt.edu.cn/archlinux/. Then, edit /etc/pacman.d/mirrorlist , and paste the string below into the file. 1Server = https://mirrors.njupt.edu.cn/archlinux/$repo/os/$arch Last, save the file and run sudo pacman -Syu to update. The file /etc/pacman.d/mirrorlist has already provided many mirrors in it. So you can just skip the first step above, just edit the mirrorlist file. Find the server you want, and delete the # at the begining of that line to uncomment it. For an easy copy, here are some mirrors in China: 1234567891011### China## Aliyun# Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch## Netease# Server = https://mirrors.163.com/archlinux/$repo/os/$arch## Tsinghua# Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch## NJU# Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch## NJUPT# Server = https://mirrors.njupt.edu.cn/archlinux/$repo/os/$arch pacman - Upgrading packagesRun the command below to upgrade packages. 1sudo pacman -Syu You are recommended to immediately run this command after changing to a mirror. pacman - Querying package(s)To find the package you need in the sync database: 1pacman -Ss &lt;package_name&gt; The “s” in the small case means “search”. To list the packages installed: 1234pacman -Qq // list all the packages, ignore version (-q)pacman -Qqe // list explicitly installed packages (-e)pacman -Qqd // list the packages installed as dependencies (-d)pacman -Qqdt // list the packages which are no longer dependencies (-t), usually can be removed pacman - Installing package(s)This command helps install one or more packages. 1sudo pacman -S &lt;package_name1&gt; &lt;package_name2&gt; ... For example, to install bat, run: 1sudo pacman -S bat pacman - Removing package(s)This command helps remove a single package, leaving all of its dependencies installed: 1sudo pacman -R &lt;package_name&gt; To remove a package and its dependencies that are not required by any other installed package: 1sudo pacman -Rs &lt;package_name&gt; Here I found a helpful article that provides more information: 《Arch Linux 软件包的查询及清理》. APTThe APT(Advanced Packaging Tools) is(Maybe “are”? Since it’s “tools”?) widely used in Debian and Ubuntu etc. It mainly includes apt-get ,apt-cache and apt-file. APT - Changing to mirrorTake Tsinghua’s mirror as an example: 12345678910111213141516171819## Tsinghua## from https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse APT - Useful commands1234567891011sudo apt update // update the package info sudo apt upgrade // upgrade all the packages installedapt list --upgradeable // list all the packages that can upgradesudo apt install &lt;package_name&gt; // install a specific packagesudo apt install -f // fix the dependenciessudo apt remove &lt;package_name&gt; // remove a specific packagesudo apt autoremove // auto remove the packages that no longer neededapt show &lt;package_name&gt; // show the info about a specific package To be continued","link":"/posts/4ee6ac78.html"},{"title":"error: summary string parsing error 错误解决方法","text":"直接先说解决方法：在使用 clang 工具链进行编译的时候，添加编译选项 -fstandalone-debug。 下边是完整的发现及解决问题的过程。 发现问题在按照 《使用 VS Code + Clangd + CMake 搭建 C/C++ 开发环境》 搭建我在 ArchWSL 内的 C/C++ 开发环境时，我创建了一个用于测试的 HelloWorld 工程。这个工程的文件结构长这样： 12345.├── build├── .clang-format├── CMakeLists.txt└── main.cpp 12345678# @file CMakeLists.txt# oldcmake_minimum_required(VERSION 3.10)project(HelloWorld)add_executable(HelloWorld main.cpp) 123456789101112// @file main.cpp#include &lt;iostream&gt;#include &lt;string&gt;int main(){ int a = 10; std::string str = &quot;你好&quot;; std::cout &lt;&lt; str &lt;&lt; std::endl; return 0;} 调试的时候发现，int 型变量 a 是可以查看的，但 std::string 型的变量 str 却显示 error: summary string parsing error 错误。 问题解决在测试中我发现，这个问题只在我使用 clang 工具链编译时产生，使用 g++ 就没有这个问题，所以猜测不是 lldb 调试器的问题，而是 clang 编译器的问题。 在网上搜索到了类似的问题： 无法在 lldb 中检查 std::string 变量 - 问答 - 腾讯云开发者社区 Cannot inspect any strings · Issue #415 · vadimcn/vscode-lldb 都说要使用 -fstandalone-debug 重新编译。 于是修改 CMakeLists.txt 为： 1234567891011121314# @file CMakeLists.txt# newcmake_minimum_required(VERSION 3.10)project(HelloWorld)# 如果使用的是 clang 工具链，那么需要添加上 -fstandalone-debug，否则 lldb 无法查看 std::string 的东东# 见 https://cloud.tencent.com/developer/ask/sof/1542916# 又见 https://github.com/vadimcn/vscode-lldb/issues/415add_compile_options(-fstandalone-debug)message(STATUS &quot;optional: -fstandalone-debug&quot;)add_executable(HelloWorld main.cpp) 至此成功解决。","link":"/posts/78dc947f.html"},{"title":"Useful packages in Java","text":"A simple conclusion of some useful packages in java. java.ioClassification by type of streamStream of charactersReader BufferedReader InputStreamReader FileReader StringReader PipedReader CharArrayReader FilterReader PushbackReader Writer BufferedWriter OutputStreamWriter FileWriter PrinterWriter StringWriter PipedWriter CharArrayWriter FilterWriter Stream of bytesInputStream FileInputStream FilterInputStream BufferedInputStream DataInputStream PushbackInputStream ObjectInputStream PipedInputStream SequenceInputStream StringBufferInputStream ByteArrayInputStream OutputStream FileOutputStream FilterOutputStream BufferedOutputStream DataOutputStream PrintStream ObjectOutputStream PipedOutputStream ByteArrayOutputStream Classification by operation objectFile FileReader FileWriter FileInputStream FileOutputStream ArrayByteArray ByteArrayInputStream ByteArrayOutputStream CharArray CharArrayReader CharArrayWriter Pipe PipedReader PipedWriter PipedInputStream PipedOutputStream Data (basic data types) DataInputStream DataOutputStream Buffer BufferedReader BufferedWriter BufferedInputStream BufferedOutputStream Print PrinterWriter PrintStream Object serialization ObjectInputStream ObjectOutputStream Stream transformation InputStreamReader OutputStreamWriter java.langSystemProcess Process ProcessBuilder Thread Thread ThreadGroup ThreadDeath ThreadLocal Run Runnable Runtime RuntimePermission System Stack StackTraceElement Exception - ThrowableError NoClassDefFoundError NoSuchFieldError OutOfMemoryError NoSuchMethodError Exception ArrayIndexOutOfBoundsException ClassCastException ClassNotFoundException IllegalArgumentException IndexOutOfBoundsException NoSuchFieldException NoSuchMethodException NullPointerException NumberFormatException RuntimeException InterruptedException Annotationjava.lang Deprecated FunctionalInterface Override SafeVarargs SuppressWarnings java.lang.annotation Documented Inherited Native Repeatable Retention Target Interfacejava.lang AutoCloseable Annotation CharSequence Cloneable Comparable Iterable Readable Runnable java.lang.reflect InvocationHandler GenericDeclaration AnnotatedElement Member TypeBasic type Boolean Character String Number Byte Short Integer Long Float Double Class Class Package Package Other Object Enum Void Tool classCharacter serial StringBuffer StringBuilder Math java.lang.Math NOTICE: not java.math Reflectionjava.lang.reflect Array Constructor Field Method Proxy Executable AccessibleObject java.mathNOTICE: not java.lang.Math BigDecimal BigInteger MathContext RoundingMode To be continuedjava.net","link":"/posts/a4746c9.html"},{"title":"Replace cat with bat","text":"When using Linux, I often use cat to browse some short codes. But it doesn’t support syntax highlighting originally. So, I found one of its replacements: bat. Brief introduction On BAT‘s official GitHub page, it defines itself “a cat clone with wings”. In my opinion, one is “syntax highlighting”, and the other is “git integration”. Here are some of its important features: Syntax highlighting Git integration Show non-printable characters Automatic paging InstallationIn ArchLinux, you can run: 1sudo pacman -S bat In Termux, you can run: 1pkg install bat In Ubuntu, you can run: 1sudo apt install bat Learn more on BAT‘s GitHub page. Usage123456789# Display a single file:bat &lt;filename&gt;# Display multi files at once:bat &lt;filename1&gt; &lt;filename2&gt; ...# Show and highlight non-printable characters:bat -A &lt;filename&gt; # orbat --show-all &lt;filename&gt; Learn more on BAT‘s GitHub page. ConfigurationYou can use BAT’s configuration file to customize your BAT. To generate a default config file, run: 1bat --generate-config-file Here is an example: 12345# Set the theme--theme=&quot;Dracula&quot;# Use C++ syntax for Arduino .ino files--map-syntax &quot;*.ino:C++&quot;","link":"/posts/e7bc2e88.html"},{"title":"The chmod command in Linux","text":"I accidentally ran a wrong chmod command in my Linux, and it messed up everything! I hate the permission management in Linux. :| PERMISSION MANAGEMENT IN LINUXWhen you run ls -l in your terminal, you can always see strings like -rw-r–r– and drwxr-xr-x etc. To understand them, we can always split a such string into four part. The first one is a single character, - if it’s a file and d if it’s a directory. The rest 9 characters can be equally divided into three parts, representing the permission of the owner, the members of the group and other users relatively. Every part contains three characters, showing the permission of r(read), w(write) and x(execute). Besides the bit pattern, you can also use octal notation to express these permissions, which uses 4 for r, 2 for w and 1 for x. The sum of these octal numbers then can replace the rwx pattern. For example, using 6 for rw. Why is 4, 2 and 1? Actually, you can view every 3-character unit as 3 binary bits. So, 100(r–) means 4 in decimal, 010(-w-) means 2, and 001(–x) means 1. You can then understand what dose the sum means. Now, you can read this: 1234567-rw------- # (600) Owner:RW-rw-r--r-- # (644) Owner:RW Group:R Other:R-rw-rw-rw- # (666) Owner:RW Group:RW Other:RW-rwx------ # (700) Owner:RWX-rwx--x--x # (711) Owner:RWX Group:X Other:X-rwxr-xr-x # (755) Owner:RWX Group:RX Other:RX-rwxrwxrwx # (777) Owner:RWX Group:RWX Other:RWX DEFAULT PERMISSIONThe default permission for a file is 666, which means -rw-rw-rw-, indicating that the owner, group and other users can read and write the file. The default permission for a directory is 777, which means drwxrwxrwx, indicating that the owner, group and other users can read, write and access the directory. However, these default permissions are affected by the user’s umask setting. The umask is a value that controls which permissions are removed when creating a new file or directory. For example, if the user’s umask is 022, then the write permission for group and other users will be removed when creating a new file, and the write and execute permission for group and other users will be removed when creating a new directory. Therefore: The actual default permission for a file is 666 - 022 = 644, which means -rw-r–r–. The actual default permission for a directory is 777 - 022 = 755, which means drwxr-xr-x. You can run the umask command to see what your setting is. THE CHMOD COMMAND 1chmod [-cfvR] [--help] [--version] &lt;mode&gt; &lt;file&gt;... The -R means recursively. You will need it. The most important part is &lt;mode&gt; obviously. Its pattern is: 1[ugoa...][[+-=][rwxX]...][,...] [ugoa…]: u means user, g means group, o means other, and a means all. [+-=]: + means adding permission, - means removing, and = means setting the permissions for a specific user type, regardless of the previous permissions. [rwxX]: You have known rwx, and the X means setting the execute permission only if the file is a directory or already has execute permission for some user. For example: 1234chmod u+x &lt;file&gt; # adding execute permission to the owner of the file, and leaving the group and other permissions unchangedchmod o-rwx &lt;file&gt; # removing all permissions from others, and leaving the owner and group permissions unchangedchmod a=r &lt;file&gt; # setting all user types’ permissions to read only, overwriting any previous permissionschmod a+X &lt;file&gt; # adding execute permission to all user types only if file is a directory or already executable by some user You can also use octal pattern represents the &lt;mode&gt;. For example: 1chmod 777 &lt;file&gt; # now everyone can read, write and execute the &lt;file&gt; CHANGE PERMISSIONS TO FILE OR DIR INDIVIDUALLYTo change permissions to file or dir individually, you can use the -exec option of find to execute chmod on each matching file or directory. For example: To find all files in the current directory and its subdirectories and change their permissions to 644, you can use: find . -type f -exec chmod 644 {} ; -type f means file. You can use -type d to find all the dir. THANKSBy the way, this blog was completed with the help of new bing. I asked her many questions and got great answers. She also helped me correct errors and polish my writing. She is just too amazing! REFERENCE 《Linux chmod 命令 | 菜鸟教程》 《Linux 权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）》","link":"/posts/a9dc5c1e.html"},{"title":"Uses std::cin.ignore() to keep the user typing until the input meets the requirements","text":"I used to control users’ input by making the input a string and process it later. But today, my friend posed this question to me: Can we control input without a char array or string class? On cppreference.com, I found std::cin.ignore(). This function can help us solve the previous question. Here is an example: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;limits&gt;int main() { int n = 0; while (true) { std::cout &lt;&lt; &quot;Please input a number: &quot;; std::cin &gt;&gt; n; if (!std::cin.good()) { std::cerr &lt;&lt; &quot;Error input.&quot; &lt;&lt; std::endl; std::cin.clear(); std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); continue; } else { break; } } std::cout &lt;&lt; &quot;Your input is: &quot; &lt;&lt; n &lt;&lt; std::endl; return 0;}","link":"/posts/f96b3358.html"},{"title":"VS Code 中设置显示最大列数边界线","text":"很多时候我们会避免一行代码过长，常见的限制有 80 字符、120 个字符等。我希望能在 VS Code 中显示一条边界线来提醒我已经到达这个限制了，需要换行。下边是设置的方法。 打开设置（快捷键 Ctrl+,），搜索 Editor: Rulers，点击 “在 settings.json” 中编辑，添加如下内容： 1&quot;editor.rulers&quot;: [80,120] 当然你也可以按照自己的喜好设置字符数。","link":"/posts/bb929dc9.html"},{"title":"Makefile 简单笔记","text":"这是一篇笔记，原视频是 @于仕琪 老师的 《Makefile 20 分钟入门，简简单单，展示如何使用 Makefile 管理和编译 C++ 代码》。 老师所给的四个版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 版本一hello: main.cpp printhello.cpp factorial.cpp g++ -o hello main.cpp printhello.cpp factorial.cpp# 版本二CXX = g++TARGET = helloOBJ = main.o printhello.o factorial.o$(TARGET): $(OBJ) $(CXX) -o $(TARGET) $(OBJ)main.o: main.cpp $(CXX) -c main.cppprinthello.o: printhello.cpp $(CXX) -c printhello.cppfactorial.o: factorial.cpp $(CXX) -c factorial.cpp# 版本三CXX = g++TARGET = helloOBJ = main.o printhello.o factorial.oCXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) -o $@ $^%.o: %.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET)# 版本四CXX = g++TARGET = helloSRC = $(wildcard *.cpp)OBJ = $(patsubst %.cpp, %.o, $(SRC))CXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) -o $@ $^%.o: %.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) 知识点首先是关于 g++ 这个 C++ 编译器的一些知识点。 -c 参数表示生成 obj 文件（*.o）； -o 用于指定生成的可执行文件的名称，比如上边 -o hello 就表示生成的可执行文件叫 hello； -Wall 表示 Warning all，也就是打开全部的警告。 接着是 Makefile 文件的大致原理。 首先看最易理解的版本一。 12hello: main.cpp printhello.cpp factorial.cpp g++ -o hello main.cpp printhello.cpp factorial.cpp 第一行冒号前的部分表示我们需要的文件（这里是 hello），冒号后表示冒号前文件的依赖项（这里是三个 .cpp 文件），第二行表示为了生成冒号前的文件，需要执行什么命令。Make 工具通过检测冒号后文件的时间戳是否比冒号前文件更新来判断是否要执行第二行语句。 在第二个版本中，引入了变量的概念。形似 XXX = YYY 的东西就是在给变量赋值，使用 $(XXX) 来取得值 YYY。 第三个版本中出现了 $@、$^、$&lt; 等符号，他们分别表示冒号前面的内容、冒号后边的全部内容和冒号后边第一个内容。 第三个版本中的 .PHONY: clean 标识了 clean 是个命令而不是一个文件，这样结合下边的 clean: 的内容，就可以实现直接在终端输入 make clean 来执行 rm -f *.o $(TARGET) 的命令，清空生成出来的文件。","link":"/posts/b5f1b38d.html"},{"title":"The const and constexpr in C++ (REMAKE)","text":"I have written a post about const in C++ in Chinese before, but it was too verbose and unclear. :( So, I decided to rewrite it. BASIC USAGE OF CONSTMODIFIES BASIC DATE TYPE WITH CONSTThe most basic usage of const is to define a constant. A constant is a variable whose value cannot be changed after initialization. 123456int a = 1;const double b = 1.0; // now b is immutablea = 2; // a is a variable. It's okay.// b = 2.0; // WRONG! b is a constant. MODIFIES POINTERS WITH CONSTWhen it comes to pointers, const can be used in two ways: top-level const and low-level const. Top-level const means that the pointer itself is a constant, i.e. you can’t change what it points to.Low-level const means that the object that the pointer points to is a constant, i.e. you can’t change the value of that object through this pointer. For example: 123456789101112131415int x = 1;int y = 2;int *const p1 = &amp;x; // top-level constconst int *p2 = &amp;x; // low-level constconst int *const p3 = &amp;x; // The first is low-level // The second is top-level// p1 = &amp;y; // WRONG! p1 is a constant pointer, it can't change its direction.*p1 = y; // OKp2 = &amp;y; // OK// *p2 = y; // WRONG! p2 points at a constant.// p3 = &amp;y; // WRONG!// *p3 = y; // WRONG! MODIFIES REFERENCE WITH CONSTFor reference, there is only one way to use const: const T &amp; (T is type name). Reference itself (like T &amp;) is always top-level, since you can’t change what it refers to after its initialization. So, const T &amp; makes the reference both top-level and low-level. MODIFIES OBJECTS WITH CONSTModifying an object with const means that this object is immutable after its initialization. 1const std::string str = &quot;This is an immutable string.&quot;; CONST IN FUNCTIONSCONST IN PARAMETER LISTA parameter modified with const means it is read-only to the function. Usually, we use this feature together with reference. So, when we don’t want a function to change a specific argument, the parameter’s type may look like const T &amp;. 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename T&gt;void Show(const T &amp;);int main() { std::string str = &quot;This is an example.&quot;; Show(str); return 0;}template &lt;typename T&gt;void Show(const T &amp;in) { // in is read-only std::cout &lt;&lt; in &lt;&lt; std::endl;} THE CONST AFTER A MEMBER FUNCTIONThe const after a member function indicates that the function does not modify any non-mutable data members of the class. In other words, this means that the this pointer is const, implying that this member function does not alter the state of this object. 1234567891011121314151617181920212223#include &lt;iostream&gt;class Fish { private: double weight_; public: Fish() : weight_(0) {} Fish(const double&amp; weight) : weight_(weight) {} void ModifyWeight(const double&amp; weight); void ShowWeight() const; // Just show the weight. Read-only.};void Fish::ModifyWeight(const double&amp; weight) { this-&gt;weight_ = weight; }void Fish::ShowWeight() const { std::cout &lt;&lt; this-&gt;weight_ &lt;&lt; std::endl; }int main() { Fish fish(5.0); fish.ShowWeight(); fish.ModifyWeight(10.0); fish.ShowWeight(); return 0;} RETURNS A CONSTWhen returning an object, the const before the return type indicates that this object is a constant and is immutable. For example: const int&amp; GetAgeConst(), which returns a rvalue whose referenced content cannot be modified. When return a pointer type (or a reference), const helps protect the pointer or reference content from being modified. For example: const char * const Fun(), which returns a pointer to a constant, whose pointed content and the pointer itself cannot be modified. Here is an example generated by new bing: 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class Person { private: int age; public: Person(int a) : age(a) {} const int&amp; GetAgeConst() const { return age; }};int main() { Person p(20); cout &lt;&lt; &quot;The age is &quot; &lt;&lt; p.GetAgeConst() &lt;&lt; endl; // p.GetAgeConst() = 30; // WRONG return 0;} CONSTEXPR (NEW IN C++11)constexpr keyword helps the compiler find those constant expressions at compile stage. A really common place of use is defining an array: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;constexpr int GetConstexprLen();constexpr int Fibonacci(const int n);int main() { int variable_len = 10; const int const_len = 10; constexpr int constexpr_len = 10; // int arr1[variable_len]; // Illegal. Not OK. // int arr2[const_len]; // Illegal. But usually OK. int arr3[constexpr_len]; // Legal. OK. int arr4[GetConstexprLen()]; // Legal. OK. int arr5[Fibonacci(5)]; // Legal. OK. return 0;}constexpr int GetConstexprLen() { return 10; }constexpr int Fibonacci(const int n) { // These codes are from https://changkun.de/modern-cpp/ // You can't use local variables, loops, // and conditional statements here in C++11 // But in C++14, that's OK. return n == 1 || n == 2 ? 1 : Fibonacci(n - 1) + Fibonacci(n - 2);} To learn more, you may read Modern C++ Tutorial","link":"/posts/3358bcc1.html"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编译链接","slug":"编译链接","link":"/tags/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"推荐","slug":"推荐","link":"/tags/%E6%8E%A8%E8%8D%90/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"Edge","slug":"Edge","link":"/tags/Edge/"},{"name":"问题","slug":"问题","link":"/tags/%E9%97%AE%E9%A2%98/"},{"name":"已解决","slug":"已解决","link":"/tags/%E5%B7%B2%E8%A7%A3%E5%86%B3/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"RLCraft","slug":"RLCraft","link":"/tags/RLCraft/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"Element UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Bulma","slug":"Bulma","link":"/tags/Bulma/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"建模","slug":"建模","link":"/tags/%E5%BB%BA%E6%A8%A1/"},{"name":"Blender","slug":"Blender","link":"/tags/Blender/"},{"name":"Hexo插件","slug":"Hexo插件","link":"/tags/Hexo%E6%8F%92%E4%BB%B6/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"随机数生成器","slug":"随机数生成器","link":"/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"NovelAI","slug":"NovelAI","link":"/tags/NovelAI/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"函数传参","slug":"函数传参","link":"/tags/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"二维数组","slug":"二维数组","link":"/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"iomanip","slug":"iomanip","link":"/tags/iomanip/"},{"name":"最大公约数","slug":"最大公约数","link":"/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"搜索算法","slug":"搜索算法","link":"/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"宽度优先搜索","slug":"宽度优先搜索","link":"/tags/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"文件","slug":"文件","link":"/tags/%E6%96%87%E4%BB%B6/"},{"name":"进制","slug":"进制","link":"/tags/%E8%BF%9B%E5%88%B6/"},{"name":"科普","slug":"科普","link":"/tags/%E7%A7%91%E6%99%AE/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"包管理器","slug":"包管理器","link":"/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"ArchLinux","slug":"ArchLinux","link":"/tags/ArchLinux/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"pacman","slug":"pacman","link":"/tags/pacman/"},{"name":"APT","slug":"APT","link":"/tags/APT/"},{"name":"错误","slug":"错误","link":"/tags/%E9%94%99%E8%AF%AF/"},{"name":"解决方案","slug":"解决方案","link":"/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"调试","slug":"调试","link":"/tags/%E8%B0%83%E8%AF%95/"},{"name":"LLDB","slug":"LLDB","link":"/tags/LLDB/"},{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"Clang","slug":"Clang","link":"/tags/Clang/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"cat","slug":"cat","link":"/tags/cat/"},{"name":"bat","slug":"bat","link":"/tags/bat/"},{"name":"chmod","slug":"chmod","link":"/tags/chmod/"},{"name":"Makefile","slug":"Makefile","link":"/tags/Makefile/"},{"name":"GNU Make","slug":"GNU-Make","link":"/tags/GNU-Make/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"推荐","slug":"推荐","link":"/categories/%E6%8E%A8%E8%8D%90/"},{"name":"C&#x2F;C++","slug":"学习/C-C","link":"/categories/%E5%AD%A6%E4%B9%A0/C-C/"},{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"编译链接","slug":"学习/编译链接","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/"},{"name":"Web","slug":"学习/Web","link":"/categories/%E5%AD%A6%E4%B9%A0/Web/"},{"name":"游戏","slug":"游戏","link":"/categories/%E6%B8%B8%E6%88%8F/"},{"name":"建模","slug":"学习/建模","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%BB%BA%E6%A8%A1/"},{"name":"车","slug":"学习/车","link":"/categories/%E5%AD%A6%E4%B9%A0/%E8%BD%A6/"},{"name":"LaTeX","slug":"学习/LaTeX","link":"/categories/%E5%AD%A6%E4%B9%A0/LaTeX/"},{"name":"数学","slug":"学习/数学","link":"/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E5%AD%A6/"},{"name":"Hexo","slug":"学习/Web/Hexo","link":"/categories/%E5%AD%A6%E4%B9%A0/Web/Hexo/"},{"name":"AI","slug":"学习/AI","link":"/categories/%E5%AD%A6%E4%B9%A0/AI/"},{"name":"Minecraft","slug":"游戏/Minecraft","link":"/categories/%E6%B8%B8%E6%88%8F/Minecraft/"},{"name":"Vue.js","slug":"学习/Web/Vue-js","link":"/categories/%E5%AD%A6%E4%B9%A0/Web/Vue-js/"},{"name":"Blender","slug":"学习/建模/Blender","link":"/categories/%E5%AD%A6%E4%B9%A0/%E5%BB%BA%E6%A8%A1/Blender/"},{"name":"NovelAI","slug":"学习/AI/NovelAI","link":"/categories/%E5%AD%A6%E4%B9%A0/AI/NovelAI/"},{"name":"RLCraft","slug":"游戏/Minecraft/RLCraft","link":"/categories/%E6%B8%B8%E6%88%8F/Minecraft/RLCraft/"},{"name":"算法","slug":"学习/算法","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"},{"name":"搜索算法","slug":"学习/算法/搜索算法","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"最大公约数","slug":"学习/算法/最大公约数","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"name":"VS Code","slug":"学习/VS-Code","link":"/categories/%E5%AD%A6%E4%B9%A0/VS-Code/"},{"name":"版本控制","slug":"学习/版本控制","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Linux","slug":"学习/Linux","link":"/categories/%E5%AD%A6%E4%B9%A0/Linux/"},{"name":"调试","slug":"学习/调试","link":"/categories/%E5%AD%A6%E4%B9%A0/%E8%B0%83%E8%AF%95/"},{"name":"Java","slug":"学习/Java","link":"/categories/%E5%AD%A6%E4%B9%A0/Java/"},{"name":"git","slug":"学习/版本控制/git","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/"},{"name":"GNU Make","slug":"学习/编译链接/GNU-Make","link":"/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/GNU-Make/"},{"name":"LLDB","slug":"学习/调试/LLDB","link":"/categories/%E5%AD%A6%E4%B9%A0/%E8%B0%83%E8%AF%95/LLDB/"}],"pages":[{"title":"","text":"","link":"/Bookmarks.html"},{"title":"","text":"google-site-verification: google7b9c7ea42a3102a3.html","link":"/google7b9c7ea42a3102a3.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"555aa853c96ff5a922c522a73f469254","link":"/baidu_verify_code-53bseLro2G.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}